"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xyflow";
exports.ids = ["vendor-chunks/@xyflow"];
exports.modules = {

/***/ "(ssr)/./node_modules/@xyflow/react/dist/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode),\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText),\n/* harmony export */   Handle: () => (/* binding */ Handle),\n/* harmony export */   MarkerType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType),\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap),\n/* harmony export */   MiniMapNode: () => (/* binding */ MiniMapNode),\n/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),\n/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),\n/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),\n/* harmony export */   PanOnScrollMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position),\n/* harmony export */   ReactFlow: () => (/* binding */ index),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   ResizeControlVariant: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),\n/* harmony export */   addEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   getBezierEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath),\n/* harmony export */   getConnectedEdges: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectedEdges),\n/* harmony export */   getEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgeCenter),\n/* harmony export */   getIncomers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getIncomers),\n/* harmony export */   getNodesBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOutgoers),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   reconnectEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.reconnectEdge),\n/* harmony export */   useConnection: () => (/* binding */ useConnection),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),\n/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeConnections: () => (/* binding */ useNodeConnections),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesData: () => (/* binding */ useNodesData),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var _xyflow_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @xyflow/system */ \"(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ ConnectionLineType,ConnectionMode,MarkerType,PanOnScrollMode,Position,ResizeControlVariant,SelectionMode,addEdge,getBezierEdgeCenter,getBezierPath,getConnectedEdges,getEdgeCenter,getIncomers,getNodesBounds,getOutgoers,getSmoothStepPath,getStraightPath,getViewportForBounds,reconnectEdge,Background,BackgroundVariant,BaseEdge,BezierEdge,ControlButton,Controls,EdgeLabelRenderer,EdgeText,Handle,MiniMap,MiniMapNode,NodeResizeControl,NodeResizer,NodeToolbar,Panel,ReactFlow,ReactFlowProvider,SimpleBezierEdge,SmoothStepEdge,StepEdge,StraightEdge,ViewportPortal,applyEdgeChanges,applyNodeChanges,getSimpleBezierPath,isEdge,isNode,useConnection,useEdges,useEdgesState,useHandleConnections,useInternalNode,useKeyPress,useNodeConnections,useNodeId,useNodes,useNodesData,useNodesInitialized,useNodesState,useOnSelectionChange,useOnViewportChange,useReactFlow,useStore,useStoreApi,useUpdateNodeInternals,useViewport auto */ \n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst zustandErrorMessage = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error001\"]();\n/**\n * This hook can be used to subscribe to internal state changes of the React Flow\n * component. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)\n * state management library, so you should check out their docs for more details.\n *\n * @public\n * @param selector - A selector function that returns a slice of the flow's internal state.\n * Extracting or transforming just the state you need is a good practice to avoid unnecessary\n * re-renders.\n * @param equalityFn - A function to compare the previous and next value. This is incredibly useful\n * for preventing unnecessary re-renders. Good sensible defaults are using `Object.is` or importing\n * `zustand/shallow`, but you can be as granular as you like.\n * @returns The selected state slice.\n *\n * @example\n * ```ts\n * const nodes = useStore((state) => state.nodes);\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\n/**\n * In some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.\n *\n * @returns The store object.\n * @example\n * ```ts\n * const store = useStoreApi();\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStoreApi() {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            getState: store.getState,\n            setState: store.setState,\n            subscribe: store.subscribe\n        }), [\n        store\n    ]);\n}\nconst style = {\n    display: \"none\"\n};\nconst ariaLiveStyle = {\n    position: \"absolute\",\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: \"hidden\",\n    clip: \"rect(0px, 0px, 0px, 0px)\",\n    clipPath: \"inset(100%)\"\n};\nconst ARIA_NODE_DESC_KEY = \"react-flow__node-desc\";\nconst ARIA_EDGE_DESC_KEY = \"react-flow__edge-desc\";\nconst ARIA_LIVE_MESSAGE = \"react-flow__aria-live\";\nconst ariaLiveSelector = (s)=>s.ariaLiveMessage;\nconst ariaLabelConfigSelector = (s)=>s.ariaLabelConfig;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(ariaLiveSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle,\n        children: ariaLiveMessage\n    });\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    const ariaLabelConfig = useStore(ariaLabelConfigSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: disableKeyboardA11y ? ariaLabelConfig[\"node.a11yDescription.default\"] : ariaLabelConfig[\"node.a11yDescription.keyboardDisabled\"]\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: ariaLabelConfig[\"edge.a11yDescription.default\"]\n            }),\n            !disableKeyboardA11y && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AriaLiveMessage, {\n                rfId: rfId\n            })\n        ]\n    });\n}\n/**\n * The `<Panel />` component helps you position content above the viewport.\n * It is used internally by the [`<MiniMap />`](/api-reference/components/minimap)\n * and [`<Controls />`](/api-reference/components/controls) components.\n *\n * @public\n *\n * @example\n * ```jsx\n *import { ReactFlow, Background, Panel } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[]} fitView>\n *      <Panel position=\"top-left\">top-left</Panel>\n *      <Panel position=\"top-center\">top-center</Panel>\n *      <Panel position=\"top-right\">top-right</Panel>\n *      <Panel position=\"bottom-left\">bottom-left</Panel>\n *      <Panel position=\"bottom-center\">bottom-center</Panel>\n *      <Panel position=\"bottom-right\">bottom-right</Panel>\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const Panel = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ position = \"top-left\", children, className, style, ...rest }, ref)=>{\n    const positionClasses = `${position}`.split(\"-\");\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__panel\",\n            className,\n            ...positionClasses\n        ]),\n        style: style,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n});\nPanel.displayName = \"Panel\";\nfunction Attribution({ proOptions, position = \"bottom-right\" }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"https://reactflow.dev\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            \"aria-label\": \"React Flow attribution\",\n            children: \"React Flow\"\n        })\n    });\n}\nconst selector$m = (s)=>{\n    const selectedNodes = [];\n    const selectedEdges = [];\n    for (const [, node] of s.nodeLookup){\n        if (node.selected) {\n            selectedNodes.push(node.internals.userNode);\n        }\n    }\n    for (const [, edge] of s.edgeLookup){\n        if (edge.selected) {\n            selectedEdges.push(edge);\n        }\n    }\n    return {\n        selectedNodes,\n        selectedEdges\n    };\n};\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\nfunction SelectionListenerInner({ onSelectionChange }) {\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$m, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const params = {\n            nodes: selectedNodes,\n            edges: selectedEdges\n        };\n        onSelectionChange?.(params);\n        store.getState().onSelectionChangeHandlers.forEach((fn)=>fn(params));\n    }, [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n}\nconst changeSelector = (s)=>!!s.onSelectionChangeHandlers;\nfunction SelectionListener({ onSelectionChange }) {\n    const storeHasSelectionChangeHandlers = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChangeHandlers) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListenerInner, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst defaultNodeOrigin = [\n    0,\n    0\n];\nconst defaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\n/*\n * This component helps us to update the store with the values coming from the user.\n * We distinguish between values we can update directly with `useDirectStoreUpdater` (like `snapGrid`)\n * and values that have a dedicated setter function in the store (like `setNodes`).\n */ // These fields exist in the global store, and we need to keep them up to date\nconst reactFlowFieldsToTrack = [\n    \"nodes\",\n    \"edges\",\n    \"defaultNodes\",\n    \"defaultEdges\",\n    \"onConnect\",\n    \"onConnectStart\",\n    \"onConnectEnd\",\n    \"onClickConnectStart\",\n    \"onClickConnectEnd\",\n    \"nodesDraggable\",\n    \"autoPanOnNodeFocus\",\n    \"nodesConnectable\",\n    \"nodesFocusable\",\n    \"edgesFocusable\",\n    \"edgesReconnectable\",\n    \"elevateNodesOnSelect\",\n    \"elevateEdgesOnSelect\",\n    \"minZoom\",\n    \"maxZoom\",\n    \"nodeExtent\",\n    \"onNodesChange\",\n    \"onEdgesChange\",\n    \"elementsSelectable\",\n    \"connectionMode\",\n    \"snapGrid\",\n    \"snapToGrid\",\n    \"translateExtent\",\n    \"connectOnClick\",\n    \"defaultEdgeOptions\",\n    \"fitView\",\n    \"fitViewOptions\",\n    \"onNodesDelete\",\n    \"onEdgesDelete\",\n    \"onDelete\",\n    \"onNodeDrag\",\n    \"onNodeDragStart\",\n    \"onNodeDragStop\",\n    \"onSelectionDrag\",\n    \"onSelectionDragStart\",\n    \"onSelectionDragStop\",\n    \"onMoveStart\",\n    \"onMove\",\n    \"onMoveEnd\",\n    \"noPanClassName\",\n    \"nodeOrigin\",\n    \"autoPanOnConnect\",\n    \"autoPanOnNodeDrag\",\n    \"onError\",\n    \"connectionRadius\",\n    \"isValidConnection\",\n    \"selectNodesOnDrag\",\n    \"nodeDragThreshold\",\n    \"connectionDragThreshold\",\n    \"onBeforeDelete\",\n    \"debug\",\n    \"autoPanSpeed\",\n    \"paneClickDistance\",\n    \"ariaLabelConfig\"\n];\n// rfId doesn't exist in ReactFlowProps, but it's one of the fields we want to update\nconst fieldsToTrack = [\n    ...reactFlowFieldsToTrack,\n    \"rfId\"\n];\nconst selector$l = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,\n        setPaneClickDistance: s.setPaneClickDistance\n    });\nconst initPrevValues = {\n    /*\n     * these are values that are also passed directly to other components\n     * than the StoreUpdater. We can reduce the number of setStore calls\n     * by setting the same values here as prev fields.\n     */ translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n    nodeOrigin: defaultNodeOrigin,\n    minZoom: 0.5,\n    maxZoom: 2,\n    elementsSelectable: true,\n    noPanClassName: \"nopan\",\n    rfId: \"1\",\n    paneClickDistance: 0\n};\nfunction StoreUpdater(props) {\n    const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges, setPaneClickDistance } = useStore(selector$l, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges);\n        return ()=>{\n            // when we reset the store we also need to reset the previous fields\n            previousFields.current = initPrevValues;\n            reset();\n        };\n    }, []);\n    const previousFields = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(initPrevValues);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        for (const fieldName of fieldsToTrack){\n            const fieldValue = props[fieldName];\n            const previousFieldValue = previousFields.current[fieldName];\n            if (fieldValue === previousFieldValue) continue;\n            if (typeof props[fieldName] === \"undefined\") continue;\n            // Custom handling with dedicated setters for some fields\n            if (fieldName === \"nodes\") setNodes(fieldValue);\n            else if (fieldName === \"edges\") setEdges(fieldValue);\n            else if (fieldName === \"minZoom\") setMinZoom(fieldValue);\n            else if (fieldName === \"maxZoom\") setMaxZoom(fieldValue);\n            else if (fieldName === \"translateExtent\") setTranslateExtent(fieldValue);\n            else if (fieldName === \"nodeExtent\") setNodeExtent(fieldValue);\n            else if (fieldName === \"paneClickDistance\") setPaneClickDistance(fieldValue);\n            else if (fieldName === \"ariaLabelConfig\") store.setState({\n                ariaLabelConfig: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.mergeAriaLabelConfig)(fieldValue)\n            });\n            else if (fieldName === \"fitView\") store.setState({\n                fitViewQueued: fieldValue\n            });\n            else if (fieldName === \"fitViewOptions\") store.setState({\n                fitViewOptions: fieldValue\n            });\n            else store.setState({\n                [fieldName]: fieldValue\n            });\n        }\n        previousFields.current = props;\n    }, // Only re-run the effect if one of the fields we track changes\n    fieldsToTrack.map((fieldName)=>props[fieldName]));\n    return null;\n}\nfunction getMediaQuery() {\n    if (true) {\n        return null;\n    }\n    return window.matchMedia(\"(prefers-color-scheme: dark)\");\n}\n/**\n * Hook for receiving the current color mode class 'dark' or 'light'.\n *\n * @internal\n * @param colorMode - The color mode to use ('dark', 'light' or 'system')\n */ function useColorModeClass(colorMode) {\n    const [colorModeClass, setColorModeClass] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(colorMode === \"system\" ? null : colorMode);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (colorMode !== \"system\") {\n            setColorModeClass(colorMode);\n            return;\n        }\n        const mediaQuery = getMediaQuery();\n        const updateColorModeClass = ()=>setColorModeClass(mediaQuery?.matches ? \"dark\" : \"light\");\n        updateColorModeClass();\n        mediaQuery?.addEventListener(\"change\", updateColorModeClass);\n        return ()=>{\n            mediaQuery?.removeEventListener(\"change\", updateColorModeClass);\n        };\n    }, [\n        colorMode\n    ]);\n    return colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? \"dark\" : \"light\";\n}\nconst defaultDoc = typeof document !== \"undefined\" ? document : null;\n/**\n * This hook lets you listen for specific key codes and tells you whether they are\n * currently pressed or not.\n *\n * @public\n * @param options - Options\n *\n * @example\n * ```tsx\n *import { useKeyPress } from '@xyflow/react';\n *\n *export default function () {\n *  const spacePressed = useKeyPress('Space');\n *  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);\n *\n *  return (\n *    <div>\n *     {spacePressed && <p>Space pressed!</p>}\n *     {cmdAndSPressed && <p>Cmd + S pressed!</p>}\n *    </div>\n *  );\n *}\n *```\n */ function useKeyPress(/**\n * The key code (string or array of strings) specifies which key(s) should trigger\n * an action.\n *\n * A **string** can represent:\n * - A **single key**, e.g. `'a'`\n * - A **key combination**, using `'+'` to separate keys, e.g. `'a+d'`\n *\n * An  **array of strings** represents **multiple possible key inputs**. For example, `['a', 'd+s']`\n * means the user can press either the single key `'a'` or the combination of `'d'` and `'s'`.\n * @default null\n */ keyCode = null, options = {\n    target: defaultDoc,\n    actInsideInputWithModifier: true\n}) {\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set([]));\n    /*\n     * keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n     * keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n     * used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n     * we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n     * and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n     * we can't find it in the list of keysToWatch.\n     */ const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (keyCode !== null) {\n            const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                keyCode\n            ];\n            const keys = keyCodeArr.filter((kc)=>typeof kc === \"string\")/*\n                 * we first replace all '+' with '\\n'  which we will use to split the keys on\n                 * then we replace '\\n\\n' with '\\n+', this way we can also support the combination 'key++'\n                 * in the end we simply split on '\\n' to get the key array\n                 */ .map((kc)=>kc.replace(\"+\", \"\\n\").replace(\"\\n\\n\", \"\\n+\").split(\"\\n\"));\n            const keysFlat = keys.reduce((res, item)=>res.concat(...item), []);\n            return [\n                keys,\n                keysFlat\n            ];\n        }\n        return [\n            [],\n            []\n        ];\n    }, [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const target = options?.target ?? defaultDoc;\n        const actInsideInputWithModifier = options?.actInsideInputWithModifier ?? true;\n        if (keyCode !== null) {\n            const downHandler = (event)=>{\n                modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;\n                const preventAction = (!modifierPressed.current || modifierPressed.current && !actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event);\n                if (preventAction) {\n                    return false;\n                }\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                pressedKeys.current.add(event[keyOrCode]);\n                if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                    const target = event.composedPath?.()?.[0] || event.target;\n                    const isInteractiveElement = target?.nodeName === \"BUTTON\" || target?.nodeName === \"A\";\n                    if (options.preventDefault !== false && (modifierPressed.current || !isInteractiveElement)) {\n                        event.preventDefault();\n                    }\n                    setKeyPressed(true);\n                }\n            };\n            const upHandler = (event)=>{\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                    setKeyPressed(false);\n                    pressedKeys.current.clear();\n                } else {\n                    pressedKeys.current.delete(event[keyOrCode]);\n                }\n                // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                if (event.key === \"Meta\") {\n                    pressedKeys.current.clear();\n                }\n                modifierPressed.current = false;\n            };\n            const resetHandler = ()=>{\n                pressedKeys.current.clear();\n                setKeyPressed(false);\n            };\n            target?.addEventListener(\"keydown\", downHandler);\n            target?.addEventListener(\"keyup\", upHandler);\n            window.addEventListener(\"blur\", resetHandler);\n            window.addEventListener(\"contextmenu\", resetHandler);\n            return ()=>{\n                target?.removeEventListener(\"keydown\", downHandler);\n                target?.removeEventListener(\"keyup\", upHandler);\n                window.removeEventListener(\"blur\", resetHandler);\n                window.removeEventListener(\"contextmenu\", resetHandler);\n            };\n        }\n    }, [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n}\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes/*\n         * we only want to compare same sizes of keyCode definitions\n         * and pressed keys. When the user specified 'Meta' as a key somewhere\n         * this would also be truthy without this filter when user presses 'Meta' + 'r'\n         */ .filter((keys)=>isUp || keys.length === pressedKeys.size)/*\n         * since we want to support multiple possibilities only one of the\n         * combinations need to be part of the pressed keys\n         */ .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? \"code\" : \"key\";\n}\n/**\n * Hook for getting viewport helper functions.\n *\n * @internal\n * @returns viewport helper functions\n */ const useViewportHelper = ()=>{\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return {\n            zoomIn: (options)=>{\n                const { panZoom } = store.getState();\n                return panZoom ? panZoom.scaleBy(1.2, {\n                    duration: options?.duration\n                }) : Promise.resolve(false);\n            },\n            zoomOut: (options)=>{\n                const { panZoom } = store.getState();\n                return panZoom ? panZoom.scaleBy(1 / 1.2, {\n                    duration: options?.duration\n                }) : Promise.resolve(false);\n            },\n            zoomTo: (zoomLevel, options)=>{\n                const { panZoom } = store.getState();\n                return panZoom ? panZoom.scaleTo(zoomLevel, {\n                    duration: options?.duration\n                }) : Promise.resolve(false);\n            },\n            getZoom: ()=>store.getState().transform[2],\n            setViewport: async (viewport, options)=>{\n                const { transform: [tX, tY, tZoom], panZoom } = store.getState();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                await panZoom.setViewport({\n                    x: viewport.x ?? tX,\n                    y: viewport.y ?? tY,\n                    zoom: viewport.zoom ?? tZoom\n                }, options);\n                return Promise.resolve(true);\n            },\n            getViewport: ()=>{\n                const [x, y, zoom] = store.getState().transform;\n                return {\n                    x,\n                    y,\n                    zoom\n                };\n            },\n            setCenter: async (x, y, options)=>{\n                return store.getState().setCenter(x, y, options);\n            },\n            fitBounds: async (bounds, options)=>{\n                const { width, height, minZoom, maxZoom, panZoom } = store.getState();\n                const viewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                await panZoom.setViewport(viewport, {\n                    duration: options?.duration,\n                    ease: options?.ease,\n                    interpolate: options?.interpolate\n                });\n                return Promise.resolve(true);\n            },\n            screenToFlowPosition: (clientPosition, options = {})=>{\n                const { transform, snapGrid, snapToGrid, domNode } = store.getState();\n                if (!domNode) {\n                    return clientPosition;\n                }\n                const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                const correctedPosition = {\n                    x: clientPosition.x - domX,\n                    y: clientPosition.y - domY\n                };\n                const _snapGrid = options.snapGrid ?? snapGrid;\n                const _snapToGrid = options.snapToGrid ?? snapToGrid;\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(correctedPosition, transform, _snapToGrid, _snapGrid);\n            },\n            flowToScreenPosition: (flowPosition)=>{\n                const { transform, domNode } = store.getState();\n                if (!domNode) {\n                    return flowPosition;\n                }\n                const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                const rendererPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.rendererPointToPoint)(flowPosition, transform);\n                return {\n                    x: rendererPosition.x + domX,\n                    y: rendererPosition.y + domY\n                };\n            }\n        };\n    }, []);\n};\n/*\n * This function applies changes to nodes or edges that are triggered by React Flow internally.\n * When you drag a node for example, React Flow will send a position change update.\n * This function then applies the changes and returns the updated elements.\n */ function applyChanges(changes, elements) {\n    const updatedElements = [];\n    /*\n     * By storing a map of changes for each element, we can a quick lookup as we\n     * iterate over the elements array!\n     */ const changesMap = new Map();\n    const addItemChanges = [];\n    for (const change of changes){\n        if (change.type === \"add\") {\n            addItemChanges.push(change);\n            continue;\n        } else if (change.type === \"remove\" || change.type === \"replace\") {\n            /*\n             * For a 'remove' change we can safely ignore any other changes queued for\n             * the same element, it's going to be removed anyway!\n             */ changesMap.set(change.id, [\n                change\n            ]);\n        } else {\n            const elementChanges = changesMap.get(change.id);\n            if (elementChanges) {\n                /*\n                 * If we have some changes queued already, we can do a mutable update of\n                 * that array and save ourselves some copying.\n                 */ elementChanges.push(change);\n            } else {\n                changesMap.set(change.id, [\n                    change\n                ]);\n            }\n        }\n    }\n    for (const element of elements){\n        const changes = changesMap.get(element.id);\n        /*\n         * When there are no changes for an element we can just push it unmodified,\n         * no need to copy it.\n         */ if (!changes) {\n            updatedElements.push(element);\n            continue;\n        }\n        // If we have a 'remove' change queued, it'll be the only change in the array\n        if (changes[0].type === \"remove\") {\n            continue;\n        }\n        if (changes[0].type === \"replace\") {\n            updatedElements.push({\n                ...changes[0].item\n            });\n            continue;\n        }\n        /**\n         * For other types of changes, we want to start with a shallow copy of the\n         * object so React knows this element has changed. Sequential changes will\n         * each _mutate_ this object, so there's only ever one copy.\n         */ const updatedElement = {\n            ...element\n        };\n        for (const change of changes){\n            applyChange(change, updatedElement);\n        }\n        updatedElements.push(updatedElement);\n    }\n    /*\n     * we need to wait for all changes to be applied before adding new items\n     * to be able to add them at the correct index\n     */ if (addItemChanges.length) {\n        addItemChanges.forEach((change)=>{\n            if (change.index !== undefined) {\n                updatedElements.splice(change.index, 0, {\n                    ...change.item\n                });\n            } else {\n                updatedElements.push({\n                    ...change.item\n                });\n            }\n        });\n    }\n    return updatedElements;\n}\n// Applies a single change to an element. This is a *mutable* update.\nfunction applyChange(change, element) {\n    switch(change.type){\n        case \"select\":\n            {\n                element.selected = change.selected;\n                break;\n            }\n        case \"position\":\n            {\n                if (typeof change.position !== \"undefined\") {\n                    element.position = change.position;\n                }\n                if (typeof change.dragging !== \"undefined\") {\n                    element.dragging = change.dragging;\n                }\n                break;\n            }\n        case \"dimensions\":\n            {\n                if (typeof change.dimensions !== \"undefined\") {\n                    element.measured ??= {};\n                    element.measured.width = change.dimensions.width;\n                    element.measured.height = change.dimensions.height;\n                    if (change.setAttributes) {\n                        if (change.setAttributes === true || change.setAttributes === \"width\") {\n                            element.width = change.dimensions.width;\n                        }\n                        if (change.setAttributes === true || change.setAttributes === \"height\") {\n                            element.height = change.dimensions.height;\n                        }\n                    }\n                }\n                if (typeof change.resizing === \"boolean\") {\n                    element.resizing = change.resizing;\n                }\n                break;\n            }\n    }\n}\n/**\n * Drop in function that applies node changes to an array of nodes.\n * @public\n * @param changes - Array of changes to apply.\n * @param nodes - Array of nodes to apply the changes to.\n * @returns Array of updated nodes.\n * @example\n *```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyNodeChanges, type Node, type Edge, type OnNodesChange } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState<Node[]>([]);\n *  const [edges, setEdges] = useState<Edge[]>([]);\n *  const onNodesChange: OnNodesChange = useCallback(\n *    (changes) => {\n *      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));\n *    },\n *    [setNodes],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link NodeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\n/**\n * Drop in function that applies edge changes to an array of edges.\n * @public\n * @param changes - Array of changes to apply.\n * @param edges - Array of edge to apply the changes to.\n * @returns Array of updated edges.\n * @example\n * ```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyEdgeChanges } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState([]);\n *  const [edges, setEdges] = useState([]);\n *  const onEdgesChange = useCallback(\n *    (changes) => {\n *      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));\n *    },\n *    [setEdges],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link EdgeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nfunction createSelectionChange(id, selected) {\n    return {\n        id,\n        type: \"select\",\n        selected\n    };\n}\nfunction getSelectionChanges(items, selectedIds = new Set(), mutateItem = false) {\n    const changes = [];\n    for (const [id, item] of items){\n        const willBeSelected = selectedIds.has(id);\n        // we don't want to set all items to selected=false on the first selection\n        if (!(item.selected === undefined && !willBeSelected) && item.selected !== willBeSelected) {\n            if (mutateItem) {\n                /*\n                 * this hack is needed for nodes. When the user dragged a node, it's selected.\n                 * When another node gets dragged, we need to deselect the previous one,\n                 * in order to have only one selected node at a time - the onNodesChange callback comes too late here :/\n                 */ item.selected = willBeSelected;\n            }\n            changes.push(createSelectionChange(item.id, willBeSelected));\n        }\n    }\n    return changes;\n}\nfunction getElementsDiffChanges({ items = [], lookup }) {\n    const changes = [];\n    const itemsLookup = new Map(items.map((item)=>[\n            item.id,\n            item\n        ]));\n    for (const [index, item] of items.entries()){\n        const lookupItem = lookup.get(item.id);\n        const storeItem = lookupItem?.internals?.userNode ?? lookupItem;\n        if (storeItem !== undefined && storeItem !== item) {\n            changes.push({\n                id: item.id,\n                item: item,\n                type: \"replace\"\n            });\n        }\n        if (storeItem === undefined) {\n            changes.push({\n                item: item,\n                type: \"add\",\n                index\n            });\n        }\n    }\n    for (const [id] of lookup){\n        const nextNode = itemsLookup.get(id);\n        if (nextNode === undefined) {\n            changes.push({\n                id,\n                type: \"remove\"\n            });\n        }\n    }\n    return changes;\n}\nfunction elementToRemoveChange(item) {\n    return {\n        id: item.id,\n        type: \"remove\"\n    };\n}\n/**\n * Test whether an object is usable as an [`Node`](/api-reference/types/node).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Node`](/api-reference/types/node) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test.\n * @returns Tests whether the provided value can be used as a `Node`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Node` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isNode } from '@xyflow/react';\n *\n *if (isNode(node)) {\n * // ...\n *}\n *```\n */ const isNode = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNodeBase)(element);\n/**\n * Test whether an object is usable as an [`Edge`](/api-reference/types/edge).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Edge`](/api-reference/types/edge) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns Tests whether the provided value can be used as an `Edge`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Edge` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isEdge } from '@xyflow/react';\n *\n *if (isEdge(edge)) {\n * // ...\n *}\n *```\n */ const isEdge = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeBase)(element);\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nfunction fixedForwardRef(render) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(render);\n}\n// we need this hook to prevent a warning when using react-flow in SSR\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n/**\n * This hook returns a queue that can be used to batch updates.\n *\n * @param runQueue - a function that gets called when the queue is flushed\n * @internal\n *\n * @returns a Queue object\n */ function useQueue(runQueue) {\n    /*\n     * Because we're using a ref above, we need some way to let React know when to\n     * actually process the queue. We increment this number any time we mutate the\n     * queue, creating a new state to trigger the layout effect below.\n     * Using a boolean dirty flag here instead would lead to issues related to\n     * automatic batching. (https://github.com/xyflow/xyflow/issues/4779)\n     */ const [serial, setSerial] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(BigInt(0));\n    /*\n     * A reference of all the batched updates to process before the next render. We\n     * want a reference here so multiple synchronous calls to `setNodes` etc can be\n     * batched together.\n     */ const [queue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>createQueue(()=>setSerial((n)=>n + BigInt(1))));\n    /*\n     * Layout effects are guaranteed to run before the next render which means we\n     * shouldn't run into any issues with stale state or weird issues that come from\n     * rendering things one frame later than expected (we used to use `setTimeout`).\n     */ useIsomorphicLayoutEffect(()=>{\n        const queueItems = queue.get();\n        if (queueItems.length) {\n            runQueue(queueItems);\n            queue.reset();\n        }\n    }, [\n        serial\n    ]);\n    return queue;\n}\nfunction createQueue(cb) {\n    let queue = [];\n    return {\n        get: ()=>queue,\n        reset: ()=>{\n            queue = [];\n        },\n        push: (item)=>{\n            queue.push(item);\n            cb();\n        }\n    };\n}\nconst BatchContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n/**\n * This is a context provider that holds and processes the node and edge update queues\n * that are needed to handle setNodes, addNodes, setEdges and addEdges.\n *\n * @internal\n */ function BatchProvider({ children }) {\n    const store = useStoreApi();\n    const nodeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((queueItems)=>{\n        const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup, fitViewQueued } = store.getState();\n        /*\n         * This is essentially an `Array.reduce` in imperative clothing. Processing\n         * this queue is a relatively hot path so we'd like to avoid the overhead of\n         * array methods where we can.\n         */ let next = nodes;\n        for (const payload of queueItems){\n            next = typeof payload === \"function\" ? payload(next) : payload;\n        }\n        const changes = getElementsDiffChanges({\n            items: next,\n            lookup: nodeLookup\n        });\n        if (hasDefaultNodes) {\n            setNodes(next);\n        }\n        // We only want to fire onNodesChange if there are changes to the nodes\n        if (changes.length > 0) {\n            onNodesChange?.(changes);\n        } else if (fitViewQueued) {\n            // If there are no changes to the nodes, we still need to call setNodes\n            // to trigger a re-render and fitView.\n            window.requestAnimationFrame(()=>{\n                const { fitViewQueued, nodes, setNodes } = store.getState();\n                if (fitViewQueued) {\n                    setNodes(nodes);\n                }\n            });\n        }\n    }, []);\n    const nodeQueue = useQueue(nodeQueueHandler);\n    const edgeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((queueItems)=>{\n        const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();\n        let next = edges;\n        for (const payload of queueItems){\n            next = typeof payload === \"function\" ? payload(next) : payload;\n        }\n        if (hasDefaultEdges) {\n            setEdges(next);\n        } else if (onEdgesChange) {\n            onEdgesChange(getElementsDiffChanges({\n                items: next,\n                lookup: edgeLookup\n            }));\n        }\n    }, []);\n    const edgeQueue = useQueue(edgeQueueHandler);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            nodeQueue,\n            edgeQueue\n        }), []);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useBatchContext() {\n    const batchContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BatchContext);\n    if (!batchContext) {\n        throw new Error(\"useBatchContext must be used within a BatchProvider\");\n    }\n    return batchContext;\n}\nconst selector$k = (s)=>!!s.panZoom;\n/**\n * This hook returns a ReactFlowInstance that can be used to update nodes and edges, manipulate the viewport, or query the current state of the flow.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { useReactFlow } from '@xyflow/react';\n *\n *export function NodeCounter() {\n *  const reactFlow = useReactFlow();\n *  const [count, setCount] = useState(0);\n *  const countNodes = useCallback(() => {\n *    setCount(reactFlow.getNodes().length);\n *    // you need to pass it as a dependency if you are using it with useEffect or useCallback\n *    // because at the first render, it's not initialized yet and some functions might not work.\n *  }, [reactFlow]);\n *\n *  return (\n *    <div>\n *      <button onClick={countNodes}>Update count</button>\n *      <p>There are {count} nodes in the flow.</p>\n *    </div>\n *  );\n *}\n *```\n */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const batchContext = useBatchContext();\n    const viewportInitialized = useStore(selector$k);\n    const generalHelper = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const getInternalNode = (id)=>store.getState().nodeLookup.get(id);\n        const setNodes = (payload)=>{\n            batchContext.nodeQueue.push(payload);\n        };\n        const setEdges = (payload)=>{\n            batchContext.edgeQueue.push(payload);\n        };\n        const getNodeRect = (node)=>{\n            const { nodeLookup, nodeOrigin } = store.getState();\n            const nodeToUse = isNode(node) ? node : nodeLookup.get(node.id);\n            const position = nodeToUse.parentId ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position;\n            const nodeWithPosition = {\n                ...nodeToUse,\n                position,\n                width: nodeToUse.measured?.width ?? nodeToUse.width,\n                height: nodeToUse.measured?.height ?? nodeToUse.height\n            };\n            return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(nodeWithPosition);\n        };\n        const updateNode = (id, nodeUpdate, options = {\n            replace: false\n        })=>{\n            setNodes((prevNodes)=>prevNodes.map((node)=>{\n                    if (node.id === id) {\n                        const nextNode = typeof nodeUpdate === \"function\" ? nodeUpdate(node) : nodeUpdate;\n                        return options.replace && isNode(nextNode) ? nextNode : {\n                            ...node,\n                            ...nextNode\n                        };\n                    }\n                    return node;\n                }));\n        };\n        const updateEdge = (id, edgeUpdate, options = {\n            replace: false\n        })=>{\n            setEdges((prevEdges)=>prevEdges.map((edge)=>{\n                    if (edge.id === id) {\n                        const nextEdge = typeof edgeUpdate === \"function\" ? edgeUpdate(edge) : edgeUpdate;\n                        return options.replace && isEdge(nextEdge) ? nextEdge : {\n                            ...edge,\n                            ...nextEdge\n                        };\n                    }\n                    return edge;\n                }));\n        };\n        return {\n            getNodes: ()=>store.getState().nodes.map((n)=>({\n                        ...n\n                    })),\n            getNode: (id)=>getInternalNode(id)?.internals.userNode,\n            getInternalNode,\n            getEdges: ()=>{\n                const { edges = [] } = store.getState();\n                return edges.map((e)=>({\n                        ...e\n                    }));\n            },\n            getEdge: (id)=>store.getState().edgeLookup.get(id),\n            setNodes,\n            setEdges,\n            addNodes: (payload)=>{\n                const newNodes = Array.isArray(payload) ? payload : [\n                    payload\n                ];\n                batchContext.nodeQueue.push((nodes)=>[\n                        ...nodes,\n                        ...newNodes\n                    ]);\n            },\n            addEdges: (payload)=>{\n                const newEdges = Array.isArray(payload) ? payload : [\n                    payload\n                ];\n                batchContext.edgeQueue.push((edges)=>[\n                        ...edges,\n                        ...newEdges\n                    ]);\n            },\n            toObject: ()=>{\n                const { nodes = [], edges = [], transform } = store.getState();\n                const [x, y, zoom] = transform;\n                return {\n                    nodes: nodes.map((n)=>({\n                            ...n\n                        })),\n                    edges: edges.map((e)=>({\n                            ...e\n                        })),\n                    viewport: {\n                        x,\n                        y,\n                        zoom\n                    }\n                };\n            },\n            deleteElements: async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] })=>{\n                const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState();\n                const { nodes: matchingNodes, edges: matchingEdges } = await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElementsToRemove)({\n                    nodesToRemove,\n                    edgesToRemove,\n                    nodes,\n                    edges,\n                    onBeforeDelete\n                });\n                const hasMatchingEdges = matchingEdges.length > 0;\n                const hasMatchingNodes = matchingNodes.length > 0;\n                if (hasMatchingEdges) {\n                    const edgeChanges = matchingEdges.map(elementToRemoveChange);\n                    onEdgesDelete?.(matchingEdges);\n                    triggerEdgeChanges(edgeChanges);\n                }\n                if (hasMatchingNodes) {\n                    const nodeChanges = matchingNodes.map(elementToRemoveChange);\n                    onNodesDelete?.(matchingNodes);\n                    triggerNodeChanges(nodeChanges);\n                }\n                if (hasMatchingNodes || hasMatchingEdges) {\n                    onDelete?.({\n                        nodes: matchingNodes,\n                        edges: matchingEdges\n                    });\n                }\n                return {\n                    deletedNodes: matchingNodes,\n                    deletedEdges: matchingEdges\n                };\n            },\n            /**\n             * Partial is defined as \"the 2 nodes/areas are intersecting partially\".\n             * If a is contained in b or b is contained in a, they are both\n             * considered fully intersecting.\n             */ getIntersectingNodes: (nodeOrRect, partially = true, nodes)=>{\n                const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                const hasNodesOption = nodes !== undefined;\n                if (!nodeRect) {\n                    return [];\n                }\n                return (nodes || store.getState().nodes).filter((n)=>{\n                    const internalNode = store.getState().nodeLookup.get(n.id);\n                    if (internalNode && !isRect && (n.id === nodeOrRect.id || !internalNode.internals.positionAbsolute)) {\n                        return false;\n                    }\n                    const currNodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(hasNodesOption ? n : internalNode);\n                    const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(currNodeRect, nodeRect);\n                    const partiallyVisible = partially && overlappingArea > 0;\n                    return partiallyVisible || overlappingArea >= currNodeRect.width * currNodeRect.height || overlappingArea >= nodeRect.width * nodeRect.height;\n                });\n            },\n            isNodeIntersecting: (nodeOrRect, area, partially = true)=>{\n                const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                if (!nodeRect) {\n                    return false;\n                }\n                const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(nodeRect, area);\n                const partiallyVisible = partially && overlappingArea > 0;\n                return partiallyVisible || overlappingArea >= area.width * area.height || overlappingArea >= nodeRect.width * nodeRect.height;\n            },\n            updateNode,\n            updateNodeData: (id, dataUpdate, options = {\n                replace: false\n            })=>{\n                updateNode(id, (node)=>{\n                    const nextData = typeof dataUpdate === \"function\" ? dataUpdate(node) : dataUpdate;\n                    return options.replace ? {\n                        ...node,\n                        data: nextData\n                    } : {\n                        ...node,\n                        data: {\n                            ...node.data,\n                            ...nextData\n                        }\n                    };\n                }, options);\n            },\n            updateEdge,\n            updateEdgeData: (id, dataUpdate, options = {\n                replace: false\n            })=>{\n                updateEdge(id, (edge)=>{\n                    const nextData = typeof dataUpdate === \"function\" ? dataUpdate(edge) : dataUpdate;\n                    return options.replace ? {\n                        ...edge,\n                        data: nextData\n                    } : {\n                        ...edge,\n                        data: {\n                            ...edge.data,\n                            ...nextData\n                        }\n                    };\n                }, options);\n            },\n            getNodesBounds: (nodes)=>{\n                const { nodeLookup, nodeOrigin } = store.getState();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds)(nodes, {\n                    nodeLookup,\n                    nodeOrigin\n                });\n            },\n            getHandleConnections: ({ type, id, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id ? `-${id}` : \"\"}`)?.values() ?? []),\n            getNodeConnections: ({ type, handleId, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : \"\"}`)?.values() ?? []),\n            fitView: async (options)=>{\n                // We either create a new Promise or reuse the existing one\n                // Even if fitView is called multiple times in a row, we only end up with a single Promise\n                const fitViewResolver = store.getState().fitViewResolver ?? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.withResolvers)();\n                // We schedule a fitView by setting fitViewQueued and triggering a setNodes\n                store.setState({\n                    fitViewQueued: true,\n                    fitViewOptions: options,\n                    fitViewResolver\n                });\n                batchContext.nodeQueue.push((nodes)=>[\n                        ...nodes\n                    ]);\n                return fitViewResolver.promise;\n            }\n        };\n    }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return {\n            ...generalHelper,\n            ...viewportHelper,\n            viewportInitialized\n        };\n    }, [\n        viewportInitialized\n    ]);\n}\nconst selected = (item)=>item.selected;\nconst win$1 =  false ? 0 : undefined;\n/**\n * Hook for handling global key events.\n *\n * @internal\n */ function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, {\n        actInsideInputWithModifier: false\n    });\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, {\n        target: win$1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (deleteKeyPressed) {\n            const { edges, nodes } = store.getState();\n            deleteElements({\n                nodes: nodes.filter(selected),\n                edges: edges.filter(selected)\n            });\n            store.setState({\n                nodesSelectionActive: false\n            });\n        }\n    }, [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            multiSelectionActive: multiSelectionKeyPressed\n        });\n    }, [\n        multiSelectionKeyPressed\n    ]);\n}\n/**\n * Hook for handling resize events.\n *\n * @internal\n */ function useResizeHandler(domNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const updateDimensions = ()=>{\n            if (!domNode.current || !(domNode.current.checkVisibility?.() ?? true)) {\n                return false;\n            }\n            const size = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getDimensions)(domNode.current);\n            if (size.height === 0 || size.width === 0) {\n                store.getState().onError?.(\"004\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error004\"]());\n            }\n            store.setState({\n                width: size.width || 500,\n                height: size.height || 500\n            });\n        };\n        if (domNode.current) {\n            updateDimensions();\n            window.addEventListener(\"resize\", updateDimensions);\n            const resizeObserver = new ResizeObserver(()=>updateDimensions());\n            resizeObserver.observe(domNode.current);\n            return ()=>{\n                window.removeEventListener(\"resize\", updateDimensions);\n                if (resizeObserver && domNode.current) {\n                    resizeObserver.unobserve(domNode.current);\n                }\n            };\n        }\n    }, []);\n}\nconst containerStyle = {\n    position: \"absolute\",\n    width: \"100%\",\n    height: \"100%\",\n    top: 0,\n    left: 0\n};\nconst selector$j = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        lib: s.lib,\n        connectionInProgress: s.connection.inProgress\n    });\nfunction ZoomPane({ onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance }) {\n    const store = useStoreApi();\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { userSelectionActive, lib, connectionInProgress } = useStore(selector$j, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const panZoom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    useResizeHandler(zoomPane);\n    const onTransformChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((transform)=>{\n        onViewportChange?.({\n            x: transform[0],\n            y: transform[1],\n            zoom: transform[2]\n        });\n        if (!isControlledViewport) {\n            store.setState({\n                transform\n            });\n        }\n    }, [\n        onViewportChange,\n        isControlledViewport\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (zoomPane.current) {\n            panZoom.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYPanZoom)({\n                domNode: zoomPane.current,\n                minZoom,\n                maxZoom,\n                translateExtent,\n                viewport: defaultViewport,\n                paneClickDistance,\n                onDraggingChange: (paneDragging)=>store.setState({\n                        paneDragging\n                    }),\n                onPanZoomStart: (event, vp)=>{\n                    const { onViewportChangeStart, onMoveStart } = store.getState();\n                    onMoveStart?.(event, vp);\n                    onViewportChangeStart?.(vp);\n                },\n                onPanZoom: (event, vp)=>{\n                    const { onViewportChange, onMove } = store.getState();\n                    onMove?.(event, vp);\n                    onViewportChange?.(vp);\n                },\n                onPanZoomEnd: (event, vp)=>{\n                    const { onViewportChangeEnd, onMoveEnd } = store.getState();\n                    onMoveEnd?.(event, vp);\n                    onViewportChangeEnd?.(vp);\n                }\n            });\n            const { x, y, zoom } = panZoom.current.getViewport();\n            store.setState({\n                panZoom: panZoom.current,\n                transform: [\n                    x,\n                    y,\n                    zoom\n                ],\n                domNode: zoomPane.current.closest(\".react-flow\")\n            });\n            return ()=>{\n                panZoom.current?.destroy();\n            };\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        panZoom.current?.update({\n            onPaneContextMenu,\n            zoomOnScroll,\n            zoomOnPinch,\n            panOnScroll,\n            panOnScrollSpeed,\n            panOnScrollMode,\n            zoomOnDoubleClick,\n            panOnDrag,\n            zoomActivationKeyPressed,\n            preventScrolling,\n            noPanClassName,\n            userSelectionActive,\n            noWheelClassName,\n            lib,\n            onTransformChange,\n            connectionInProgress\n        });\n    }, [\n        onPaneContextMenu,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        panOnScrollSpeed,\n        panOnScrollMode,\n        zoomOnDoubleClick,\n        panOnDrag,\n        zoomActivationKeyPressed,\n        preventScrolling,\n        noPanClassName,\n        userSelectionActive,\n        noWheelClassName,\n        lib,\n        onTransformChange,\n        connectionInProgress\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle,\n        children: children\n    });\n}\nconst selector$i = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$i, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nconst wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$h = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        connectionInProgress: s.connection.inProgress,\n        dragging: s.paneDragging\n    });\nfunction Pane({ isSelecting, selectionKeyPressed, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panOnDrag, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children }) {\n    const store = useStoreApi();\n    const { userSelectionActive, elementsSelectable, dragging, connectionInProgress } = useStore(selector$h, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const selectedNodeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    const selectedEdgeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    // Used to prevent click events when the user lets go of the selectionKey during a selection\n    const selectionInProgress = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const selectionStarted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const onClick = (event)=>{\n        // We prevent click events when the user let go of the selectionKey during a selection\n        // We also prevent click events when a connection is in progress\n        if (selectionInProgress.current || connectionInProgress) {\n            selectionInProgress.current = false;\n            return;\n        }\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onPointerDown = (event)=>{\n        const { resetSelectedElements, domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container.current || !containerBounds.current) {\n            return;\n        }\n        event.target?.setPointerCapture?.(event.pointerId);\n        selectionStarted.current = true;\n        selectionInProgress.current = false;\n        const { x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        resetSelectedElements();\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        onSelectionStart?.(event);\n    };\n    const onPointerMove = (event)=>{\n        const { userSelectionRect, transform, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions } = store.getState();\n        if (!containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        selectionInProgress.current = true;\n        const { x: mouseX, y: mouseY } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        const { startX, startY } = userSelectionRect;\n        const nextUserSelectRect = {\n            startX,\n            startY,\n            x: mouseX < startX ? mouseX : startX,\n            y: mouseY < startY ? mouseY : startY,\n            width: Math.abs(mouseX - startX),\n            height: Math.abs(mouseY - startY)\n        };\n        const prevSelectedNodeIds = selectedNodeIds.current;\n        const prevSelectedEdgeIds = selectedEdgeIds.current;\n        selectedNodeIds.current = new Set((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(nodeLookup, nextUserSelectRect, transform, selectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Partial, true).map((node)=>node.id));\n        selectedEdgeIds.current = new Set();\n        const edgesSelectable = defaultEdgeOptions?.selectable ?? true;\n        // We look for all edges connected to the selected nodes\n        for (const nodeId of selectedNodeIds.current){\n            const connections = connectionLookup.get(nodeId);\n            if (!connections) continue;\n            for (const { edgeId } of connections.values()){\n                const edge = edgeLookup.get(edgeId);\n                if (edge && (edge.selectable ?? edgesSelectable)) {\n                    selectedEdgeIds.current.add(edgeId);\n                }\n            }\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedNodeIds, selectedNodeIds.current)) {\n            const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, true);\n            triggerNodeChanges(changes);\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedEdgeIds, selectedEdgeIds.current)) {\n            const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);\n            triggerEdgeChanges(changes);\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect,\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n    };\n    const onPointerUp = (event)=>{\n        if (event.button !== 0 || !selectionStarted.current) {\n            return;\n        }\n        event.target?.releasePointerCapture?.(event.pointerId);\n        const { userSelectionRect } = store.getState();\n        /*\n         * We only want to trigger click functions when in selection mode if\n         * the user did not move the mouse.\n         */ if (!userSelectionActive && userSelectionRect && event.target === container.current) {\n            onClick?.(event);\n        }\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null,\n            nodesSelectionActive: selectedNodeIds.current.size > 0\n        });\n        onSelectionEnd?.(event);\n        /*\n         * If the user kept holding the selectionKey during the selection,\n         * we need to reset the selectionInProgress, so the next click event is not prevented\n         */ if (selectionKeyPressed || selectionOnDrag) {\n            selectionInProgress.current = false;\n        }\n        selectionStarted.current = false;\n    };\n    const draggable = panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(0);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__pane\",\n            {\n                draggable,\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onPointerEnter: hasActiveSelection ? undefined : onPaneMouseEnter,\n        onPointerDown: hasActiveSelection ? onPointerDown : onPaneMouseMove,\n        onPointerMove: hasActiveSelection ? onPointerMove : onPaneMouseMove,\n        onPointerUp: hasActiveSelection ? onPointerUp : undefined,\n        onPointerLeave: onPaneMouseLeave,\n        ref: container,\n        style: containerStyle,\n        children: [\n            children,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UserSelection, {})\n        ]\n    });\n}\n/*\n * this handler is called by\n * 1. the click handler when node is not draggable or selectNodesOnDrag = false\n * or\n * 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\n */ function handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState();\n    const node = nodeLookup.get(id);\n    if (!node) {\n        onError?.(\"012\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error012\"](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\n/**\n * Hook for calling XYDrag helper from @xyflow/system.\n *\n * @internal\n */ function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const xyDrag = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        xyDrag.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYDrag)({\n            getStoreItems: ()=>store.getState(),\n            onNodeMouseDown: (id)=>{\n                handleNodeClick({\n                    id,\n                    store,\n                    nodeRef\n                });\n            },\n            onDragStart: ()=>{\n                setDragging(true);\n            },\n            onDragStop: ()=>{\n                setDragging(false);\n            }\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (disabled) {\n            xyDrag.current?.destroy();\n        } else if (nodeRef.current) {\n            xyDrag.current?.update({\n                noDragClassName,\n                handleSelector,\n                domNode: nodeRef.current,\n                isSelectable,\n                nodeId,\n                nodeClickDistance\n            });\n            return ()=>{\n                xyDrag.current?.destroy();\n            };\n        }\n    }, [\n        noDragClassName,\n        handleSelector,\n        disabled,\n        isSelectable,\n        nodeRef,\n        nodeId\n    ]);\n    return dragging;\n}\nconst selectedAndDraggable = (nodesDraggable)=>(n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === \"undefined\");\n/**\n * Hook for updating node positions by passing a direction and factor\n *\n * @internal\n * @returns function for updating node positions\n */ function useMoveSelectedNodes() {\n    const store = useStoreApi();\n    const moveSelectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((params)=>{\n        const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState();\n        const nodeUpdates = new Map();\n        const isSelected = selectedAndDraggable(nodesDraggable);\n        /*\n         * by default a node moves 5px on each key press\n         * if snap grid is enabled, we use that for the velocity\n         */ const xVelo = snapToGrid ? snapGrid[0] : 5;\n        const yVelo = snapToGrid ? snapGrid[1] : 5;\n        const xDiff = params.direction.x * xVelo * params.factor;\n        const yDiff = params.direction.y * yVelo * params.factor;\n        for (const [, node] of nodeLookup){\n            if (!isSelected(node)) {\n                continue;\n            }\n            let nextPosition = {\n                x: node.internals.positionAbsolute.x + xDiff,\n                y: node.internals.positionAbsolute.y + yDiff\n            };\n            if (snapToGrid) {\n                nextPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.snapPosition)(nextPosition, snapGrid);\n            }\n            const { position, positionAbsolute } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.calculateNodePosition)({\n                nodeId: node.id,\n                nextPosition,\n                nodeLookup,\n                nodeExtent,\n                nodeOrigin,\n                onError\n            });\n            node.position = position;\n            node.internals.positionAbsolute = positionAbsolute;\n            nodeUpdates.set(node.id, node);\n        }\n        updateNodePositions(nodeUpdates);\n    }, []);\n    return moveSelectedNodes;\n}\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\n/**\n * You can use this hook to get the id of the node it is used inside. It is useful\n * if you need the node's id deeper in the render tree but don't want to manually\n * drill down the id as a prop.\n *\n * @public\n * @returns The id for a node in the flow.\n *\n * @example\n *```jsx\n *import { useNodeId } from '@xyflow/react';\n *\n *export default function CustomNode() {\n *  return (\n *    <div>\n *      <span>This node has an id of </span>\n *      <NodeIdDisplay />\n *    </div>\n *  );\n *}\n *\n *function NodeIdDisplay() {\n *  const nodeId = useNodeId();\n *\n *  return <span>{nodeId}</span>;\n *}\n *```\n */ const useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst selector$g = (s)=>({\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName,\n        rfId: s.rfId\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state;\n        const { fromHandle, toHandle, isValid } = connection;\n        const connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;\n        return {\n            connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,\n            connectingTo,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,\n            isPossibleEndHandle: connectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,\n            connectionInProcess: !!fromHandle,\n            clickConnectionInProcess: !!clickHandle,\n            valid: connectingTo && isValid\n        };\n    };\nfunction HandleComponent({ type = \"source\", position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) {\n    const handleId = id || null;\n    const isTarget = type === \"target\";\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName, rfId } = useStore(selector$g, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, clickConnectionInProcess, valid } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.(\"010\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error010\"]());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge)(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMouseEvent)(event.nativeEvent);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            const currentStore = store.getState();\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n                handleDomNode: event.currentTarget,\n                autoPanOnConnect: currentStore.autoPanOnConnect,\n                connectionMode: currentStore.connectionMode,\n                connectionRadius: currentStore.connectionRadius,\n                domNode: currentStore.domNode,\n                nodeLookup: currentStore.nodeLookup,\n                lib: currentStore.lib,\n                isTarget,\n                handleId,\n                nodeId,\n                flowId: currentStore.rfId,\n                panBy: currentStore.panBy,\n                cancelConnection: currentStore.cancelConnection,\n                onConnectStart: currentStore.onConnectStart,\n                onConnectEnd: currentStore.onConnectEnd,\n                updateConnection: currentStore.updateConnection,\n                onConnect: onConnectExtended,\n                isValidConnection: isValidConnection || currentStore.isValidConnection,\n                getTransform: ()=>store.getState().transform,\n                getFromHandle: ()=>store.getState().connection.fromHandle,\n                autoPanSpeed: currentStore.autoPanSpeed,\n                dragThreshold: currentStore.connectionDragThreshold\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event.nativeEvent, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    id: handleId\n                }\n            });\n            return;\n        }\n        const doc = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getHostForElement)(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore;\n        const { connection, isValid } = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.isValid(event.nativeEvent, {\n            handle: {\n                nodeId,\n                id: handleId,\n                type\n            },\n            connectionMode,\n            fromNodeId: connectionClickStartHandle.nodeId,\n            fromHandleId: connectionClickStartHandle.id || null,\n            fromType: connectionClickStartHandle.type,\n            isValidConnection: isValidConnectionHandler,\n            flowId,\n            doc,\n            lib,\n            nodeLookup\n        });\n        if (isValid && connection) {\n            onConnectExtended(connection);\n        }\n        const connectionClone = structuredClone(connectionState);\n        delete connectionClone.inProgress;\n        connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;\n        onClickConnectEnd?.(event, connectionClone);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${rfId}-${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__handle\",\n            `react-flow__handle-${position}`,\n            \"nodrag\",\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                clickconnecting: clickConnecting,\n                connectingfrom: connectingFrom,\n                connectingto: connectingTo,\n                valid,\n                /*\n                 * shows where you can start a connection from\n                 * and where you can end it while connecting\n                 */ connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess || clickConnectionInProcess ? isConnectableEnd : isConnectableStart)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n}\n/**\n * The `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)\n * to define connection points.\n *\n *@public\n *\n *@example\n *\n *```jsx\n *import { Handle, Position } from '@xyflow/react';\n *\n *export function CustomNode({ data }) {\n *  return (\n *    <>\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *```\n */ const Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(fixedForwardRef(HandleComponent));\nfunction InputNode({ data, isConnectable, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction DefaultNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction GroupNode() {\n    return null;\n}\nfunction OutputNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label\n        ]\n    });\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nconst builtinNodeTypes = {\n    input: InputNode,\n    default: DefaultNode,\n    output: OutputNode,\n    group: GroupNode\n};\nfunction getNodeInlineStyleDimensions(node) {\n    if (node.internals.handleBounds === undefined) {\n        return {\n            width: node.width ?? node.initialWidth ?? node.style?.width,\n            height: node.height ?? node.initialHeight ?? node.style?.height\n        };\n    }\n    return {\n        width: node.width ?? node.style?.width,\n        height: node.height ?? node.style?.height\n    };\n}\nconst selector$f = (s)=>{\n    const { width, height, x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n        filter: (node)=>!!node.selected\n    });\n    return {\n        width: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(width) ? width : null,\n        height: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(height) ? height : null,\n        userSelectionActive: s.userSelectionActive,\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x}px,${y}px)`\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, transformString, userSelectionActive } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const moveSelectedNodes = useMoveSelectedNodes();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!disableKeyboardA11y) {\n            nodeRef.current?.focus({\n                preventScroll: true\n            });\n        }\n    }, [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().nodes.filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            event.preventDefault();\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__nodesselection\",\n            \"react-flow__container\",\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            ref: nodeRef,\n            className: \"react-flow__nodesselection-rect\",\n            onContextMenu: onContextMenu,\n            tabIndex: disableKeyboardA11y ? undefined : -1,\n            onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n            style: {\n                width,\n                height\n            }\n        })\n    });\n}\nconst win =  false ? 0 : undefined;\nconst selector$e = (s)=>{\n    return {\n        nodesSelectionActive: s.nodesSelectionActive,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction FlowRendererComponent({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {\n    const { nodesSelectionActive, userSelectionActive } = useStore(selector$e);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode, {\n        target: win\n    });\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode, {\n        target: win\n    });\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const _selectionOnDrag = selectionOnDrag && panOnDrag !== true;\n    const isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ZoomPane, {\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        onViewportChange: onViewportChange,\n        isControlledViewport: isControlledViewport,\n        paneClickDistance: paneClickDistance,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Pane, {\n            onSelectionStart: onSelectionStart,\n            onSelectionEnd: onSelectionEnd,\n            onPaneClick: onPaneClick,\n            onPaneMouseEnter: onPaneMouseEnter,\n            onPaneMouseMove: onPaneMouseMove,\n            onPaneMouseLeave: onPaneMouseLeave,\n            onPaneContextMenu: onPaneContextMenu,\n            onPaneScroll: onPaneScroll,\n            panOnDrag: panOnDrag,\n            isSelecting: !!isSelecting,\n            selectionMode: selectionMode,\n            selectionKeyPressed: selectionKeyPressed,\n            selectionOnDrag: _selectionOnDrag,\n            children: [\n                children,\n                nodesSelectionActive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodesSelection, {\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nFlowRendererComponent.displayName = \"FlowRenderer\";\nconst FlowRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FlowRendererComponent);\nconst selector$d = (onlyRenderVisible)=>(s)=>{\n        return onlyRenderVisible ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(s.nodeLookup, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true).map((node)=>node.id) : Array.from(s.nodeLookup.keys());\n    };\n/**\n * Hook for getting the visible node ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible node ids\n */ function useVisibleNodeIds(onlyRenderVisible) {\n    const nodeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(selector$d(onlyRenderVisible), [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodeIds;\n}\nconst selector$c = (s)=>s.updateNodeInternals;\nfunction useResizeObserver() {\n    const updateNodeInternals = useStore(selector$c);\n    const [resizeObserver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>{\n        if (typeof ResizeObserver === \"undefined\") {\n            return null;\n        }\n        return new ResizeObserver((entries)=>{\n            const updates = new Map();\n            entries.forEach((entry)=>{\n                const id = entry.target.getAttribute(\"data-id\");\n                updates.set(id, {\n                    id,\n                    nodeElement: entry.target,\n                    force: true\n                });\n            });\n            updateNodeInternals(updates);\n        });\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            resizeObserver?.disconnect();\n        };\n    }, [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\n/**\n * Hook to handle the resize observation + internal updates for the passed node.\n *\n * @internal\n * @returns nodeRef - reference to the node element\n */ function useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }) {\n    const store = useStoreApi();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const observedNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.sourcePosition);\n    const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.targetPosition);\n    const prevType = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeType);\n    const isInitialized = hasDimensions && !!node.internals.handleBounds;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current)) {\n            if (observedNode.current) {\n                resizeObserver?.unobserve(observedNode.current);\n            }\n            resizeObserver?.observe(nodeRef.current);\n            observedNode.current = nodeRef.current;\n        }\n    }, [\n        isInitialized,\n        node.hidden\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            if (observedNode.current) {\n                resizeObserver?.unobserve(observedNode.current);\n                observedNode.current = null;\n            }\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (nodeRef.current) {\n            /*\n             * when the user programmatically changes the source or handle position, we need to update the internals\n             * to make sure the edges are updated correctly\n             */ const typeChanged = prevType.current !== nodeType;\n            const sourcePosChanged = prevSourcePosition.current !== node.sourcePosition;\n            const targetPosChanged = prevTargetPosition.current !== node.targetPosition;\n            if (typeChanged || sourcePosChanged || targetPosChanged) {\n                prevType.current = nodeType;\n                prevSourcePosition.current = node.sourcePosition;\n                prevTargetPosition.current = node.targetPosition;\n                store.getState().updateNodeInternals(new Map([\n                    [\n                        node.id,\n                        {\n                            id: node.id,\n                            nodeElement: nodeRef.current,\n                            force: true\n                        }\n                    ]\n                ]));\n            }\n        }\n    }, [\n        node.id,\n        nodeType,\n        node.sourcePosition,\n        node.targetPosition\n    ]);\n    return nodeRef;\n}\nfunction NodeWrapper({ id, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes, nodeClickDistance, onError }) {\n    const { node, internals, isParent } = useStore((s)=>{\n        const node = s.nodeLookup.get(id);\n        const isParent = s.parentLookup.has(id);\n        return {\n            node,\n            internals: node.internals,\n            isParent\n        };\n    }, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    let nodeType = node.type || \"default\";\n    let NodeComponent = nodeTypes?.[nodeType] || builtinNodeTypes[nodeType];\n    if (NodeComponent === undefined) {\n        onError?.(\"003\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error003\"](nodeType));\n        nodeType = \"default\";\n        NodeComponent = nodeTypes?.[\"default\"] || builtinNodeTypes.default;\n    }\n    const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === \"undefined\");\n    const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === \"undefined\");\n    const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === \"undefined\");\n    const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === \"undefined\");\n    const store = useStoreApi();\n    const hasDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node);\n    const nodeRef = useNodeObserver({\n        node,\n        nodeType,\n        hasDimensions,\n        resizeObserver\n    });\n    const dragging = useDrag({\n        nodeRef,\n        disabled: node.hidden || !isDraggable,\n        noDragClassName,\n        handleSelector: node.dragHandle,\n        nodeId: id,\n        isSelectable,\n        nodeClickDistance\n    });\n    const moveSelectedNodes = useMoveSelectedNodes();\n    if (node.hidden) {\n        return null;\n    }\n    const nodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n    const inlineDimensions = getNodeInlineStyleDimensions(node);\n    const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n    const onMouseEnterHandler = onMouseEnter ? (event)=>onMouseEnter(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseMoveHandler = onMouseMove ? (event)=>onMouseMove(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseLeaveHandler = onMouseLeave ? (event)=>onMouseLeave(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onContextMenuHandler = onContextMenu ? (event)=>onContextMenu(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onDoubleClickHandler = onDoubleClick ? (event)=>onDoubleClick(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onSelectNodeHandler = (event)=>{\n        const { selectNodesOnDrag, nodeDragThreshold } = store.getState();\n        if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n            /*\n             * this handler gets called by XYDrag on drag start when selectNodesOnDrag=true\n             * here we only need to call it when selectNodesOnDrag=false\n             */ handleNodeClick({\n                id,\n                store,\n                nodeRef\n            });\n        }\n        if (onClick) {\n            onClick(event, {\n                ...internals.userNode\n            });\n        }\n    };\n    const onKeyDown = (event)=>{\n        if ((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event.nativeEvent) || disableKeyboardA11y) {\n            return;\n        }\n        if (_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const unselect = event.key === \"Escape\";\n            handleNodeClick({\n                id,\n                store,\n                unselect,\n                nodeRef\n            });\n        } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            // prevent default scrolling behavior on arrow key press when node is moved\n            event.preventDefault();\n            const { ariaLabelConfig } = store.getState();\n            store.setState({\n                ariaLiveMessage: ariaLabelConfig[\"node.a11yDescription.ariaLiveMessage\"]({\n                    direction: event.key.replace(\"Arrow\", \"\").toLowerCase(),\n                    x: ~~internals.positionAbsolute.x,\n                    y: ~~internals.positionAbsolute.y\n                })\n            });\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    const onFocus = ()=>{\n        if (disableKeyboardA11y || !nodeRef.current?.matches(\":focus-visible\")) {\n            return;\n        }\n        const { transform, width, height, autoPanOnNodeFocus, setCenter } = store.getState();\n        if (!autoPanOnNodeFocus) {\n            return;\n        }\n        const withinViewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(new Map([\n            [\n                id,\n                node\n            ]\n        ]), {\n            x: 0,\n            y: 0,\n            width,\n            height\n        }, transform, true).length > 0;\n        if (!withinViewport) {\n            setCenter(node.position.x + nodeDimensions.width / 2, node.position.y + nodeDimensions.height / 2, {\n                zoom: transform[2]\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__node\",\n            `react-flow__node-${nodeType}`,\n            {\n                // this is overwritable by passing `nopan` as a class name\n                [noPanClassName]: isDraggable\n            },\n            node.className,\n            {\n                selected: node.selected,\n                selectable: isSelectable,\n                parent: isParent,\n                draggable: isDraggable,\n                dragging\n            }\n        ]),\n        ref: nodeRef,\n        style: {\n            zIndex: internals.z,\n            transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,\n            pointerEvents: hasPointerEvents ? \"all\" : \"none\",\n            visibility: hasDimensions ? \"visible\" : \"hidden\",\n            ...node.style,\n            ...inlineDimensions\n        },\n        \"data-id\": id,\n        \"data-testid\": `rf__node-${id}`,\n        onMouseEnter: onMouseEnterHandler,\n        onMouseMove: onMouseMoveHandler,\n        onMouseLeave: onMouseLeaveHandler,\n        onContextMenu: onContextMenuHandler,\n        onClick: onSelectNodeHandler,\n        onDoubleClick: onDoubleClickHandler,\n        onKeyDown: isFocusable ? onKeyDown : undefined,\n        tabIndex: isFocusable ? 0 : undefined,\n        onFocus: isFocusable ? onFocus : undefined,\n        role: node.ariaRole ?? (isFocusable ? \"group\" : undefined),\n        \"aria-roledescription\": \"node\",\n        \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        \"aria-label\": node.ariaLabel,\n        ...node.domAttributes,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider, {\n            value: id,\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n                id: id,\n                data: node.data,\n                type: nodeType,\n                positionAbsoluteX: internals.positionAbsolute.x,\n                positionAbsoluteY: internals.positionAbsolute.y,\n                selected: node.selected ?? false,\n                selectable: isSelectable,\n                draggable: isDraggable,\n                deletable: node.deletable ?? true,\n                isConnectable: isConnectable,\n                sourcePosition: node.sourcePosition,\n                targetPosition: node.targetPosition,\n                dragging: dragging,\n                dragHandle: node.dragHandle,\n                zIndex: internals.z,\n                parentId: node.parentId,\n                ...nodeDimensions\n            })\n        })\n    });\n}\nconst selector$b = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        onError: s.onError\n    });\nfunction NodeRendererComponent(props) {\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements);\n    const resizeObserver = useResizeObserver();\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle,\n        children: nodeIds.map((nodeId)=>{\n            return(/*\n             * The split of responsibilities between NodeRenderer and\n             * NodeComponentWrapper may appear weird. However, its designed to\n             * minimize the cost of updates when individual nodes change.\n             *\n             * For example, when youre dragging a single node, that node gets\n             * updated multiple times per second. If `NodeRenderer` were to update\n             * every time, it would have to re-run the `nodes.map()` loop every\n             * time. This gets pricey with hundreds of nodes, especially if every\n             * loop cycle does more than just rendering a JSX element!\n             *\n             * As a result of this choice, we took the following implementation\n             * decisions:\n             * - NodeRenderer subscribes *only* to node IDs  and therefore\n             *   rerender *only* when visible nodes are added or removed.\n             * - NodeRenderer performs all operations the result of which can be\n             *   shared between nodes (such as creating the `ResizeObserver`\n             *   instance, or subscribing to `selector`). This means extra prop\n             *   drilling into `NodeComponentWrapper`, but it means we need to run\n             *   these operations only once  instead of once per node.\n             * - Any operations that youd normally write inside `nodes.map` are\n             *   moved into `NodeComponentWrapper`. This ensures they are\n             *   memorized  so if `NodeRenderer` *has* to rerender, it only\n             *   needs to regenerate the list of nodes, nothing else.\n             */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeWrapper, {\n                id: nodeId,\n                nodeTypes: props.nodeTypes,\n                nodeExtent: props.nodeExtent,\n                onClick: props.onNodeClick,\n                onMouseEnter: props.onNodeMouseEnter,\n                onMouseMove: props.onNodeMouseMove,\n                onMouseLeave: props.onNodeMouseLeave,\n                onContextMenu: props.onNodeContextMenu,\n                onDoubleClick: props.onNodeDoubleClick,\n                noDragClassName: props.noDragClassName,\n                noPanClassName: props.noPanClassName,\n                rfId: props.rfId,\n                disableKeyboardA11y: props.disableKeyboardA11y,\n                resizeObserver: resizeObserver,\n                nodesDraggable: nodesDraggable,\n                nodesConnectable: nodesConnectable,\n                nodesFocusable: nodesFocusable,\n                elementsSelectable: elementsSelectable,\n                nodeClickDistance: props.nodeClickDistance,\n                onError: onError\n            }, nodeId));\n        })\n    });\n}\nNodeRendererComponent.displayName = \"NodeRenderer\";\nconst NodeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeRendererComponent);\n/**\n * Hook for getting the visible edge ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible edge ids\n */ function useVisibleEdgeIds(onlyRenderVisible) {\n    const edgeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((s)=>{\n        if (!onlyRenderVisible) {\n            return s.edges.map((edge)=>edge.id);\n        }\n        const visibleEdgeIds = [];\n        if (s.width && s.height) {\n            for (const edge of s.edges){\n                const sourceNode = s.nodeLookup.get(edge.source);\n                const targetNode = s.nodeLookup.get(edge.target);\n                if (sourceNode && targetNode && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeVisible)({\n                    sourceNode,\n                    targetNode,\n                    width: s.width,\n                    height: s.height,\n                    transform: s.transform\n                })) {\n                    visibleEdgeIds.push(edge.id);\n                }\n            }\n        }\n        return visibleEdgeIds;\n    }, [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edgeIds;\n}\nconst ArrowSymbol = ({ color = \"none\", strokeWidth = 1 })=>{\n    const style = {\n        strokeWidth,\n        ...color && {\n            stroke: color\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        className: \"arrow\",\n        style: style,\n        strokeLinecap: \"round\",\n        fill: \"none\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = \"none\", strokeWidth = 1 })=>{\n    const style = {\n        strokeWidth,\n        ...color && {\n            stroke: color,\n            fill: color\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        className: \"arrowclosed\",\n        style: style,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.Arrow]: ArrowSymbol,\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n        if (!symbolExists) {\n            store.getState().onError?.(\"009\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error009\"](type));\n            return null;\n        }\n        return MarkerSymbols[type];\n    }, [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = \"strokeWidth\", strokeWidth, orient = \"auto-start-reverse\" })=>{\n    const Symbol = useMarkerSymbol(type);\n    if (!Symbol) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Symbol, {\n            color: color,\n            strokeWidth: strokeWidth\n        })\n    });\n};\n/*\n * when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n * when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n * that we can then use for creating our unique marker ids\n */ const MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const edges = useStore((s)=>s.edges);\n    const defaultEdgeOptions = useStore((s)=>s.defaultEdgeOptions);\n    const markers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const markers = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.createMarkerIds)(edges, {\n            id: rfId,\n            defaultColor,\n            defaultMarkerStart: defaultEdgeOptions?.markerStart,\n            defaultMarkerEnd: defaultEdgeOptions?.markerEnd\n        });\n        return markers;\n    }, [\n        edges,\n        defaultEdgeOptions,\n        rfId,\n        defaultColor\n    ]);\n    if (!markers.length) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        className: \"react-flow__marker\",\n        \"aria-hidden\": \"true\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n            children: markers.map((marker)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Marker, {\n                    id: marker.id,\n                    type: marker.type,\n                    color: marker.color,\n                    width: marker.width,\n                    height: marker.height,\n                    markerUnits: marker.markerUnits,\n                    strokeWidth: marker.strokeWidth,\n                    orient: marker.orient\n                }, marker.id))\n        })\n    });\n};\nMarkerDefinitions.displayName = \"MarkerDefinitions\";\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerDefinitions);\nfunction EdgeTextComponent({ x, y, label, labelStyle, labelShowBg = true, labelBgStyle, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest }) {\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 1,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n        \"react-flow__edge-textwrapper\",\n        className\n    ]);\n    const edgeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (edgeTextRef.current) {\n            const textBbox = edgeTextRef.current.getBBox();\n            setEdgeTextBbox({\n                x: textBbox.x,\n                y: textBbox.y,\n                width: textBbox.width,\n                height: textBbox.height\n            });\n        }\n    }, [\n        label\n    ]);\n    if (!label) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? \"visible\" : \"hidden\",\n        ...rest,\n        children: [\n            labelShowBg && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                width: edgeTextBbox.width + 2 * labelBgPadding[0],\n                x: -labelBgPadding[0],\n                y: -labelBgPadding[1],\n                height: edgeTextBbox.height + 2 * labelBgPadding[1],\n                className: \"react-flow__edge-textbg\",\n                style: labelBgStyle,\n                rx: labelBgBorderRadius,\n                ry: labelBgBorderRadius\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"text\", {\n                className: \"react-flow__edge-text\",\n                y: edgeTextBbox.height / 2,\n                dy: \"0.3em\",\n                ref: edgeTextRef,\n                style: labelStyle,\n                children: label\n            }),\n            children\n        ]\n    });\n}\nEdgeTextComponent.displayName = \"EdgeText\";\n/**\n * You can use the `<EdgeText />` component as a helper component to display text\n * within your custom edges.\n *\n * @public\n *\n * @example\n * ```jsx\n * import { EdgeText } from '@xyflow/react';\n *\n * export function CustomEdgeLabel({ label }) {\n *   return (\n *     <EdgeText\n *       x={100}\n *       y={100}\n *       label={label}\n *       labelStyle={{ fill: 'white' }}\n *       labelShowBg\n *       labelBgStyle={{ fill: 'red' }}\n *       labelBgPadding={[2, 4]}\n *       labelBgBorderRadius={2}\n *     />\n *   );\n * }\n *```\n */ const EdgeText = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeTextComponent);\n/**\n * The `<BaseEdge />` component gets used internally for all the edges. It can be\n * used inside a custom edge and handles the invisible helper edge and the edge label\n * for you.\n *\n * @public\n * @example\n * ```jsx\n *import { BaseEdge } from '@xyflow/react';\n *\n *export function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {\n *  const [edgePath] = getStraightPath({\n *    sourceX,\n *    sourceY,\n *    targetX,\n *    targetY,\n *  });\n *\n *  return <BaseEdge path={edgePath} {...props} />;\n *}\n *```\n *\n * @remarks If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,\n * you can pass the `markerStart` or `markerEnd` props passed to your custom edge\n * through to the [`<BaseEdge />`](/api-reference/components/base-edge) component.\n * You can see all the props passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type.\n */ function BaseEdge({ path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                ...props,\n                d: path,\n                fill: \"none\",\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                    \"react-flow__edge-path\",\n                    props.className\n                ])\n            }),\n            interactionWidth ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: path,\n                fill: \"none\",\n                strokeOpacity: 0,\n                strokeWidth: interactionWidth,\n                className: \"react-flow__edge-interaction\"\n            }) : null,\n            label && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelX) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelY) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeText, {\n                x: labelX,\n                y: labelY,\n                label: label,\n                labelStyle: labelStyle,\n                labelShowBg: labelShowBg,\n                labelBgStyle: labelBgStyle,\n                labelBgPadding: labelBgPadding,\n                labelBgBorderRadius: labelBgBorderRadius\n            }) : null\n        ]\n    });\n}\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left || pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\n/**\n * The `getSimpleBezierPath` util returns everything you need to render a simple\n * bezier edge between two nodes.\n * @public\n * @returns\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n */ function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetX, targetY, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter)({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction createSimpleBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = getSimpleBezierPath({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SimpleBezierEdge = createSimpleBezierEdge({\n    isInternal: false\n});\nconst SimpleBezierEdgeInternal = createSimpleBezierEdge({\n    isInternal: true\n});\nSimpleBezierEdge.displayName = \"SimpleBezierEdge\";\nSimpleBezierEdgeInternal.displayName = \"SimpleBezierEdgeInternal\";\nfunction createSmoothStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            borderRadius: pathOptions?.borderRadius,\n            offset: pathOptions?.offset,\n            stepPosition: pathOptions?.stepPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a smooth step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { SmoothStepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <SmoothStepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const SmoothStepEdge = createSmoothStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const SmoothStepEdgeInternal = createSmoothStepEdge({\n    isInternal: true\n});\nSmoothStepEdge.displayName = \"SmoothStepEdge\";\nSmoothStepEdgeInternal.displayName = \"SmoothStepEdgeInternal\";\nfunction createStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, ...props })=>{\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SmoothStepEdge, {\n            ...props,\n            id: _id,\n            pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n                    borderRadius: 0,\n                    offset: props.pathOptions?.offset\n                }), [\n                props.pathOptions?.offset\n            ])\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <StepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const StepEdge = createStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StepEdgeInternal = createStepEdge({\n    isInternal: true\n});\nStepEdge.displayName = \"StepEdge\";\nStepEdgeInternal.displayName = \"StepEdgeInternal\";\nfunction createStraightEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)({\n            sourceX,\n            sourceY,\n            targetX,\n            targetY\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a straight line.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StraightEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY }) {\n *   return (\n *     <StraightEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *     />\n *   );\n * }\n * ```\n */ const StraightEdge = createStraightEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StraightEdgeInternal = createStraightEdge({\n    isInternal: true\n});\nStraightEdge.displayName = \"StraightEdge\";\nStraightEdgeInternal.displayName = \"StraightEdgeInternal\";\nfunction createBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            curvature: pathOptions?.curvature\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a bezier curve.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { BezierEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <BezierEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const BezierEdge = createBezierEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const BezierEdgeInternal = createBezierEdge({\n    isInternal: true\n});\nBezierEdge.displayName = \"BezierEdge\";\nBezierEdgeInternal.displayName = \"BezierEdgeInternal\";\nconst builtinEdgeTypes = {\n    default: BezierEdgeInternal,\n    straight: StraightEdgeInternal,\n    step: StepEdgeInternal,\n    smoothstep: SmoothStepEdgeInternal,\n    simplebezier: SimpleBezierEdgeInternal\n};\nconst nullPosition = {\n    sourceX: null,\n    sourceY: null,\n    targetX: null,\n    targetY: null,\n    sourcePosition: null,\n    targetPosition: null\n};\nconst shiftX = (x, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left) return x - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top) return y - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = \"react-flow__edgeupdater\";\n/**\n * @internal\n */ function EdgeAnchor({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\n}\nfunction EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {\n    const store = useStoreApi();\n    const handleEdgeUpdater = (event, oppositeHandle)=>{\n        // avoid triggering edge updater if mouse btn is not left\n        if (event.button !== 0) {\n            return;\n        }\n        const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy, updateConnection } = store.getState();\n        const isTarget = oppositeHandle.type === \"target\";\n        const _onReconnectEnd = (evt, connectionState)=>{\n            setReconnecting(false);\n            onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);\n        };\n        const onConnectEdge = (connection)=>onReconnect?.(edge, connection);\n        const _onConnectStart = (_event, params)=>{\n            setReconnecting(true);\n            onReconnectStart?.(event, edge, oppositeHandle.type);\n            onConnectStart?.(_event, params);\n        };\n        _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n            autoPanOnConnect,\n            connectionMode,\n            connectionRadius,\n            domNode,\n            handleId: oppositeHandle.id,\n            nodeId: oppositeHandle.nodeId,\n            nodeLookup,\n            isTarget,\n            edgeUpdaterType: oppositeHandle.type,\n            lib,\n            flowId,\n            cancelConnection,\n            panBy,\n            isValidConnection,\n            onConnect: onConnectEdge,\n            onConnectStart: _onConnectStart,\n            onConnectEnd,\n            onReconnectEnd: _onReconnectEnd,\n            updateConnection,\n            getTransform: ()=>store.getState().transform,\n            getFromHandle: ()=>store.getState().connection.fromHandle,\n            dragThreshold: store.getState().connectionDragThreshold,\n            handleDomNode: event.currentTarget\n        });\n    };\n    const onReconnectSourceMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.target,\n            id: edge.targetHandle ?? null,\n            type: \"target\"\n        });\n    const onReconnectTargetMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.source,\n            id: edge.sourceHandle ?? null,\n            type: \"source\"\n        });\n    const onReconnectMouseEnter = ()=>setUpdateHover(true);\n    const onReconnectMouseOut = ()=>setUpdateHover(false);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (isReconnectable === true || isReconnectable === \"source\") && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: sourcePosition,\n                centerX: sourceX,\n                centerY: sourceY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectSourceMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"source\"\n            }),\n            (isReconnectable === true || isReconnectable === \"target\") && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: targetPosition,\n                centerX: targetX,\n                centerY: targetY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectTargetMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"target\"\n            })\n        ]\n    });\n}\nfunction EdgeWrapper({ id, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes, noPanClassName, onError, disableKeyboardA11y }) {\n    let edge = useStore((s)=>s.edgeLookup.get(id));\n    const defaultEdgeOptions = useStore((s)=>s.defaultEdgeOptions);\n    edge = defaultEdgeOptions ? {\n        ...defaultEdgeOptions,\n        ...edge\n    } : edge;\n    let edgeType = edge.type || \"default\";\n    let EdgeComponent = edgeTypes?.[edgeType] || builtinEdgeTypes[edgeType];\n    if (EdgeComponent === undefined) {\n        onError?.(\"011\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error011\"](edgeType));\n        edgeType = \"default\";\n        EdgeComponent = edgeTypes?.[\"default\"] || builtinEdgeTypes.default;\n    }\n    const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === \"undefined\");\n    const isReconnectable = typeof onReconnect !== \"undefined\" && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable === \"undefined\");\n    const isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable === \"undefined\");\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [reconnecting, setReconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const store = useStoreApi();\n    const { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((store)=>{\n        const sourceNode = store.nodeLookup.get(edge.source);\n        const targetNode = store.nodeLookup.get(edge.target);\n        if (!sourceNode || !targetNode) {\n            return {\n                zIndex: edge.zIndex,\n                ...nullPosition\n            };\n        }\n        const edgePosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgePosition)({\n            id,\n            sourceNode,\n            targetNode,\n            sourceHandle: edge.sourceHandle || null,\n            targetHandle: edge.targetHandle || null,\n            connectionMode: store.connectionMode,\n            onError\n        });\n        const zIndex = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElevatedEdgeZIndex)({\n            selected: edge.selected,\n            zIndex: edge.zIndex,\n            sourceNode,\n            targetNode,\n            elevateOnSelect: store.elevateEdgesOnSelect\n        });\n        return {\n            zIndex,\n            ...edgePosition || nullPosition\n        };\n    }, [\n        edge.source,\n        edge.target,\n        edge.sourceHandle,\n        edge.targetHandle,\n        edge.selected,\n        edge.zIndex\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>edge.markerStart ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerStart, rfId)}')` : undefined, [\n        edge.markerStart,\n        rfId\n    ]);\n    const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>edge.markerEnd ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerEnd, rfId)}')` : undefined, [\n        edge.markerEnd,\n        rfId\n    ]);\n    if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null) {\n        return null;\n    }\n    const onEdgeClick = (event)=>{\n        const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n        if (isSelectable) {\n            store.setState({\n                nodesSelectionActive: false\n            });\n            if (edge.selected && multiSelectionActive) {\n                unselectNodesAndEdges({\n                    nodes: [],\n                    edges: [\n                        edge\n                    ]\n                });\n                edgeRef.current?.blur();\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n        if (onClick) {\n            onClick(event, edge);\n        }\n    };\n    const onEdgeDoubleClick = onDoubleClick ? (event)=>{\n        onDoubleClick(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeContextMenu = onContextMenu ? (event)=>{\n        onContextMenu(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseEnter = onMouseEnter ? (event)=>{\n        onMouseEnter(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseMove = onMouseMove ? (event)=>{\n        onMouseMove(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseLeave = onMouseLeave ? (event)=>{\n        onMouseLeave(event, {\n            ...edge\n        });\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (!disableKeyboardA11y && _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const { unselectNodesAndEdges, addSelectedEdges } = store.getState();\n            const unselect = event.key === \"Escape\";\n            if (unselect) {\n                edgeRef.current?.blur();\n                unselectNodesAndEdges({\n                    edges: [\n                        edge\n                    ]\n                });\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: {\n            zIndex\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__edge\",\n                `react-flow__edge-${edgeType}`,\n                edge.className,\n                noPanClassName,\n                {\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    inactive: !isSelectable && !onClick,\n                    updating: updateHover,\n                    selectable: isSelectable\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClick,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: edge.ariaRole ?? (isFocusable ? \"group\" : \"img\"),\n            \"aria-roledescription\": \"edge\",\n            \"data-id\": id,\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": edge.ariaLabel === null ? undefined : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef,\n            ...edge.domAttributes,\n            children: [\n                !reconnecting && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeComponent, {\n                    id: id,\n                    source: edge.source,\n                    target: edge.target,\n                    type: edge.type,\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    selectable: isSelectable,\n                    deletable: edge.deletable ?? true,\n                    label: edge.label,\n                    labelStyle: edge.labelStyle,\n                    labelShowBg: edge.labelShowBg,\n                    labelBgStyle: edge.labelBgStyle,\n                    labelBgPadding: edge.labelBgPadding,\n                    labelBgBorderRadius: edge.labelBgBorderRadius,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    data: edge.data,\n                    style: edge.style,\n                    sourceHandleId: edge.sourceHandle,\n                    targetHandleId: edge.targetHandle,\n                    markerStart: markerStartUrl,\n                    markerEnd: markerEndUrl,\n                    pathOptions: \"pathOptions\" in edge ? edge.pathOptions : undefined,\n                    interactionWidth: edge.interactionWidth\n                }),\n                isReconnectable && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeUpdateAnchors, {\n                    edge: edge,\n                    isReconnectable: isReconnectable,\n                    reconnectRadius: reconnectRadius,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    setUpdateHover: setUpdateHover,\n                    setReconnecting: setReconnecting\n                })\n            ]\n        })\n    });\n}\nconst selector$a = (s)=>({\n        edgesFocusable: s.edgesFocusable,\n        edgesReconnectable: s.edgesReconnectable,\n        elementsSelectable: s.elementsSelectable,\n        connectionMode: s.connectionMode,\n        onError: s.onError\n    });\nfunction EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {\n    const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"react-flow__edges\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MarkerDefinitions$1, {\n                defaultColor: defaultMarkerColor,\n                rfId: rfId\n            }),\n            edgeIds.map((id)=>{\n                return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeWrapper, {\n                    id: id,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    noPanClassName: noPanClassName,\n                    onReconnect: onReconnect,\n                    onContextMenu: onEdgeContextMenu,\n                    onMouseEnter: onEdgeMouseEnter,\n                    onMouseMove: onEdgeMouseMove,\n                    onMouseLeave: onEdgeMouseLeave,\n                    onClick: onEdgeClick,\n                    reconnectRadius: reconnectRadius,\n                    onDoubleClick: onEdgeDoubleClick,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    rfId: rfId,\n                    onError: onError,\n                    edgeTypes: edgeTypes,\n                    disableKeyboardA11y: disableKeyboardA11y\n                }, id);\n            })\n        ]\n    });\n}\nEdgeRendererComponent.displayName = \"EdgeRenderer\";\nconst EdgeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeRendererComponent);\nconst selector$9 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$9);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__viewport xyflow__viewport react-flow__container\",\n        style: {\n            transform\n        },\n        children: children\n    });\n}\n/**\n * Hook for calling onInit handler.\n *\n * @internal\n */ function useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n            setTimeout(()=>onInit(rfInstance), 1);\n            isInitialized.current = true;\n        }\n    }, [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst selector$8 = (state)=>state.panZoom?.syncViewport;\n/**\n * Hook for syncing the viewport with the panzoom instance.\n *\n * @internal\n * @param viewport\n */ function useViewportSync(viewport) {\n    const syncViewport = useStore(selector$8);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (viewport) {\n            syncViewport?.(viewport);\n            store.setState({\n                transform: [\n                    viewport.x,\n                    viewport.y,\n                    viewport.zoom\n                ]\n            });\n        }\n    }, [\n        viewport,\n        syncViewport\n    ]);\n    return null;\n}\nfunction storeSelector$1(s) {\n    return s.connection.inProgress ? {\n        ...s.connection,\n        to: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(s.connection.to, s.transform)\n    } : {\n        ...s.connection\n    };\n}\nfunction getSelector(connectionSelector) {\n    if (connectionSelector) {\n        const combinedSelector = (s)=>{\n            const connection = storeSelector$1(s);\n            return connectionSelector(connection);\n        };\n        return combinedSelector;\n    }\n    return storeSelector$1;\n}\n/**\n * The `useConnection` hook returns the current connection when there is an active\n * connection interaction. If no connection interaction is active, it returns null\n * for every property. A typical use case for this hook is to colorize handles\n * based on a certain condition (e.g. if the connection is valid or not).\n *\n * @public\n * @param connectionSelector - An optional selector function used to extract a slice of the\n * `ConnectionState` data. Using a selector can prevent component re-renders where data you don't\n * otherwise care about might change. If a selector is not provided, the entire `ConnectionState`\n * object is returned unchanged.\n * @example\n *\n * ```tsx\n *import { useConnection } from '@xyflow/react';\n *\n *function App() {\n *  const connection = useConnection();\n *\n *  return (\n *    <div> {connection ? `Someone is trying to make a connection from ${connection.fromNode} to this one.` : 'There are currently no incoming connections!'}\n *\n *   </div>\n *   );\n * }\n * ```\n *\n * @returns ConnectionState\n */ function useConnection(connectionSelector) {\n    const combinedSelector = getSelector(connectionSelector);\n    return useStore(combinedSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n}\nconst selector$7 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        isValid: s.connection.isValid,\n        inProgress: s.connection.inProgress,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodesConnectable, width, height, isValid, inProgress } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const renderConnection = !!(width && nodesConnectable && inProgress);\n    if (!renderConnection) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__connectionline react-flow__container\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__connection\",\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid)\n            ]),\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLine, {\n                style: style,\n                type: type,\n                CustomComponent: component,\n                isValid: isValid\n            })\n        })\n    });\n}\nconst ConnectionLine = ({ style, type = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, CustomComponent, isValid })=>{\n    const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition } = useConnection();\n    if (!inProgress) {\n        return;\n    }\n    if (CustomComponent) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: from.x,\n            fromY: from.y,\n            toX: to.x,\n            toY: to.y,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid),\n            toNode: toNode,\n            toHandle: toHandle\n        });\n    }\n    let path = \"\";\n    const pathParams = {\n        sourceX: from.x,\n        sourceY: from.y,\n        sourcePosition: fromPosition,\n        targetX: to.x,\n        targetY: to.y,\n        targetPosition: toPosition\n    };\n    switch(type){\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SimpleBezier:\n            [path] = getSimpleBezierPath(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Step:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n                ...pathParams,\n                borderRadius: 0\n            });\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SmoothStep:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)(pathParams);\n            break;\n        default:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)(pathParams);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = \"ConnectionLine\";\nconst emptyTypes = {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {\n    const typesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeOrEdgeTypes);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (true) {\n            const usedKeys = new Set([\n                ...Object.keys(typesRef.current),\n                ...Object.keys(nodeOrEdgeTypes)\n            ]);\n            for (const key of usedKeys){\n                if (typesRef.current[key] !== nodeOrEdgeTypes[key]) {\n                    store.getState().onError?.(\"002\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error002\"]());\n                    break;\n                }\n            }\n            typesRef.current = nodeOrEdgeTypes;\n        }\n    }, [\n        nodeOrEdgeTypes\n    ]);\n}\nfunction useStylesLoadedWarning() {\n    const store = useStoreApi();\n    const checked = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (true) {\n            if (!checked.current) {\n                const pane = document.querySelector(\".react-flow__pane\");\n                if (pane && !(window.getComputedStyle(pane).zIndex === \"1\")) {\n                    store.getState().onError?.(\"013\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error013\"](\"react\"));\n                }\n                checked.current = true;\n            }\n        }\n    }, []);\n}\nfunction GraphViewComponent({ nodeTypes, edgeTypes, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {\n    useNodeOrEdgeTypesWarning(nodeTypes);\n    useNodeOrEdgeTypesWarning(edgeTypes);\n    useStylesLoadedWarning();\n    useOnInitHandler(onInit);\n    useViewportSync(viewport);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FlowRenderer, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        paneClickDistance: paneClickDistance,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        onViewportChange: onViewportChange,\n        isControlledViewport: !!viewport,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Viewport, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeRenderer, {\n                    edgeTypes: edgeTypes,\n                    onEdgeClick: onEdgeClick,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLineWrapper, {\n                    style: connectionLineStyle,\n                    type: connectionLineType,\n                    component: connectionLineComponent,\n                    containerStyle: connectionLineContainerStyle\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__edgelabel-renderer\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeRenderer, {\n                    nodeTypes: nodeTypes,\n                    onNodeClick: onNodeClick,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    nodeClickDistance: nodeClickDistance,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    noPanClassName: noPanClassName,\n                    noDragClassName: noDragClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__viewport-portal\"\n                })\n            ]\n        })\n    });\n}\nGraphViewComponent.displayName = \"GraphView\";\nconst GraphView = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GraphViewComponent);\nconst getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom = 0.5, maxZoom = 2, nodeOrigin, nodeExtent } = {})=>{\n    const nodeLookup = new Map();\n    const parentLookup = new Map();\n    const connectionLookup = new Map();\n    const edgeLookup = new Map();\n    const storeEdges = defaultEdges ?? edges ?? [];\n    const storeNodes = defaultNodes ?? nodes ?? [];\n    const storeNodeOrigin = nodeOrigin ?? [\n        0,\n        0\n    ];\n    const storeNodeExtent = nodeExtent ?? _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent;\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, storeEdges);\n    const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(storeNodes, nodeLookup, parentLookup, {\n        nodeOrigin: storeNodeOrigin,\n        nodeExtent: storeNodeExtent,\n        elevateNodesOnSelect: false\n    });\n    let transform = [\n        0,\n        0,\n        1\n    ];\n    if (fitView && width && height) {\n        const bounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodeLookup, {\n            filter: (node)=>!!((node.width || node.initialWidth) && (node.height || node.initialHeight))\n        });\n        const { x, y, zoom } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, fitViewOptions?.padding ?? 0.1);\n        transform = [\n            x,\n            y,\n            zoom\n        ];\n    }\n    return {\n        rfId: \"1\",\n        width: width ?? 0,\n        height: height ?? 0,\n        transform,\n        nodes: storeNodes,\n        nodesInitialized,\n        nodeLookup,\n        parentLookup,\n        edges: storeEdges,\n        edgeLookup,\n        connectionLookup,\n        onNodesChange: null,\n        onEdgesChange: null,\n        hasDefaultNodes: defaultNodes !== undefined,\n        hasDefaultEdges: defaultEdges !== undefined,\n        panZoom: null,\n        minZoom,\n        maxZoom,\n        translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n        nodeExtent: storeNodeExtent,\n        nodesSelectionActive: false,\n        userSelectionActive: false,\n        userSelectionRect: null,\n        connectionMode: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict,\n        domNode: null,\n        paneDragging: false,\n        noPanClassName: \"nopan\",\n        nodeOrigin: storeNodeOrigin,\n        nodeDragThreshold: 1,\n        connectionDragThreshold: 1,\n        snapGrid: [\n            15,\n            15\n        ],\n        snapToGrid: false,\n        nodesDraggable: true,\n        nodesConnectable: true,\n        nodesFocusable: true,\n        edgesFocusable: true,\n        edgesReconnectable: true,\n        elementsSelectable: true,\n        elevateNodesOnSelect: true,\n        elevateEdgesOnSelect: false,\n        selectNodesOnDrag: true,\n        multiSelectionActive: false,\n        fitViewQueued: fitView ?? false,\n        fitViewOptions,\n        fitViewResolver: null,\n        connection: {\n            ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n        },\n        connectionClickStartHandle: null,\n        connectOnClick: true,\n        ariaLiveMessage: \"\",\n        autoPanOnConnect: true,\n        autoPanOnNodeDrag: true,\n        autoPanOnNodeFocus: true,\n        autoPanSpeed: 15,\n        connectionRadius: 20,\n        onError: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.devWarn,\n        isValidConnection: undefined,\n        onSelectionChangeHandlers: [],\n        lib: \"react\",\n        debug: false,\n        ariaLabelConfig: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.defaultAriaLabelConfig\n    };\n};\nconst createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent })=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.createWithEqualityFn)((set, get)=>{\n        async function resolveFitView() {\n            const { nodeLookup, panZoom, fitViewOptions, fitViewResolver, width, height, minZoom, maxZoom } = get();\n            if (!panZoom) {\n                return;\n            }\n            await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.fitViewport)({\n                nodes: nodeLookup,\n                width,\n                height,\n                panZoom,\n                minZoom,\n                maxZoom\n            }, fitViewOptions);\n            fitViewResolver?.resolve(true);\n            /**\n         * wait for the fitViewport to resolve before deleting the resolver,\n         * we want to reuse the old resolver if the user calls fitView again in the mean time\n         */ set({\n                fitViewResolver: null\n            });\n        }\n        return {\n            ...getInitialState({\n                nodes,\n                edges,\n                width,\n                height,\n                fitView,\n                fitViewOptions,\n                minZoom,\n                maxZoom,\n                nodeOrigin,\n                nodeExtent,\n                defaultNodes,\n                defaultEdges\n            }),\n            setNodes: (nodes)=>{\n                const { nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, fitViewQueued } = get();\n                /*\n             * setNodes() is called exclusively in response to user actions:\n             * - either when the `<ReactFlow nodes>` prop is updated in the controlled ReactFlow setup,\n             * - or when the user calls something like `reactFlowInstance.setNodes()` in an uncontrolled ReactFlow setup.\n             *\n             * When this happens, we take the note objects passed by the user and extend them with fields\n             * relevant for internal React Flow operations.\n             */ const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: true\n                });\n                if (fitViewQueued && nodesInitialized) {\n                    resolveFitView();\n                    set({\n                        nodes,\n                        nodesInitialized,\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    set({\n                        nodes,\n                        nodesInitialized\n                    });\n                }\n            },\n            setEdges: (edges)=>{\n                const { connectionLookup, edgeLookup } = get();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, edges);\n                set({\n                    edges\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                if (nodes) {\n                    const { setNodes } = get();\n                    setNodes(nodes);\n                    set({\n                        hasDefaultNodes: true\n                    });\n                }\n                if (edges) {\n                    const { setEdges } = get();\n                    setEdges(edges);\n                    set({\n                        hasDefaultEdges: true\n                    });\n                }\n            },\n            /*\n         * Every node gets registerd at a ResizeObserver. Whenever a node\n         * changes its dimensions, this function is called to measure the\n         * new dimensions and update the nodes.\n         */ updateNodeInternals: (updates)=>{\n                const { triggerNodeChanges, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, debug, fitViewQueued } = get();\n                const { changes, updatedInternals } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateNodeInternals)(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent);\n                if (!updatedInternals) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateAbsolutePositions)(nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent\n                });\n                if (fitViewQueued) {\n                    resolveFitView();\n                    set({\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    // we always want to trigger useStore calls whenever updateNodeInternals is called\n                    set({});\n                }\n                if (changes?.length > 0) {\n                    if (debug) {\n                        console.log(\"React Flow: trigger node changes\", changes);\n                    }\n                    triggerNodeChanges?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, dragging = false)=>{\n                const parentExpandChildren = [];\n                const changes = [];\n                const { nodeLookup, triggerNodeChanges } = get();\n                for (const [id, dragItem] of nodeDragItems){\n                    // we are using the nodelookup to be sure to use the current expandParent and parentId value\n                    const node = nodeLookup.get(id);\n                    const expandParent = !!(node?.expandParent && node?.parentId && dragItem?.position);\n                    const change = {\n                        id,\n                        type: \"position\",\n                        position: expandParent ? {\n                            x: Math.max(0, dragItem.position.x),\n                            y: Math.max(0, dragItem.position.y)\n                        } : dragItem.position,\n                        dragging\n                    };\n                    if (expandParent && node.parentId) {\n                        parentExpandChildren.push({\n                            id,\n                            parentId: node.parentId,\n                            rect: {\n                                ...dragItem.internals.positionAbsolute,\n                                width: dragItem.measured.width ?? 0,\n                                height: dragItem.measured.height ?? 0\n                            }\n                        });\n                    }\n                    changes.push(change);\n                }\n                if (parentExpandChildren.length > 0) {\n                    const { parentLookup, nodeOrigin } = get();\n                    const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n                    changes.push(...parentExpandChanges);\n                }\n                triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, setNodes, nodes, hasDefaultNodes, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const updatedNodes = applyNodeChanges(changes, nodes);\n                        setNodes(updatedNodes);\n                    }\n                    if (debug) {\n                        console.log(\"React Flow: trigger node changes\", changes);\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            triggerEdgeChanges: (changes)=>{\n                const { onEdgesChange, setEdges, edges, hasDefaultEdges, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultEdges) {\n                        const updatedEdges = applyEdgeChanges(changes, edges);\n                        setEdges(updatedEdges);\n                    }\n                    if (debug) {\n                        console.log(\"React Flow: trigger edge changes\", changes);\n                    }\n                    onEdgesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const nodeChanges = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                    triggerNodeChanges(nodeChanges);\n                    return;\n                }\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set([\n                    ...selectedNodeIds\n                ]), true));\n                triggerEdgeChanges(getSelectionChanges(edgeLookup));\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                    triggerEdgeChanges(changedEdges);\n                    return;\n                }\n                triggerEdgeChanges(getSelectionChanges(edgeLookup, new Set([\n                    ...selectedEdgeIds\n                ])));\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(), true));\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodesToUnselect = nodes ? nodes : storeNodes;\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const nodeChanges = nodesToUnselect.map((n)=>{\n                    const internalNode = nodeLookup.get(n.id);\n                    if (internalNode) {\n                        /*\n                     * we need to unselect the internal node that was selected previously before we\n                     * send the change to the user to prevent it to be selected while dragging the new node\n                     */ internalNode.selected = false;\n                    }\n                    return createSelectionChange(n.id, false);\n                });\n                const edgeChanges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setMinZoom: (minZoom)=>{\n                const { panZoom, maxZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { panZoom, minZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().panZoom?.setTranslateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            setPaneClickDistance: (clickDistance)=>{\n                get().panZoom?.setClickDistance(clickDistance);\n            },\n            resetSelectedElements: ()=>{\n                const { edges, nodes, triggerNodeChanges, triggerEdgeChanges, elementsSelectable } = get();\n                if (!elementsSelectable) {\n                    return;\n                }\n                const nodeChanges = nodes.reduce((res, node)=>node.selected ? [\n                        ...res,\n                        createSelectionChange(node.id, false)\n                    ] : res, []);\n                const edgeChanges = edges.reduce((res, edge)=>edge.selected ? [\n                        ...res,\n                        createSelectionChange(edge.id, false)\n                    ] : res, []);\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setNodeExtent: (nextNodeExtent)=>{\n                const { nodes, nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, nodeExtent } = get();\n                if (nextNodeExtent[0][0] === nodeExtent[0][0] && nextNodeExtent[0][1] === nodeExtent[0][1] && nextNodeExtent[1][0] === nodeExtent[1][0] && nextNodeExtent[1][1] === nodeExtent[1][1]) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent: nextNodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: false\n                });\n                set({\n                    nodeExtent: nextNodeExtent\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, panZoom, translateExtent } = get();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.panBy)({\n                    delta,\n                    panZoom,\n                    transform,\n                    translateExtent,\n                    width,\n                    height\n                });\n            },\n            setCenter: async (x, y, options)=>{\n                const { width, height, maxZoom, panZoom } = get();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                const nextZoom = typeof options?.zoom !== \"undefined\" ? options.zoom : maxZoom;\n                await panZoom.setViewport({\n                    x: width / 2 - x * nextZoom,\n                    y: height / 2 - y * nextZoom,\n                    zoom: nextZoom\n                }, {\n                    duration: options?.duration,\n                    ease: options?.ease,\n                    interpolate: options?.interpolate\n                });\n                return Promise.resolve(true);\n            },\n            cancelConnection: ()=>{\n                set({\n                    connection: {\n                        ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n                    }\n                });\n            },\n            updateConnection: (connection)=>{\n                set({\n                    connection\n                });\n            },\n            reset: ()=>set({\n                    ...getInitialState()\n                })\n        };\n    }, Object.is);\n/**\n * The `<ReactFlowProvider />` component is a [context provider](https://react.dev/learn/passing-data-deeply-with-context#)\n * that makes it possible to access a flow's internal state outside of the\n * [`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we\n * provide rely on this component to work.\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow, ReactFlowProvider, useNodes } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlowProvider>\n *      <ReactFlow nodes={...} edges={...} />\n *      <Sidebar />\n *    </ReactFlowProvider>\n *  );\n *}\n *\n *function Sidebar() {\n *  // This hook will only work if the component it's used in is a child of a\n *  // <ReactFlowProvider />.\n *  const nodes = useNodes()\n *\n *  return <aside>do something with nodes</aside>;\n *}\n *```\n *\n * @remarks If you're using a router and want your flow's state to persist across routes,\n * it's vital that you place the `<ReactFlowProvider />` component _outside_ of\n * your router. If you have multiple flows on the same page you will need to use a separate\n * `<ReactFlowProvider />` for each flow.\n */ function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, initialMinZoom: minZoom, initialMaxZoom: maxZoom, initialFitViewOptions: fitViewOptions, fitView, nodeOrigin, nodeExtent, children }) {\n    const [store] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>createStore({\n            nodes,\n            edges,\n            defaultNodes,\n            defaultEdges,\n            width,\n            height,\n            fitView,\n            minZoom,\n            maxZoom,\n            fitViewOptions,\n            nodeOrigin,\n            nodeExtent\n        }));\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider$1, {\n        value: store,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchProvider, {\n            children: children\n        })\n    });\n}\nfunction Wrapper({ children, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent }) {\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (isWrapped) {\n        /*\n         * we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n         * https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n         */ return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactFlowProvider, {\n        initialNodes: nodes,\n        initialEdges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        initialWidth: width,\n        initialHeight: height,\n        fitView: fitView,\n        initialFitViewOptions: fitViewOptions,\n        initialMinZoom: minZoom,\n        initialMaxZoom: maxZoom,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        children: children\n    });\n}\nconst wrapperStyle = {\n    width: \"100%\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    position: \"relative\",\n    zIndex: 0\n};\nfunction ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes, edgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = \"Backspace\", selectionKeyCode = \"Shift\", selectionOnDrag = false, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panActivationKeyCode = \"Space\", multiSelectionKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? \"Meta\" : \"Control\", zoomActivationKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? \"Meta\" : \"Control\", snapToGrid, snapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag, nodesDraggable, autoPanOnNodeFocus, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = true, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = \"#b1b1b7\", zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 0, nodeClickDistance = 0, children, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = \"nodrag\", noWheelClassName = \"nowheel\", noPanClassName = \"nopan\", fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect, elevateEdgesOnSelect, disableKeyboardA11y = false, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style, id, nodeDragThreshold, connectionDragThreshold, viewport, onViewportChange, width, height, colorMode = \"light\", debug, onScroll, ariaLabelConfig, ...rest }, ref) {\n    const rfId = id || \"1\";\n    const colorModeClassName = useColorModeClass(colorMode);\n    // Undo scroll events, preventing viewport from shifting when nodes outside of it are focused\n    const wrapperOnScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        e.currentTarget.scrollTo({\n            top: 0,\n            left: 0,\n            behavior: \"instant\"\n        });\n        onScroll?.(e);\n    }, [\n        onScroll\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-testid\": \"rf__wrapper\",\n        ...rest,\n        onScroll: wrapperOnScroll,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow\",\n            className,\n            colorModeClassName\n        ]),\n        id: id,\n        role: \"application\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, {\n            nodes: nodes,\n            edges: edges,\n            width: width,\n            height: height,\n            fitView: fitView,\n            fitViewOptions: fitViewOptions,\n            minZoom: minZoom,\n            maxZoom: maxZoom,\n            nodeOrigin: nodeOrigin,\n            nodeExtent: nodeExtent,\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GraphView, {\n                    onInit: onInit,\n                    onNodeClick: onNodeClick,\n                    onEdgeClick: onEdgeClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    nodeTypes: nodeTypes,\n                    edgeTypes: edgeTypes,\n                    connectionLineType: connectionLineType,\n                    connectionLineStyle: connectionLineStyle,\n                    connectionLineComponent: connectionLineComponent,\n                    connectionLineContainerStyle: connectionLineContainerStyle,\n                    selectionKeyCode: selectionKeyCode,\n                    selectionOnDrag: selectionOnDrag,\n                    selectionMode: selectionMode,\n                    deleteKeyCode: deleteKeyCode,\n                    multiSelectionKeyCode: multiSelectionKeyCode,\n                    panActivationKeyCode: panActivationKeyCode,\n                    zoomActivationKeyCode: zoomActivationKeyCode,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    defaultViewport: defaultViewport$1,\n                    translateExtent: translateExtent,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    preventScrolling: preventScrolling,\n                    zoomOnScroll: zoomOnScroll,\n                    zoomOnPinch: zoomOnPinch,\n                    zoomOnDoubleClick: zoomOnDoubleClick,\n                    panOnScroll: panOnScroll,\n                    panOnScrollSpeed: panOnScrollSpeed,\n                    panOnScrollMode: panOnScrollMode,\n                    panOnDrag: panOnDrag,\n                    onPaneClick: onPaneClick,\n                    onPaneMouseEnter: onPaneMouseEnter,\n                    onPaneMouseMove: onPaneMouseMove,\n                    onPaneMouseLeave: onPaneMouseLeave,\n                    onPaneScroll: onPaneScroll,\n                    onPaneContextMenu: onPaneContextMenu,\n                    paneClickDistance: paneClickDistance,\n                    nodeClickDistance: nodeClickDistance,\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    onSelectionStart: onSelectionStart,\n                    onSelectionEnd: onSelectionEnd,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noDragClassName: noDragClassName,\n                    noWheelClassName: noWheelClassName,\n                    noPanClassName: noPanClassName,\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    viewport: viewport,\n                    onViewportChange: onViewportChange\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StoreUpdater, {\n                    nodes: nodes,\n                    edges: edges,\n                    defaultNodes: defaultNodes,\n                    defaultEdges: defaultEdges,\n                    onConnect: onConnect,\n                    onConnectStart: onConnectStart,\n                    onConnectEnd: onConnectEnd,\n                    onClickConnectStart: onClickConnectStart,\n                    onClickConnectEnd: onClickConnectEnd,\n                    nodesDraggable: nodesDraggable,\n                    autoPanOnNodeFocus: autoPanOnNodeFocus,\n                    nodesConnectable: nodesConnectable,\n                    nodesFocusable: nodesFocusable,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    elevateNodesOnSelect: elevateNodesOnSelect,\n                    elevateEdgesOnSelect: elevateEdgesOnSelect,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    nodeExtent: nodeExtent,\n                    onNodesChange: onNodesChange,\n                    onEdgesChange: onEdgesChange,\n                    snapToGrid: snapToGrid,\n                    snapGrid: snapGrid,\n                    connectionMode: connectionMode,\n                    translateExtent: translateExtent,\n                    connectOnClick: connectOnClick,\n                    defaultEdgeOptions: defaultEdgeOptions,\n                    fitView: fitView,\n                    fitViewOptions: fitViewOptions,\n                    onNodesDelete: onNodesDelete,\n                    onEdgesDelete: onEdgesDelete,\n                    onDelete: onDelete,\n                    onNodeDragStart: onNodeDragStart,\n                    onNodeDrag: onNodeDrag,\n                    onNodeDragStop: onNodeDragStop,\n                    onSelectionDrag: onSelectionDrag,\n                    onSelectionDragStart: onSelectionDragStart,\n                    onSelectionDragStop: onSelectionDragStop,\n                    onMove: onMove,\n                    onMoveStart: onMoveStart,\n                    onMoveEnd: onMoveEnd,\n                    noPanClassName: noPanClassName,\n                    nodeOrigin: nodeOrigin,\n                    rfId: rfId,\n                    autoPanOnConnect: autoPanOnConnect,\n                    autoPanOnNodeDrag: autoPanOnNodeDrag,\n                    autoPanSpeed: autoPanSpeed,\n                    onError: onError,\n                    connectionRadius: connectionRadius,\n                    isValidConnection: isValidConnection,\n                    selectNodesOnDrag: selectNodesOnDrag,\n                    nodeDragThreshold: nodeDragThreshold,\n                    connectionDragThreshold: connectionDragThreshold,\n                    onBeforeDelete: onBeforeDelete,\n                    paneClickDistance: paneClickDistance,\n                    debug: debug,\n                    ariaLabelConfig: ariaLabelConfig\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListener, {\n                    onSelectionChange: onSelectionChange\n                }),\n                children,\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Attribution, {\n                    proOptions: proOptions,\n                    position: attributionPosition\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(A11yDescriptions, {\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\n/**\n * The `<ReactFlow />` component is the heart of your React Flow application.\n * It renders your nodes and edges and handles user interaction\n *\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (<ReactFlow\n *    nodes={...}\n *    edges={...}\n *    onNodesChange={...}\n *    ...\n *  />);\n *}\n *```\n */ var index = fixedForwardRef(ReactFlow);\nconst selector$6 = (s)=>s.domNode?.querySelector(\".react-flow__edgelabel-renderer\");\n/**\n * Edges are SVG-based. If you want to render more complex labels you can use the\n * `<EdgeLabelRenderer />` component to access a div based renderer. This component\n * is a portal that renders the label in a `<div />` that is positioned on top of\n * the edges. You can see an example usage of the component in the\n * [edge label renderer example](/examples/edges/edge-label-renderer).\n * @public\n *\n * @example\n * ```jsx\n * import React from 'react';\n * import { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';\n *\n * export function CustomEdge({ id, data, ...props }) {\n *   const [edgePath, labelX, labelY] = getBezierPath(props);\n *\n *   return (\n *     <>\n *       <BaseEdge id={id} path={edgePath} />\n *       <EdgeLabelRenderer>\n *         <div\n *           style={{\n *             position: 'absolute',\n *             transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n *             background: '#ffcc00',\n *             padding: 10,\n *         }}\n *           className=\"nodrag nopan\"\n *         >\n *          {data.label}\n *         </div>\n *       </EdgeLabelRenderer>\n *     </>\n *   );\n * };\n * ```\n *\n * @remarks The `<EdgeLabelRenderer />` has no pointer events by default. If you want to\n * add mouse interactions you need to set the style `pointerEvents: all` and add\n * the `nopan` class on the label or the element you want to interact with.\n */ function EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$6);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, edgeLabelRenderer);\n}\nconst selector$5 = (s)=>s.domNode?.querySelector(\".react-flow__viewport-portal\");\n/**\n * The `<ViewportPortal />` component can be used to add components to the same viewport\n * of the flow where nodes and edges are rendered. This is useful when you want to render\n * your own components that are adhere to the same coordinate system as the nodes & edges\n * and are also affected by zooming and panning\n * @public\n * @example\n *\n * ```jsx\n *import React from 'react';\n *import { ViewportPortal } from '@xyflow/react';\n *\n *export default function () {\n *  return (\n *    <ViewportPortal>\n *      <div\n *        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}\n *      >\n *        This div is positioned at [100, 100] on the flow.\n *      </div>\n *    </ViewportPortal>\n *  );\n *}\n *```\n */ function ViewportPortal({ children }) {\n    const viewPortalDiv = useStore(selector$5);\n    if (!viewPortalDiv) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, viewPortalDiv);\n}\n/**\n * When you programmatically add or remove handles to a node or update a node's\n * handle position, you need to let React Flow know about it using this hook. This\n * will update the internal dimensions of the node and properly reposition handles\n * on the canvas if necessary.\n *\n * @public\n * @returns Use this function to tell React Flow to update the internal state of one or more nodes\n * that you have changed programmatically.\n *\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { Handle, useUpdateNodeInternals } from '@xyflow/react';\n *\n *export default function RandomHandleNode({ id }) {\n *  const updateNodeInternals = useUpdateNodeInternals();\n *  const [handleCount, setHandleCount] = useState(0);\n *  const randomizeHandleCount = useCallback(() => {\n *   setHandleCount(Math.floor(Math.random() * 10));\n *    updateNodeInternals(id);\n *  }, [id, updateNodeInternals]);\n *\n *  return (\n *    <>\n *      {Array.from({ length: handleCount }).map((_, index) => (\n *        <Handle\n *          key={index}\n *          type=\"target\"\n *          position=\"left\"\n *          id={`handle-${index}`}\n *        />\n *      ))}\n *\n *      <div>\n *        <button onClick={randomizeHandleCount}>Randomize handle count</button>\n *        <p>There are {handleCount} handles on this node.</p>\n *      </div>\n *    </>\n *  );\n *}\n *```\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((id)=>{\n        const { domNode, updateNodeInternals } = store.getState();\n        const updateIds = Array.isArray(id) ? id : [\n            id\n        ];\n        const updates = new Map();\n        updateIds.forEach((updateId)=>{\n            const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n            if (nodeElement) {\n                updates.set(updateId, {\n                    id: updateId,\n                    nodeElement,\n                    force: true\n                });\n            }\n        });\n        requestAnimationFrame(()=>updateNodeInternals(updates, {\n                triggerFitView: false\n            }));\n    }, []);\n}\nconst nodesSelector = (state)=>state.nodes;\n/**\n * This hook returns an array of the current nodes. Components that use this hook\n * will re-render **whenever any node changes**, including when a node is selected\n * or moved.\n *\n * @public\n * @returns An array of all nodes currently in the flow.\n *\n * @example\n * ```jsx\n *import { useNodes } from '@xyflow/react';\n *\n *export default function() {\n *  const nodes = useNodes();\n *\n *  return <div>There are currently {nodes.length} nodes!</div>;\n *}\n *```\n */ function useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\n/**\n * This hook returns an array of the current edges. Components that use this hook\n * will re-render **whenever any edge changes**.\n *\n * @public\n * @returns An array of all edges currently in the flow.\n *\n * @example\n * ```tsx\n *import { useEdges } from '@xyflow/react';\n *\n *export default function () {\n *  const edges = useEdges();\n *\n *  return <div>There are currently {edges.length} edges!</div>;\n *}\n *```\n */ function useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\n/**\n * The `useViewport` hook is a convenient way to read the current state of the\n * {@link Viewport} in a component. Components that use this hook\n * will re-render **whenever the viewport changes**.\n *\n * @public\n * @returns The current viewport.\n *\n * @example\n *\n *```jsx\n *import { useViewport } from '@xyflow/react';\n *\n *export default function ViewportDisplay() {\n *  const { x, y, zoom } = useViewport();\n *\n *  return (\n *    <div>\n *      <p>\n *        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.\n *      </p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return viewport;\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `nodes`: The current array of nodes. You might pass this directly to the `nodes` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n * - `setNodes`: A function that you can use to update the nodes. You can pass it a new array of\n * nodes or a callback that receives the current array of nodes and returns a new array of nodes.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n * - `onNodesChange`: A handy callback that can take an array of `NodeChanges` and update the nodes\n * state accordingly. You'll typically pass this directly to the `onNodesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useNodesState(initialNodes) {\n    const [nodes, setNodes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialNodes);\n    const onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((changes)=>setNodes((nds)=>applyNodeChanges(changes, nds)), []);\n    return [\n        nodes,\n        setNodes,\n        onNodesChange\n    ];\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `edges`: The current array of edges. You might pass this directly to the `edges` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n *\n * - `setEdges`: A function that you can use to update the edges. You can pass it a new array of\n * edges or a callback that receives the current array of edges and returns a new array of edges.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n *\n * - `onEdgesChange`: A handy callback that can take an array of `EdgeChanges` and update the edges\n * state accordingly. You'll typically pass this directly to the `onEdgesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useEdgesState(initialEdges) {\n    const [edges, setEdges] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialEdges);\n    const onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((changes)=>setEdges((eds)=>applyEdgeChanges(changes, eds)), []);\n    return [\n        edges,\n        setEdges,\n        onEdgesChange\n    ];\n}\n/**\n * The `useOnViewportChange` hook lets you listen for changes to the viewport such\n * as panning and zooming. You can provide a callback for each phase of a viewport\n * change: `onStart`, `onChange`, and `onEnd`.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback } from 'react';\n *import { useOnViewportChange } from '@xyflow/react';\n *\n *function ViewportChangeLogger() {\n *  useOnViewportChange({\n *    onStart: (viewport: Viewport) => console.log('start', viewport),\n *    onChange: (viewport: Viewport) => console.log('change', viewport),\n *    onEnd: (viewport: Viewport) => console.log('end', viewport),\n *  });\n *\n *  return null;\n *}\n *```\n */ function useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            onViewportChangeStart: onStart\n        });\n    }, [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            onViewportChange: onChange\n        });\n    }, [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            onViewportChangeEnd: onEnd\n        });\n    }, [\n        onEnd\n    ]);\n}\n/**\n * This hook lets you listen for changes to both node and edge selection. As the\n *name implies, the callback you provide will be called whenever the selection of\n *_either_ nodes or edges changes.\n *\n * @public\n * @example\n * ```jsx\n *import { useState } from 'react';\n *import { ReactFlow, useOnSelectionChange } from '@xyflow/react';\n *\n *function SelectionDisplay() {\n *  const [selectedNodes, setSelectedNodes] = useState([]);\n *  const [selectedEdges, setSelectedEdges] = useState([]);\n *\n *  // the passed handler has to be memoized, otherwise the hook will not work correctly\n *  const onChange = useCallback(({ nodes, edges }) => {\n *    setSelectedNodes(nodes.map((node) => node.id));\n *    setSelectedEdges(edges.map((edge) => edge.id));\n *  }, []);\n *\n *  useOnSelectionChange({\n *    onChange,\n *  });\n *\n *  return (\n *    <div>\n *      <p>Selected nodes: {selectedNodes.join(', ')}</p>\n *      <p>Selected edges: {selectedEdges.join(', ')}</p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks You need to memoize the passed `onChange` handler, otherwise the hook will not work correctly.\n */ function useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const nextOnSelectionChangeHandlers = [\n            ...store.getState().onSelectionChangeHandlers,\n            onChange\n        ];\n        store.setState({\n            onSelectionChangeHandlers: nextOnSelectionChangeHandlers\n        });\n        return ()=>{\n            const nextHandlers = store.getState().onSelectionChangeHandlers.filter((fn)=>fn !== onChange);\n            store.setState({\n                onSelectionChangeHandlers: nextHandlers\n            });\n        };\n    }, [\n        onChange\n    ]);\n}\nconst selector$4 = (options)=>(s)=>{\n        if (!options.includeHiddenNodes) {\n            return s.nodesInitialized;\n        }\n        if (s.nodeLookup.size === 0) {\n            return false;\n        }\n        for (const [, { internals }] of s.nodeLookup){\n            if (internals.handleBounds === undefined || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(internals.userNode)) {\n                return false;\n            }\n        }\n        return true;\n    };\n/**\n * This hook tells you whether all the nodes in a flow have been measured and given\n *a width and height. When you add a node to the flow, this hook will return\n *`false` and then `true` again once the node has been measured.\n *\n * @public\n * @returns Whether or not the nodes have been initialized by the `<ReactFlow />` component and\n * given a width and height.\n *\n * @example\n * ```jsx\n *import { useReactFlow, useNodesInitialized } from '@xyflow/react';\n *import { useEffect, useState } from 'react';\n *\n *const options = {\n *  includeHiddenNodes: false,\n *};\n *\n *export default function useLayout() {\n *  const { getNodes } = useReactFlow();\n *  const nodesInitialized = useNodesInitialized(options);\n *  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());\n *\n *  useEffect(() => {\n *    if (nodesInitialized) {\n *      setLayoutedNodes(yourLayoutingFunction(getNodes()));\n *    }\n *  }, [nodesInitialized]);\n *\n *  return layoutedNodes;\n *}\n *```\n */ function useNodesInitialized(options = {\n    includeHiddenNodes: false\n}) {\n    const initialized = useStore(selector$4(options));\n    return initialized;\n}\n/**\n * Hook to check if a <Handle /> is connected to another <Handle /> and get the connections.\n *\n * @public\n * @deprecated Use `useNodeConnections` instead.\n * @returns An array with handle connections.\n */ function useHandleConnections({ type, id, nodeId, onConnect, onDisconnect }) {\n    console.warn(\"[DEPRECATED] `useHandleConnections` is deprecated. Instead use `useNodeConnections` https://reactflow.dev/api-reference/hooks/useNodeConnections\");\n    const _nodeId = useNodeId();\n    const currentNodeId = nodeId ?? _nodeId;\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore((state)=>state.connectionLookup.get(`${currentNodeId}-${type}${id ? `-${id}` : \"\"}`), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n        if (prevConnections.current && prevConnections.current !== connections) {\n            const _connections = connections ?? new Map();\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n        }\n        prevConnections.current = connections ?? new Map();\n    }, [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>Array.from(connections?.values() ?? []), [\n        connections\n    ]);\n}\nconst error014 = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error014\"]();\n/**\n * This hook returns an array of connections on a specific node, handle type ('source', 'target') or handle ID.\n *\n * @public\n * @returns An array with connections.\n *\n * @example\n * ```jsx\n *import { useNodeConnections } from '@xyflow/react';\n *\n *export default function () {\n *  const connections = useNodeConnections({\n *    handleType: 'target',\n *    handleId: 'my-handle',\n *  });\n *\n *  return (\n *    <div>There are currently {connections.length} incoming connections!</div>\n *  );\n *}\n *```\n */ function useNodeConnections({ id, handleType, handleId, onConnect, onDisconnect } = {}) {\n    const nodeId = useNodeId();\n    const currentNodeId = id ?? nodeId;\n    if (!currentNodeId) {\n        throw new Error(error014);\n    }\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore((state)=>state.connectionLookup.get(`${currentNodeId}${handleType ? handleId ? `-${handleType}-${handleId}` : `-${handleType}` : \"\"}`), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // @todo discuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n        if (prevConnections.current && prevConnections.current !== connections) {\n            const _connections = connections ?? new Map();\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n        }\n        prevConnections.current = connections ?? new Map();\n    }, [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>Array.from(connections?.values() ?? []), [\n        connections\n    ]);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodesData(nodeIds) {\n    const nodesData = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((s)=>{\n        const data = [];\n        const isArrayOfIds = Array.isArray(nodeIds);\n        const _nodeIds = isArrayOfIds ? nodeIds : [\n            nodeIds\n        ];\n        for (const nodeId of _nodeIds){\n            const node = s.nodeLookup.get(nodeId);\n            if (node) {\n                data.push({\n                    id: node.id,\n                    type: node.type,\n                    data: node.data\n                });\n            }\n        }\n        return isArrayOfIds ? data : data[0] ?? null;\n    }, [\n        nodeIds\n    ]), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.shallowNodeData);\n    return nodesData;\n}\n/**\n * This hook returns the internal representation of a specific node.\n * Components that use this hook will re-render **whenever the node changes**,\n * including when a node is selected or moved.\n *\n * @public\n * @param id - The ID of a node you want to observe.\n * @returns The `InternalNode` object for the node with the given ID.\n *\n * @example\n * ```tsx\n *import { useInternalNode } from '@xyflow/react';\n *\n *export default function () {\n *  const internalNode = useInternalNode('node-1');\n *  const absolutePosition = internalNode.internals.positionAbsolute;\n *\n *  return (\n *    <div>\n *      The absolute position of the node is at:\n *      <p>x: {absolutePosition.x}</p>\n *      <p>y: {absolutePosition.y}</p>\n *    </div>\n *  );\n *}\n *```\n */ function useInternalNode(id) {\n    const node = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((s)=>s.nodeLookup.get(id), [\n        id\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return node;\n}\nfunction LinePattern({ dimensions, lineWidth, variant, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__background-pattern\",\n            variant,\n            className\n        ])\n    });\n}\nfunction DotPattern({ radius, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__background-pattern\",\n            \"dots\",\n            className\n        ])\n    });\n}\n/**\n * The three variants are exported as an enum for convenience. You can either import\n * the enum and use it like `BackgroundVariant.Lines` or you can use the raw string\n * value directly.\n * @public\n */ var BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector$3 = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction BackgroundComponent({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 0, color, bgColor, style, className, patternClassName }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { transform, patternId } = useStore(selector$3, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const offsetXY = Array.isArray(offset) ? offset : [\n        offset,\n        offset\n    ];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const scaledOffset = [\n        offsetXY[0] * transform[2] || 1 + patternDimensions[0] / 2,\n        offsetXY[1] * transform[2] || 1 + patternDimensions[1] / 2\n    ];\n    const _patternId = `${patternId}${id ? id : \"\"}`;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__background\",\n            className\n        ]),\n        style: {\n            ...style,\n            ...containerStyle,\n            \"--xy-background-color-props\": bgColor,\n            \"--xy-background-pattern-color-props\": color\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pattern\", {\n                id: _patternId,\n                x: transform[0] % scaledGap[0],\n                y: transform[1] % scaledGap[1],\n                width: scaledGap[0],\n                height: scaledGap[1],\n                patternUnits: \"userSpaceOnUse\",\n                patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`,\n                children: isDots ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DotPattern, {\n                    radius: scaledSize / 2,\n                    className: patternClassName\n                }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinePattern, {\n                    dimensions: patternDimensions,\n                    lineWidth: lineWidth,\n                    variant: variant,\n                    className: patternClassName\n                })\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"0\",\n                y: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                fill: `url(#${_patternId})`\n            })\n        ]\n    });\n}\nBackgroundComponent.displayName = \"Background\";\n/**\n * The `<Background />` component makes it convenient to render different types of backgrounds common in node-based UIs. It comes with three variants: lines, dots and cross.\n *\n * @example\n *\n * A simple example of how to use the Background component.\n *\n * ```tsx\n * import { useState } from 'react';\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background color=\"#ccc\" variant={BackgroundVariant.Dots} />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @example\n *\n * In this example you can see how to combine multiple backgrounds\n *\n * ```tsx\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n * import '@xyflow/react/dist/style.css';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background\n *         id=\"1\"\n *         gap={10}\n *         color=\"#f1f1f1\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *       <Background\n *         id=\"2\"\n *         gap={100}\n *         color=\"#ccc\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @remarks\n *\n * When combining multiple <Background /> components its important to give each of them a unique id prop!\n *\n */ const Background = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(BackgroundComponent);\nfunction PlusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n        })\n    });\n}\nfunction MinusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M0 0h32v4.2H0z\"\n        })\n    });\n}\nfunction FitViewIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n        })\n    });\n}\nfunction LockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n        })\n    });\n}\nfunction UnlockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n        })\n    });\n}\n/**\n * You can add buttons to the control panel by using the `<ControlButton />` component\n * and pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.\n *\n * @public\n * @example\n *```jsx\n *import { MagicWand } from '@radix-ui/react-icons'\n *import { ReactFlow, Controls, ControlButton } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls>\n *        <ControlButton onClick={() => alert('Something magical just happened. ')}>\n *          <MagicWand />\n *        </ControlButton>\n *      </Controls>\n *    </ReactFlow>\n *  )\n *}\n *```\n */ function ControlButton({ children, className, ...rest }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__controls-button\",\n            className\n        ]),\n        ...rest,\n        children: children\n    });\n}\nconst selector$2 = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom,\n        ariaLabelConfig: s.ariaLabelConfig\n    });\nfunction ControlsComponent({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = \"bottom-left\", orientation = \"vertical\", \"aria-label\": ariaLabel }) {\n    const store = useStoreApi();\n    const { isInteractive, minZoomReached, maxZoomReached, ariaLabelConfig } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { zoomIn, zoomOut, fitView } = useReactFlow();\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    const orientationClass = orientation === \"horizontal\" ? \"horizontal\" : \"vertical\";\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__controls\",\n            orientationClass,\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\",\n        \"aria-label\": ariaLabel ?? ariaLabelConfig[\"controls.ariaLabel\"],\n        children: [\n            showZoom && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomInHandler,\n                        className: \"react-flow__controls-zoomin\",\n                        title: ariaLabelConfig[\"controls.zoomIn.ariaLabel\"],\n                        \"aria-label\": ariaLabelConfig[\"controls.zoomIn.ariaLabel\"],\n                        disabled: maxZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PlusIcon, {})\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomOutHandler,\n                        className: \"react-flow__controls-zoomout\",\n                        title: ariaLabelConfig[\"controls.zoomOut.ariaLabel\"],\n                        \"aria-label\": ariaLabelConfig[\"controls.zoomOut.ariaLabel\"],\n                        disabled: minZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MinusIcon, {})\n                    })\n                ]\n            }),\n            showFitView && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-fitview\",\n                onClick: onFitViewHandler,\n                title: ariaLabelConfig[\"controls.fitView.ariaLabel\"],\n                \"aria-label\": ariaLabelConfig[\"controls.fitView.ariaLabel\"],\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FitViewIcon, {})\n            }),\n            showInteractive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-interactive\",\n                onClick: onToggleInteractivity,\n                title: ariaLabelConfig[\"controls.interactive.ariaLabel\"],\n                \"aria-label\": ariaLabelConfig[\"controls.interactive.ariaLabel\"],\n                children: isInteractive ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnlockIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LockIcon, {})\n            }),\n            children\n        ]\n    });\n}\nControlsComponent.displayName = \"Controls\";\n/**\n * The `<Controls />` component renders a small panel that contains convenient\n * buttons to zoom in, zoom out, fit the view, and lock the viewport.\n *\n * @public\n * @example\n *```tsx\n *import { ReactFlow, Controls } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls />\n *    </ReactFlow>\n *  )\n *}\n *```\n *\n * @remarks To extend or customise the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button) component\n *\n */ const Controls = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ControlsComponent);\nfunction MiniMapNodeComponent({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected, onClick }) {\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__minimap-node\",\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        style: {\n            fill,\n            stroke: strokeColor,\n            strokeWidth\n        },\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n}\nconst MiniMapNode = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodeComponent);\nconst selectorNodeIds = (s)=>s.nodes.map((node)=>node.id);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor, nodeColor, nodeClassName = \"\", nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent: NodeComponent = MiniMapNode, onClick }) {\n    const nodeIds = useStore(selectorNodeIds, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? \"crispEdges\" : 0;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: nodeIds.map((nodeId)=>/*\n         * The split of responsibilities between MiniMapNodes and\n         * NodeComponentWrapper may appear weird. However, its designed to\n         * minimize the cost of updates when individual nodes change.\n         *\n         * For more details, see a similar commit in `NodeRenderer/index.tsx`.\n         */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponentWrapper, {\n                id: nodeId,\n                nodeColorFunc: nodeColorFunc,\n                nodeStrokeColorFunc: nodeStrokeColorFunc,\n                nodeClassNameFunc: nodeClassNameFunc,\n                nodeBorderRadius: nodeBorderRadius,\n                nodeStrokeWidth: nodeStrokeWidth,\n                NodeComponent: NodeComponent,\n                onClick: onClick,\n                shapeRendering: shapeRendering\n            }, nodeId))\n    });\n}\nfunction NodeComponentWrapperInner({ id, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {\n    const { node, x, y, width, height } = useStore((s)=>{\n        const { internals } = s.nodeLookup.get(id);\n        const node = internals.userNode;\n        const { x, y } = internals.positionAbsolute;\n        const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n        return {\n            node,\n            x,\n            y,\n            width,\n            height\n        };\n    }, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!node || node.hidden || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node)) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        style: node.style,\n        selected: !!node.selected,\n        className: nodeClassNameFunc(node),\n        color: nodeColorFunc(node),\n        borderRadius: nodeBorderRadius,\n        strokeColor: nodeStrokeColorFunc(node),\n        strokeWidth: nodeStrokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick,\n        id: node.id\n    });\n}\nconst NodeComponentWrapper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeComponentWrapperInner);\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodes);\nconst defaultWidth = 200;\nconst defaultHeight = 150;\nconst filterHidden = (node)=>!node.hidden;\nconst selector$1 = (s)=>{\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: s.nodeLookup.size > 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBoundsOfRects)((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n            filter: filterHidden\n        }), viewBB) : viewBB,\n        rfId: s.rfId,\n        panZoom: s.panZoom,\n        translateExtent: s.translateExtent,\n        flowWidth: s.width,\n        flowHeight: s.height,\n        ariaLabelConfig: s.ariaLabelConfig\n    };\n};\nconst ARIA_LABEL_KEY = \"react-flow__minimap-desc\";\nfunction MiniMapComponent({ style, className, nodeStrokeColor, nodeColor, nodeClassName = \"\", nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent, bgColor, maskColor, maskStrokeColor, maskStrokeWidth, position = \"bottom-right\", onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel, inversePan, zoomStep = 1, offsetScale = 5 }) {\n    const store = useStoreApi();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight, ariaLabelConfig } = useStore(selector$1, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const minimapInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (svg.current && panZoom) {\n            minimapInstance.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYMinimap)({\n                domNode: svg.current,\n                panZoom,\n                getTransform: ()=>store.getState().transform,\n                getViewScale: ()=>viewScaleRef.current\n            });\n            return ()=>{\n                minimapInstance.current?.destroy();\n            };\n        }\n    }, [\n        panZoom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        minimapInstance.current?.update({\n            translateExtent,\n            width: flowWidth,\n            height: flowHeight,\n            inversePan,\n            pannable,\n            zoomStep,\n            zoomable\n        });\n    }, [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep,\n        translateExtent,\n        flowWidth,\n        flowHeight\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const [x, y] = minimapInstance.current?.pointer(event) || [\n            0,\n            0\n        ];\n        onClick(event, {\n            x,\n            y\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event, nodeId)=>{\n        const node = store.getState().nodeLookup.get(nodeId).internals.userNode;\n        onNodeClick(event, node);\n    }, []) : undefined;\n    const _ariaLabel = ariaLabel ?? ariaLabelConfig[\"minimap.ariaLabel\"];\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        style: {\n            ...style,\n            \"--xy-minimap-background-color-props\": typeof bgColor === \"string\" ? bgColor : undefined,\n            \"--xy-minimap-mask-background-color-props\": typeof maskColor === \"string\" ? maskColor : undefined,\n            \"--xy-minimap-mask-stroke-color-props\": typeof maskStrokeColor === \"string\" ? maskStrokeColor : undefined,\n            \"--xy-minimap-mask-stroke-width-props\": typeof maskStrokeWidth === \"number\" ? maskStrokeWidth * viewScale : undefined,\n            \"--xy-minimap-node-background-color-props\": typeof nodeColor === \"string\" ? nodeColor : undefined,\n            \"--xy-minimap-node-stroke-color-props\": typeof nodeStrokeColor === \"string\" ? nodeStrokeColor : undefined,\n            \"--xy-minimap-node-stroke-width-props\": typeof nodeStrokeWidth === \"number\" ? nodeStrokeWidth : undefined\n        },\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__minimap\",\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n            width: elementWidth,\n            height: elementHeight,\n            viewBox: `${x} ${y} ${width} ${height}`,\n            className: \"react-flow__minimap-svg\",\n            role: \"img\",\n            \"aria-labelledby\": labelledBy,\n            ref: svg,\n            onClick: onSvgClick,\n            children: [\n                _ariaLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"title\", {\n                    id: labelledBy,\n                    children: _ariaLabel\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MiniMapNodes$1, {\n                    onClick: onSvgNodeClick,\n                    nodeColor: nodeColor,\n                    nodeStrokeColor: nodeStrokeColor,\n                    nodeBorderRadius: nodeBorderRadius,\n                    nodeClassName: nodeClassName,\n                    nodeStrokeWidth: nodeStrokeWidth,\n                    nodeComponent: nodeComponent\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    className: \"react-flow__minimap-mask\",\n                    d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n                    fillRule: \"evenodd\",\n                    pointerEvents: \"none\"\n                })\n            ]\n        })\n    });\n}\nMiniMapComponent.displayName = \"MiniMap\";\n/**\n * The `<MiniMap />` component can be used to render an overview of your flow. It\n * renders each node as an SVG element and visualizes where the current viewport is\n * in relation to the rest of the flow.\n *\n * @public\n * @example\n *\n * ```jsx\n *import { ReactFlow, MiniMap } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]]} edges={[...]]}>\n *      <MiniMap nodeStrokeWidth={3} />\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const MiniMap = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapComponent);\nconst scaleSelector = (calculateScale)=>(store)=>calculateScale ? `${Math.max(1 / store.transform[2], 1)}` : undefined;\nconst defaultPositions = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line]: \"right\",\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle]: \"bottom-right\"\n};\nfunction ResizeControl({ nodeId, position, variant = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle, className, style = undefined, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, resizeDirection, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === \"string\" ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isHandleControl = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle;\n    const scale = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(scaleSelector(isHandleControl && autoScale), [\n        isHandleControl,\n        autoScale\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const resizer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const controlPosition = position ?? defaultPositions[variant];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!resizeControlRef.current || !id) {\n            return;\n        }\n        if (!resizer.current) {\n            resizer.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYResizer)({\n                domNode: resizeControlRef.current,\n                nodeId: id,\n                getStoreItems: ()=>{\n                    const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();\n                    return {\n                        nodeLookup,\n                        transform,\n                        snapGrid,\n                        snapToGrid,\n                        nodeOrigin,\n                        paneDomNode: domNode\n                    };\n                },\n                onChange: (change, childChanges)=>{\n                    const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState();\n                    const changes = [];\n                    const nextPosition = {\n                        x: change.x,\n                        y: change.y\n                    };\n                    const node = nodeLookup.get(id);\n                    if (node && node.expandParent && node.parentId) {\n                        const origin = node.origin ?? nodeOrigin;\n                        const width = change.width ?? node.measured.width ?? 0;\n                        const height = change.height ?? node.measured.height ?? 0;\n                        const child = {\n                            id: node.id,\n                            parentId: node.parentId,\n                            rect: {\n                                width,\n                                height,\n                                ...(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)({\n                                    x: change.x ?? node.position.x,\n                                    y: change.y ?? node.position.y\n                                }, {\n                                    width,\n                                    height\n                                }, node.parentId, nodeLookup, origin)\n                            }\n                        };\n                        const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)([\n                            child\n                        ], nodeLookup, parentLookup, nodeOrigin);\n                        changes.push(...parentExpandChanges);\n                        /*\n                         * when the parent was expanded by the child node, its position will be clamped at\n                         * 0,0 when node origin is 0,0 and to width, height if it's 1,1\n                         */ nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : undefined;\n                        nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : undefined;\n                    }\n                    if (nextPosition.x !== undefined && nextPosition.y !== undefined) {\n                        const positionChange = {\n                            id,\n                            type: \"position\",\n                            position: {\n                                ...nextPosition\n                            }\n                        };\n                        changes.push(positionChange);\n                    }\n                    if (change.width !== undefined && change.height !== undefined) {\n                        const setAttributes = !resizeDirection ? true : resizeDirection === \"horizontal\" ? \"width\" : \"height\";\n                        const dimensionChange = {\n                            id,\n                            type: \"dimensions\",\n                            resizing: true,\n                            setAttributes,\n                            dimensions: {\n                                width: change.width,\n                                height: change.height\n                            }\n                        };\n                        changes.push(dimensionChange);\n                    }\n                    for (const childChange of childChanges){\n                        const positionChange = {\n                            ...childChange,\n                            type: \"position\"\n                        };\n                        changes.push(positionChange);\n                    }\n                    triggerNodeChanges(changes);\n                },\n                onEnd: ({ width, height })=>{\n                    const dimensionChange = {\n                        id: id,\n                        type: \"dimensions\",\n                        resizing: false,\n                        dimensions: {\n                            width,\n                            height\n                        }\n                    };\n                    store.getState().triggerNodeChanges([\n                        dimensionChange\n                    ]);\n                }\n            });\n        }\n        resizer.current.update({\n            controlPosition,\n            boundaries: {\n                minWidth,\n                minHeight,\n                maxWidth,\n                maxHeight\n            },\n            keepAspectRatio,\n            resizeDirection,\n            onResizeStart,\n            onResize,\n            onResizeEnd,\n            shouldResize\n        });\n        return ()=>{\n            resizer.current?.destroy();\n        };\n    }, [\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n        shouldResize\n    ]);\n    const positionClassNames = controlPosition.split(\"-\");\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__resize-control\",\n            \"nodrag\",\n            ...positionClassNames,\n            variant,\n            className\n        ]),\n        ref: resizeControlRef,\n        style: {\n            ...style,\n            scale,\n            ...color && {\n                [isHandleControl ? \"backgroundColor\" : \"borderColor\"]: color\n            }\n        },\n        children: children\n    });\n}\n/**\n * To create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).\n * @public\n *\n */ const NodeResizeControl = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ResizeControl);\n/**\n * The `<NodeResizer />` component can be used to add a resize functionality to your\n * nodes. It renders draggable controls around the node to resize in all directions.\n * @public\n *\n * @example\n *```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeResizer } from '@xyflow/react';\n *\n *function ResizableNode({ data }) {\n *  return (\n *    <>\n *      <NodeResizer minWidth={100} minHeight={30} />\n *      <Handle type=\"target\" position={Position.Left} />\n *      <div style={{ padding: 10 }}>{data.label}</div>\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(ResizableNode);\n *```\n */ function NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_LINE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: lineClassName,\n                    style: lineStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    variant: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position)),\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_HANDLE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: handleClassName,\n                    style: handleStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position))\n        ]\n    });\n}\nconst selector = (state)=>state.domNode?.querySelector(\".react-flow__renderer\");\nfunction NodeToolbarPortal({ children }) {\n    const wrapperRef = useStore(selector);\n    if (!wrapperRef) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, wrapperRef);\n}\nconst nodeEqualityFn = (a, b)=>a?.internals.positionAbsolute.x !== b?.internals.positionAbsolute.x || a?.internals.positionAbsolute.y !== b?.internals.positionAbsolute.y || a?.measured.width !== b?.measured.width || a?.measured.height !== b?.measured.height || a?.selected !== b?.selected || a?.internals.z !== b?.internals.z;\nconst nodesEqualityFn = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, node] of a){\n        if (nodeEqualityFn(node, b.get(key))) {\n            return false;\n        }\n    }\n    return true;\n};\nconst storeSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2],\n        selectedNodesCount: state.nodes.filter((node)=>node.selected).length\n    });\n/**\n * This component can render a toolbar or tooltip to one side of a custom node. This\n * toolbar doesn't scale with the viewport so that the content is always visible.\n *\n * @public\n * @example\n * ```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeToolbar } from '@xyflow/react';\n *\n *function CustomNode({ data }) {\n *  return (\n *    <>\n *      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>\n *        <button>delete</button>\n *        <button>copy</button>\n *        <button>expand</button>\n *      </NodeToolbar>\n *\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(CustomNode);\n *```\n * @remarks By default, the toolbar is only visible when a node is selected. If multiple\n * nodes are selected it will not be visible to prevent overlapping toolbars or\n * clutter. You can override this behavior by setting the `isVisible` prop to `true`.\n */ function NodeToolbar({ nodeId, children, className, style, isVisible, position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, offset = 10, align = \"center\", ...rest }) {\n    const contextNodeId = useNodeId();\n    const nodesSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((state)=>{\n        const nodeIds = Array.isArray(nodeId) ? nodeId : [\n            nodeId || contextNodeId || \"\"\n        ];\n        const internalNodes = nodeIds.reduce((res, id)=>{\n            const node = state.nodeLookup.get(id);\n            if (node) {\n                res.set(node.id, node);\n            }\n            return res;\n        }, new Map());\n        return internalNodes;\n    }, [\n        nodeId,\n        contextNodeId\n    ]);\n    const nodes = useStore(nodesSelector, nodesEqualityFn);\n    const { x, y, zoom, selectedNodesCount } = useStore(storeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    // if isVisible is not set, we show the toolbar only if its node is selected and no other node is selected\n    const isActive = typeof isVisible === \"boolean\" ? isVisible : nodes.size === 1 && nodes.values().next().value?.selected && selectedNodesCount === 1;\n    if (!isActive || !nodes.size) {\n        return null;\n    }\n    const nodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodes);\n    const nodesArray = Array.from(nodes.values());\n    const zIndex = Math.max(...nodesArray.map((node)=>node.internals.z + 1));\n    const wrapperStyle = {\n        position: \"absolute\",\n        transform: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeToolbarTransform)(nodeRect, {\n            x,\n            y,\n            zoom\n        }, position, offset, align),\n        zIndex,\n        ...style\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeToolbarPortal, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: wrapperStyle,\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__node-toolbar\",\n                className\n            ]),\n            ...rest,\n            \"data-id\": nodesArray.reduce((acc, node)=>`${acc}${node.id} `, \"\").trim(),\n            children: children\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZzhCQUN3RDtBQUNnRjtBQUM5RztBQUNrc0M7QUFDMTRCO0FBQy9QO0FBQ3pDO0FBQ0Q7QUFFekMsTUFBTTZGLDZCQUFlMUYsb0RBQWFBLENBQUM7QUFDbkMsTUFBTTJGLGFBQWFELGFBQWFFLFFBQVE7QUFFeEMsTUFBTUMsc0JBQXNCbEYseURBQWEsQ0FBQyxXQUFXO0FBQ3JEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsU0FBU21GLFNBQVNDLFFBQVEsRUFBRUMsVUFBVTtJQUNsQyxNQUFNQyxRQUFRaEcsaURBQVVBLENBQUN5RjtJQUN6QixJQUFJTyxVQUFVLE1BQU07UUFDaEIsTUFBTSxJQUFJQyxNQUFNTDtJQUNwQjtJQUNBLE9BQU9QLDJFQUFzQkEsQ0FBQ1csT0FBT0YsVUFBVUM7QUFDbkQ7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTRztJQUNMLE1BQU1GLFFBQVFoRyxpREFBVUEsQ0FBQ3lGO0lBQ3pCLElBQUlPLFVBQVUsTUFBTTtRQUNoQixNQUFNLElBQUlDLE1BQU1MO0lBQ3BCO0lBQ0EsT0FBTzNGLDhDQUFPQSxDQUFDLElBQU87WUFDbEJrRyxVQUFVSCxNQUFNRyxRQUFRO1lBQ3hCQyxVQUFVSixNQUFNSSxRQUFRO1lBQ3hCQyxXQUFXTCxNQUFNSyxTQUFTO1FBQzlCLElBQUk7UUFBQ0w7S0FBTTtBQUNmO0FBRUEsTUFBTU0sUUFBUTtJQUFFQyxTQUFTO0FBQU87QUFDaEMsTUFBTUMsZ0JBQWdCO0lBQ2xCQyxVQUFVO0lBQ1ZDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxRQUFRLENBQUM7SUFDVEMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLFVBQVU7SUFDVkMsTUFBTTtJ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a25CLENBQUMsR0FBRztJQUN2RSxNQUFNOFIsZUFBZTtRQUNqQjM3QixVQUFVO1FBQ1ZtTCxXQUFXN00sdUVBQXVCQSxDQUFDNlYsVUFBVTtZQUFFalE7WUFBR0M7WUFBR0M7UUFBSyxHQUFHcEUsVUFBVXl3QixRQUFRZ1o7UUFDL0U3ZjtRQUNBLEdBQUcvcEIsS0FBSztJQUNaO0lBQ0EsT0FBUXhHLHNEQUFHQSxDQUFDNnZDLG1CQUFtQjtRQUFFOW5DLFVBQVUvSCxzREFBR0EsQ0FBQyxPQUFPO1lBQUV3RyxPQUFPODdCO1lBQWNuNkIsV0FBV3hILG9EQUFFQSxDQUFDO2dCQUFDO2dCQUE0QndIO2FBQVU7WUFBRyxHQUFHQyxJQUFJO1lBQUUsV0FBV2tvQyxXQUFXdGhDLE1BQU0sQ0FBQyxDQUFDdWhDLEtBQUtybkMsT0FBUyxDQUFDLEVBQUVxbkMsSUFBSSxFQUFFcm5DLEtBQUtwQixFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSTBvQyxJQUFJO1lBQUl6b0MsVUFBVUE7UUFBUztJQUFHO0FBQ3JQO0FBRTZxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xheS1pdC1yaWdodC8uL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L2Rpc3QvZXNtL2luZGV4LmpzP2ZhM2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcbmltcG9ydCB7IGpzeHMsIEZyYWdtZW50LCBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCBmb3J3YXJkUmVmLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUxheW91dEVmZmVjdCwgdXNlQ2FsbGJhY2ssIG1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2MgZnJvbSAnY2xhc3NjYXQnO1xuaW1wb3J0IHsgZXJyb3JNZXNzYWdlcywgbWVyZ2VBcmlhTGFiZWxDb25maWcsIGluZmluaXRlRXh0ZW50LCBpc0lucHV0RE9NTm9kZSwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHBvaW50VG9SZW5kZXJlclBvaW50LCByZW5kZXJlclBvaW50VG9Qb2ludCwgaXNOb2RlQmFzZSwgaXNFZGdlQmFzZSwgZ2V0RWxlbWVudHNUb1JlbW92ZSwgaXNSZWN0T2JqZWN0LCBub2RlVG9SZWN0LCBnZXRPdmVybGFwcGluZ0FyZWEsIGdldE5vZGVzQm91bmRzLCB3aXRoUmVzb2x2ZXJzLCBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24sIGdldERpbWVuc2lvbnMsIFhZUGFuWm9vbSwgUGFuT25TY3JvbGxNb2RlLCBTZWxlY3Rpb25Nb2RlLCBnZXRFdmVudFBvc2l0aW9uLCBnZXROb2Rlc0luc2lkZSwgYXJlU2V0c0VxdWFsLCBYWURyYWcsIHNuYXBQb3NpdGlvbiwgY2FsY3VsYXRlTm9kZVBvc2l0aW9uLCBQb3NpdGlvbiwgQ29ubmVjdGlvbk1vZGUsIGlzTW91c2VFdmVudCwgWFlIYW5kbGUsIGdldEhvc3RGb3JFbGVtZW50LCBhZGRFZGdlLCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzLCBpc051bWVyaWMsIG5vZGVIYXNEaW1lbnNpb25zLCBnZXROb2RlRGltZW5zaW9ucywgZWxlbWVudFNlbGVjdGlvbktleXMsIGlzRWRnZVZpc2libGUsIE1hcmtlclR5cGUsIGNyZWF0ZU1hcmtlcklkcywgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0QmV6aWVyUGF0aCwgZ2V0RWRnZVBvc2l0aW9uLCBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgsIGdldE1hcmtlcklkLCBnZXRDb25uZWN0aW9uU3RhdHVzLCBDb25uZWN0aW9uTGluZVR5cGUsIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAsIGFkb3B0VXNlck5vZGVzLCBpbml0aWFsQ29ubmVjdGlvbiwgZGV2V2FybiwgZGVmYXVsdEFyaWFMYWJlbENvbmZpZywgdXBkYXRlTm9kZUludGVybmFscywgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMsIGhhbmRsZUV4cGFuZFBhcmVudCwgcGFuQnksIGZpdFZpZXdwb3J0LCBpc01hY09zLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsLCBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlLCBzaGFsbG93Tm9kZURhdGEsIFhZTWluaW1hcCwgZ2V0Qm91bmRzT2ZSZWN0cywgUmVzaXplQ29udHJvbFZhcmlhbnQsIFhZUmVzaXplciwgWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUywgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLCBnZXROb2RlVG9vbGJhclRyYW5zZm9ybSB9IGZyb20gJ0B4eWZsb3cvc3lzdGVtJztcbmV4cG9ydCB7IENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUG9zaXRpb24sIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBTZWxlY3Rpb25Nb2RlLCBhZGRFZGdlLCBnZXRCZXppZXJFZGdlQ2VudGVyLCBnZXRCZXppZXJQYXRoLCBnZXRDb25uZWN0ZWRFZGdlcywgZ2V0RWRnZUNlbnRlciwgZ2V0SW5jb21lcnMsIGdldE5vZGVzQm91bmRzLCBnZXRPdXRnb2VycywgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHJlY29ubmVjdEVkZ2UgfSBmcm9tICdAeHlmbG93L3N5c3RlbSc7XG5pbXBvcnQgeyB1c2VTdG9yZVdpdGhFcXVhbGl0eUZuLCBjcmVhdGVXaXRoRXF1YWxpdHlGbiB9IGZyb20gJ3p1c3RhbmQvdHJhZGl0aW9uYWwnO1xuaW1wb3J0IHsgc2hhbGxvdyB9IGZyb20gJ3p1c3RhbmQvc2hhbGxvdyc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5jb25zdCBTdG9yZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgUHJvdmlkZXIkMSA9IFN0b3JlQ29udGV4dC5Qcm92aWRlcjtcblxuY29uc3QgenVzdGFuZEVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAxJ10oKTtcbi8qKlxuICogVGhpcyBob29rIGNhbiBiZSB1c2VkIHRvIHN1YnNjcmliZSB0byBpbnRlcm5hbCBzdGF0ZSBjaGFuZ2VzIG9mIHRoZSBSZWFjdCBGbG93XG4gKiBjb21wb25lbnQuIFRoZSBgdXNlU3RvcmVgIGhvb2sgaXMgcmUtZXhwb3J0ZWQgZnJvbSB0aGUgW1p1c3RhbmRdKGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvenVzdGFuZClcbiAqIHN0YXRlIG1hbmFnZW1lbnQgbGlicmFyeSwgc28geW91IHNob3VsZCBjaGVjayBvdXQgdGhlaXIgZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBzZWxlY3RvciAtIEEgc2VsZWN0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2xpY2Ugb2YgdGhlIGZsb3cncyBpbnRlcm5hbCBzdGF0ZS5cbiAqIEV4dHJhY3Rpbmcgb3IgdHJhbnNmb3JtaW5nIGp1c3QgdGhlIHN0YXRlIHlvdSBuZWVkIGlzIGEgZ29vZCBwcmFjdGljZSB0byBhdm9pZCB1bm5lY2Vzc2FyeVxuICogcmUtcmVuZGVycy5cbiAqIEBwYXJhbSBlcXVhbGl0eUZuIC0gQSBmdW5jdGlvbiB0byBjb21wYXJlIHRoZSBwcmV2aW91cyBhbmQgbmV4dCB2YWx1ZS4gVGhpcyBpcyBpbmNyZWRpYmx5IHVzZWZ1bFxuICogZm9yIHByZXZlbnRpbmcgdW5uZWNlc3NhcnkgcmUtcmVuZGVycy4gR29vZCBzZW5zaWJsZSBkZWZhdWx0cyBhcmUgdXNpbmcgYE9iamVjdC5pc2Agb3IgaW1wb3J0aW5nXG4gKiBgenVzdGFuZC9zaGFsbG93YCwgYnV0IHlvdSBjYW4gYmUgYXMgZ3JhbnVsYXIgYXMgeW91IGxpa2UuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0ZWQgc3RhdGUgc2xpY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBub2RlcyA9IHVzZVN0b3JlKChzdGF0ZSkgPT4gc3RhdGUubm9kZXMpO1xuICogYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgdGhlcmUgaXMgbm8gb3RoZXIgd2F5IHRvIGFjY2VzcyB0aGUgaW50ZXJuYWxcbiAqIHN0YXRlLiBGb3IgbWFueSBvZiB0aGUgY29tbW9uIHVzZSBjYXNlcywgdGhlcmUgYXJlIGRlZGljYXRlZCBob29rcyBhdmFpbGFibGVcbiAqIHN1Y2ggYXMge0BsaW5rIHVzZVJlYWN0Rmxvd30sIHtAbGluayB1c2VWaWV3cG9ydH0sIGV0Yy5cbiAqL1xuZnVuY3Rpb24gdXNlU3RvcmUoc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgICBpZiAoc3RvcmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHp1c3RhbmRFcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlU3RvcmVXaXRoRXF1YWxpdHlGbihzdG9yZSwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xufVxuLyoqXG4gKiBJbiBzb21lIGNhc2VzLCB5b3UgbWlnaHQgbmVlZCB0byBhY2Nlc3MgdGhlIHN0b3JlIGRpcmVjdGx5LiBUaGlzIGhvb2sgcmV0dXJucyB0aGUgc3RvcmUgb2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIG9uIGRlbWFuZCB0byBhY2Nlc3MgdGhlIHN0YXRlIG9yIGRpc3BhdGNoIGFjdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIHN0b3JlIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICogYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgdGhlcmUgaXMgbm8gb3RoZXIgd2F5IHRvIGFjY2VzcyB0aGUgaW50ZXJuYWxcbiAqIHN0YXRlLiBGb3IgbWFueSBvZiB0aGUgY29tbW9uIHVzZSBjYXNlcywgdGhlcmUgYXJlIGRlZGljYXRlZCBob29rcyBhdmFpbGFibGVcbiAqIHN1Y2ggYXMge0BsaW5rIHVzZVJlYWN0Rmxvd30sIHtAbGluayB1c2VWaWV3cG9ydH0sIGV0Yy5cbiAqL1xuZnVuY3Rpb24gdXNlU3RvcmVBcGkoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKHN0b3JlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih6dXN0YW5kRXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBzZXRTdGF0ZTogc3RvcmUuc2V0U3RhdGUsXG4gICAgICAgIHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLFxuICAgIH0pLCBbc3RvcmVdKTtcbn1cblxuY29uc3Qgc3R5bGUgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xuY29uc3QgYXJpYUxpdmVTdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgbWFyZ2luOiAtMSxcbiAgICBib3JkZXI6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgY2xpcDogJ3JlY3QoMHB4LCAwcHgsIDBweCwgMHB4KScsXG4gICAgY2xpcFBhdGg6ICdpbnNldCgxMDAlKScsXG59O1xuY29uc3QgQVJJQV9OT0RFX0RFU0NfS0VZID0gJ3JlYWN0LWZsb3dfX25vZGUtZGVzYyc7XG5jb25zdCBBUklBX0VER0VfREVTQ19LRVkgPSAncmVhY3QtZmxvd19fZWRnZS1kZXNjJztcbmNvbnN0IEFSSUFfTElWRV9NRVNTQUdFID0gJ3JlYWN0LWZsb3dfX2FyaWEtbGl2ZSc7XG5jb25zdCBhcmlhTGl2ZVNlbGVjdG9yID0gKHMpID0+IHMuYXJpYUxpdmVNZXNzYWdlO1xuY29uc3QgYXJpYUxhYmVsQ29uZmlnU2VsZWN0b3IgPSAocykgPT4gcy5hcmlhTGFiZWxDb25maWc7XG5mdW5jdGlvbiBBcmlhTGl2ZU1lc3NhZ2UoeyByZklkIH0pIHtcbiAgICBjb25zdCBhcmlhTGl2ZU1lc3NhZ2UgPSB1c2VTdG9yZShhcmlhTGl2ZVNlbGVjdG9yKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGlkOiBgJHtBUklBX0xJVkVfTUVTU0FHRX0tJHtyZklkfWAsIFwiYXJpYS1saXZlXCI6IFwiYXNzZXJ0aXZlXCIsIFwiYXJpYS1hdG9taWNcIjogXCJ0cnVlXCIsIHN0eWxlOiBhcmlhTGl2ZVN0eWxlLCBjaGlsZHJlbjogYXJpYUxpdmVNZXNzYWdlIH0pKTtcbn1cbmZ1bmN0aW9uIEExMXlEZXNjcmlwdGlvbnMoeyByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pIHtcbiAgICBjb25zdCBhcmlhTGFiZWxDb25maWcgPSB1c2VTdG9yZShhcmlhTGFiZWxDb25maWdTZWxlY3Rvcik7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfTk9ERV9ERVNDX0tFWX0tJHtyZklkfWAsIHN0eWxlOiBzdHlsZSwgY2hpbGRyZW46IGRpc2FibGVLZXlib2FyZEExMXlcbiAgICAgICAgICAgICAgICAgICAgPyBhcmlhTGFiZWxDb25maWdbJ25vZGUuYTExeURlc2NyaXB0aW9uLmRlZmF1bHQnXVxuICAgICAgICAgICAgICAgICAgICA6IGFyaWFMYWJlbENvbmZpZ1snbm9kZS5hMTF5RGVzY3JpcHRpb24ua2V5Ym9hcmREaXNhYmxlZCddIH0pLCBqc3goXCJkaXZcIiwgeyBpZDogYCR7QVJJQV9FREdFX0RFU0NfS0VZfS0ke3JmSWR9YCwgc3R5bGU6IHN0eWxlLCBjaGlsZHJlbjogYXJpYUxhYmVsQ29uZmlnWydlZGdlLmExMXlEZXNjcmlwdGlvbi5kZWZhdWx0J10gfSksICFkaXNhYmxlS2V5Ym9hcmRBMTF5ICYmIGpzeChBcmlhTGl2ZU1lc3NhZ2UsIHsgcmZJZDogcmZJZCB9KV0gfSkpO1xufVxuXG4vKipcbiAqIFRoZSBgPFBhbmVsIC8+YCBjb21wb25lbnQgaGVscHMgeW91IHBvc2l0aW9uIGNvbnRlbnQgYWJvdmUgdGhlIHZpZXdwb3J0LlxuICogSXQgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBbYDxNaW5pTWFwIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9taW5pbWFwKVxuICogYW5kIFtgPENvbnRyb2xzIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9jb250cm9scykgY29tcG9uZW50cy5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIEJhY2tncm91bmQsIFBhbmVsIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbXX0gZml0Vmlldz5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwidG9wLWxlZnRcIj50b3AtbGVmdDwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cInRvcC1jZW50ZXJcIj50b3AtY2VudGVyPC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwidG9wLXJpZ2h0XCI+dG9wLXJpZ2h0PC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwiYm90dG9tLWxlZnRcIj5ib3R0b20tbGVmdDwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cImJvdHRvbS1jZW50ZXJcIj5ib3R0b20tY2VudGVyPC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwiYm90dG9tLXJpZ2h0XCI+Ym90dG9tLXJpZ2h0PC9QYW5lbD5cbiAqICAgIDwvUmVhY3RGbG93PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IFBhbmVsID0gZm9yd2FyZFJlZigoeyBwb3NpdGlvbiA9ICd0b3AtbGVmdCcsIGNoaWxkcmVuLCBjbGFzc05hbWUsIHN0eWxlLCAuLi5yZXN0IH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uQ2xhc3NlcyA9IGAke3Bvc2l0aW9ufWAuc3BsaXQoJy0nKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19wYW5lbCcsIGNsYXNzTmFtZSwgLi4ucG9zaXRpb25DbGFzc2VzXSksIHN0eWxlOiBzdHlsZSwgcmVmOiByZWYsIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59KTtcblBhbmVsLmRpc3BsYXlOYW1lID0gJ1BhbmVsJztcblxuZnVuY3Rpb24gQXR0cmlidXRpb24oeyBwcm9PcHRpb25zLCBwb3NpdGlvbiA9ICdib3R0b20tcmlnaHQnIH0pIHtcbiAgICBpZiAocHJvT3B0aW9ucz8uaGlkZUF0dHJpYnV0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChQYW5lbCwgeyBwb3NpdGlvbjogcG9zaXRpb24sIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19hdHRyaWJ1dGlvblwiLCBcImRhdGEtbWVzc2FnZVwiOiBcIlBsZWFzZSBvbmx5IGhpZGUgdGhpcyBhdHRyaWJ1dGlvbiB3aGVuIHlvdSBhcmUgc3Vic2NyaWJlZCB0byBSZWFjdCBGbG93IFBybzogaHR0cHM6Ly9wcm8ucmVhY3RmbG93LmRldlwiLCBjaGlsZHJlbjoganN4KFwiYVwiLCB7IGhyZWY6IFwiaHR0cHM6Ly9yZWFjdGZsb3cuZGV2XCIsIHRhcmdldDogXCJfYmxhbmtcIiwgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIiwgXCJhcmlhLWxhYmVsXCI6IFwiUmVhY3QgRmxvdyBhdHRyaWJ1dGlvblwiLCBjaGlsZHJlbjogXCJSZWFjdCBGbG93XCIgfSkgfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRtID0gKHMpID0+IHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gW107XG4gICAgY29uc3Qgc2VsZWN0ZWRFZGdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgWywgbm9kZV0gb2Ygcy5ub2RlTG9va3VwKSB7XG4gICAgICAgIGlmIChub2RlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzLnB1c2gobm9kZS5pbnRlcm5hbHMudXNlck5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgWywgZWRnZV0gb2Ygcy5lZGdlTG9va3VwKSB7XG4gICAgICAgIGlmIChlZGdlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZEVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcyB9O1xufTtcbmNvbnN0IHNlbGVjdElkID0gKG9iaikgPT4gb2JqLmlkO1xuZnVuY3Rpb24gYXJlRXF1YWwoYSwgYikge1xuICAgIHJldHVybiAoc2hhbGxvdyhhLnNlbGVjdGVkTm9kZXMubWFwKHNlbGVjdElkKSwgYi5zZWxlY3RlZE5vZGVzLm1hcChzZWxlY3RJZCkpICYmXG4gICAgICAgIHNoYWxsb3coYS5zZWxlY3RlZEVkZ2VzLm1hcChzZWxlY3RJZCksIGIuc2VsZWN0ZWRFZGdlcy5tYXAoc2VsZWN0SWQpKSk7XG59XG5mdW5jdGlvbiBTZWxlY3Rpb25MaXN0ZW5lcklubmVyKHsgb25TZWxlY3Rpb25DaGFuZ2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyBzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzIH0gPSB1c2VTdG9yZShzZWxlY3RvciRtLCBhcmVFcXVhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0geyBub2Rlczogc2VsZWN0ZWROb2RlcywgZWRnZXM6IHNlbGVjdGVkRWRnZXMgfTtcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U/LihwYXJhbXMpO1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMuZm9yRWFjaCgoZm4pID0+IGZuKHBhcmFtcykpO1xuICAgIH0sIFtzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzLCBvblNlbGVjdGlvbkNoYW5nZV0pO1xuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgY2hhbmdlU2VsZWN0b3IgPSAocykgPT4gISFzLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM7XG5mdW5jdGlvbiBTZWxlY3Rpb25MaXN0ZW5lcih7IG9uU2VsZWN0aW9uQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmVIYXNTZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyA9IHVzZVN0b3JlKGNoYW5nZVNlbGVjdG9yKTtcbiAgICBpZiAob25TZWxlY3Rpb25DaGFuZ2UgfHwgc3RvcmVIYXNTZWxlY3Rpb25DaGFuZ2VIYW5kbGVycykge1xuICAgICAgICByZXR1cm4ganN4KFNlbGVjdGlvbkxpc3RlbmVySW5uZXIsIHsgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgZGVmYXVsdE5vZGVPcmlnaW4gPSBbMCwgMF07XG5jb25zdCBkZWZhdWx0Vmlld3BvcnQgPSB7IHg6IDAsIHk6IDAsIHpvb206IDEgfTtcblxuLypcbiAqIFRoaXMgY29tcG9uZW50IGhlbHBzIHVzIHRvIHVwZGF0ZSB0aGUgc3RvcmUgd2l0aCB0aGUgdmFsdWVzIGNvbWluZyBmcm9tIHRoZSB1c2VyLlxuICogV2UgZGlzdGluZ3Vpc2ggYmV0d2VlbiB2YWx1ZXMgd2UgY2FuIHVwZGF0ZSBkaXJlY3RseSB3aXRoIGB1c2VEaXJlY3RTdG9yZVVwZGF0ZXJgIChsaWtlIGBzbmFwR3JpZGApXG4gKiBhbmQgdmFsdWVzIHRoYXQgaGF2ZSBhIGRlZGljYXRlZCBzZXR0ZXIgZnVuY3Rpb24gaW4gdGhlIHN0b3JlIChsaWtlIGBzZXROb2Rlc2ApLlxuICovXG4vLyBUaGVzZSBmaWVsZHMgZXhpc3QgaW4gdGhlIGdsb2JhbCBzdG9yZSwgYW5kIHdlIG5lZWQgdG8ga2VlcCB0aGVtIHVwIHRvIGRhdGVcbmNvbnN0IHJlYWN0Rmxvd0ZpZWxkc1RvVHJhY2sgPSBbXG4gICAgJ25vZGVzJyxcbiAgICAnZWRnZXMnLFxuICAgICdkZWZhdWx0Tm9kZXMnLFxuICAgICdkZWZhdWx0RWRnZXMnLFxuICAgICdvbkNvbm5lY3QnLFxuICAgICdvbkNvbm5lY3RTdGFydCcsXG4gICAgJ29uQ29ubmVjdEVuZCcsXG4gICAgJ29uQ2xpY2tDb25uZWN0U3RhcnQnLFxuICAgICdvbkNsaWNrQ29ubmVjdEVuZCcsXG4gICAgJ25vZGVzRHJhZ2dhYmxlJyxcbiAgICAnYXV0b1Bhbk9uTm9kZUZvY3VzJyxcbiAgICAnbm9kZXNDb25uZWN0YWJsZScsXG4gICAgJ25vZGVzRm9jdXNhYmxlJyxcbiAgICAnZWRnZXNGb2N1c2FibGUnLFxuICAgICdlZGdlc1JlY29ubmVjdGFibGUnLFxuICAgICdlbGV2YXRlTm9kZXNPblNlbGVjdCcsXG4gICAgJ2VsZXZhdGVFZGdlc09uU2VsZWN0JyxcbiAgICAnbWluWm9vbScsXG4gICAgJ21heFpvb20nLFxuICAgICdub2RlRXh0ZW50JyxcbiAgICAnb25Ob2Rlc0NoYW5nZScsXG4gICAgJ29uRWRnZXNDaGFuZ2UnLFxuICAgICdlbGVtZW50c1NlbGVjdGFibGUnLFxuICAgICdjb25uZWN0aW9uTW9kZScsXG4gICAgJ3NuYXBHcmlkJyxcbiAgICAnc25hcFRvR3JpZCcsXG4gICAgJ3RyYW5zbGF0ZUV4dGVudCcsXG4gICAgJ2Nvbm5lY3RPbkNsaWNrJyxcbiAgICAnZGVmYXVsdEVkZ2VPcHRpb25zJyxcbiAgICAnZml0VmlldycsXG4gICAgJ2ZpdFZpZXdPcHRpb25zJyxcbiAgICAnb25Ob2Rlc0RlbGV0ZScsXG4gICAgJ29uRWRnZXNEZWxldGUnLFxuICAgICdvbkRlbGV0ZScsXG4gICAgJ29uTm9kZURyYWcnLFxuICAgICdvbk5vZGVEcmFnU3RhcnQnLFxuICAgICdvbk5vZGVEcmFnU3RvcCcsXG4gICAgJ29uU2VsZWN0aW9uRHJhZycsXG4gICAgJ29uU2VsZWN0aW9uRHJhZ1N0YXJ0JyxcbiAgICAnb25TZWxlY3Rpb25EcmFnU3RvcCcsXG4gICAgJ29uTW92ZVN0YXJ0JyxcbiAgICAnb25Nb3ZlJyxcbiAgICAnb25Nb3ZlRW5kJyxcbiAgICAnbm9QYW5DbGFzc05hbWUnLFxuICAgICdub2RlT3JpZ2luJyxcbiAgICAnYXV0b1Bhbk9uQ29ubmVjdCcsXG4gICAgJ2F1dG9QYW5Pbk5vZGVEcmFnJyxcbiAgICAnb25FcnJvcicsXG4gICAgJ2Nvbm5lY3Rpb25SYWRpdXMnLFxuICAgICdpc1ZhbGlkQ29ubmVjdGlvbicsXG4gICAgJ3NlbGVjdE5vZGVzT25EcmFnJyxcbiAgICAnbm9kZURyYWdUaHJlc2hvbGQnLFxuICAgICdjb25uZWN0aW9uRHJhZ1RocmVzaG9sZCcsXG4gICAgJ29uQmVmb3JlRGVsZXRlJyxcbiAgICAnZGVidWcnLFxuICAgICdhdXRvUGFuU3BlZWQnLFxuICAgICdwYW5lQ2xpY2tEaXN0YW5jZScsXG4gICAgJ2FyaWFMYWJlbENvbmZpZycsXG5dO1xuLy8gcmZJZCBkb2Vzbid0IGV4aXN0IGluIFJlYWN0Rmxvd1Byb3BzLCBidXQgaXQncyBvbmUgb2YgdGhlIGZpZWxkcyB3ZSB3YW50IHRvIHVwZGF0ZVxuY29uc3QgZmllbGRzVG9UcmFjayA9IFsuLi5yZWFjdEZsb3dGaWVsZHNUb1RyYWNrLCAncmZJZCddO1xuY29uc3Qgc2VsZWN0b3IkbCA9IChzKSA9PiAoe1xuICAgIHNldE5vZGVzOiBzLnNldE5vZGVzLFxuICAgIHNldEVkZ2VzOiBzLnNldEVkZ2VzLFxuICAgIHNldE1pblpvb206IHMuc2V0TWluWm9vbSxcbiAgICBzZXRNYXhab29tOiBzLnNldE1heFpvb20sXG4gICAgc2V0VHJhbnNsYXRlRXh0ZW50OiBzLnNldFRyYW5zbGF0ZUV4dGVudCxcbiAgICBzZXROb2RlRXh0ZW50OiBzLnNldE5vZGVFeHRlbnQsXG4gICAgcmVzZXQ6IHMucmVzZXQsXG4gICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXM6IHMuc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsXG4gICAgc2V0UGFuZUNsaWNrRGlzdGFuY2U6IHMuc2V0UGFuZUNsaWNrRGlzdGFuY2UsXG59KTtcbmNvbnN0IGluaXRQcmV2VmFsdWVzID0ge1xuICAgIC8qXG4gICAgICogdGhlc2UgYXJlIHZhbHVlcyB0aGF0IGFyZSBhbHNvIHBhc3NlZCBkaXJlY3RseSB0byBvdGhlciBjb21wb25lbnRzXG4gICAgICogdGhhbiB0aGUgU3RvcmVVcGRhdGVyLiBXZSBjYW4gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2V0U3RvcmUgY2FsbHNcbiAgICAgKiBieSBzZXR0aW5nIHRoZSBzYW1lIHZhbHVlcyBoZXJlIGFzIHByZXYgZmllbGRzLlxuICAgICAqL1xuICAgIHRyYW5zbGF0ZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgbm9kZU9yaWdpbjogZGVmYXVsdE5vZGVPcmlnaW4sXG4gICAgbWluWm9vbTogMC41LFxuICAgIG1heFpvb206IDIsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiB0cnVlLFxuICAgIG5vUGFuQ2xhc3NOYW1lOiAnbm9wYW4nLFxuICAgIHJmSWQ6ICcxJyxcbiAgICBwYW5lQ2xpY2tEaXN0YW5jZTogMCxcbn07XG5mdW5jdGlvbiBTdG9yZVVwZGF0ZXIocHJvcHMpIHtcbiAgICBjb25zdCB7IHNldE5vZGVzLCBzZXRFZGdlcywgc2V0TWluWm9vbSwgc2V0TWF4Wm9vbSwgc2V0VHJhbnNsYXRlRXh0ZW50LCBzZXROb2RlRXh0ZW50LCByZXNldCwgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsIHNldFBhbmVDbGlja0Rpc3RhbmNlLCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkbCwgc2hhbGxvdyk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzKHByb3BzLmRlZmF1bHROb2RlcywgcHJvcHMuZGVmYXVsdEVkZ2VzKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVzZXQgdGhlIHN0b3JlIHdlIGFsc28gbmVlZCB0byByZXNldCB0aGUgcHJldmlvdXMgZmllbGRzXG4gICAgICAgICAgICBwcmV2aW91c0ZpZWxkcy5jdXJyZW50ID0gaW5pdFByZXZWYWx1ZXM7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBwcmV2aW91c0ZpZWxkcyA9IHVzZVJlZihpbml0UHJldlZhbHVlcyk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgZmllbGRzVG9UcmFjaykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IHByb3BzW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0ZpZWxkVmFsdWUgPSBwcmV2aW91c0ZpZWxkcy5jdXJyZW50W2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gcHJldmlvdXNGaWVsZFZhbHVlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wc1tmaWVsZE5hbWVdID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIEN1c3RvbSBoYW5kbGluZyB3aXRoIGRlZGljYXRlZCBzZXR0ZXJzIGZvciBzb21lIGZpZWxkc1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ25vZGVzJylcbiAgICAgICAgICAgICAgICBzZXROb2RlcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2VkZ2VzJylcbiAgICAgICAgICAgICAgICBzZXRFZGdlcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ21pblpvb20nKVxuICAgICAgICAgICAgICAgIHNldE1pblpvb20oZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdtYXhab29tJylcbiAgICAgICAgICAgICAgICBzZXRNYXhab29tKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAndHJhbnNsYXRlRXh0ZW50JylcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2xhdGVFeHRlbnQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdub2RlRXh0ZW50JylcbiAgICAgICAgICAgICAgICBzZXROb2RlRXh0ZW50KGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAncGFuZUNsaWNrRGlzdGFuY2UnKVxuICAgICAgICAgICAgICAgIHNldFBhbmVDbGlja0Rpc3RhbmNlKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnYXJpYUxhYmVsQ29uZmlnJylcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGFyaWFMYWJlbENvbmZpZzogbWVyZ2VBcmlhTGFiZWxDb25maWcoZmllbGRWYWx1ZSkgfSk7XG4gICAgICAgICAgICAvLyBSZW5hbWVkIGZpZWxkc1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnZml0VmlldycpXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBmaXRWaWV3UXVldWVkOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnZml0Vmlld09wdGlvbnMnKVxuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld09wdGlvbnM6IGZpZWxkVmFsdWUgfSk7XG4gICAgICAgICAgICAvLyBHZW5lcmFsIGNhc2VcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzRmllbGRzLmN1cnJlbnQgPSBwcm9wcztcbiAgICB9LCBcbiAgICAvLyBPbmx5IHJlLXJ1biB0aGUgZWZmZWN0IGlmIG9uZSBvZiB0aGUgZmllbGRzIHdlIHRyYWNrIGNoYW5nZXNcbiAgICBmaWVsZHNUb1RyYWNrLm1hcCgoZmllbGROYW1lKSA9PiBwcm9wc1tmaWVsZE5hbWVdKSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE1lZGlhUXVlcnkoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJyk7XG59XG4vKipcbiAqIEhvb2sgZm9yIHJlY2VpdmluZyB0aGUgY3VycmVudCBjb2xvciBtb2RlIGNsYXNzICdkYXJrJyBvciAnbGlnaHQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGNvbG9yTW9kZSAtIFRoZSBjb2xvciBtb2RlIHRvIHVzZSAoJ2RhcmsnLCAnbGlnaHQnIG9yICdzeXN0ZW0nKVxuICovXG5mdW5jdGlvbiB1c2VDb2xvck1vZGVDbGFzcyhjb2xvck1vZGUpIHtcbiAgICBjb25zdCBbY29sb3JNb2RlQ2xhc3MsIHNldENvbG9yTW9kZUNsYXNzXSA9IHVzZVN0YXRlKGNvbG9yTW9kZSA9PT0gJ3N5c3RlbScgPyBudWxsIDogY29sb3JNb2RlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY29sb3JNb2RlICE9PSAnc3lzdGVtJykge1xuICAgICAgICAgICAgc2V0Q29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gZ2V0TWVkaWFRdWVyeSgpO1xuICAgICAgICBjb25zdCB1cGRhdGVDb2xvck1vZGVDbGFzcyA9ICgpID0+IHNldENvbG9yTW9kZUNsYXNzKG1lZGlhUXVlcnk/Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKTtcbiAgICAgICAgdXBkYXRlQ29sb3JNb2RlQ2xhc3MoKTtcbiAgICAgICAgbWVkaWFRdWVyeT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29sb3JNb2RlQ2xhc3MpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbWVkaWFRdWVyeT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29sb3JNb2RlQ2xhc3MpO1xuICAgICAgICB9O1xuICAgIH0sIFtjb2xvck1vZGVdKTtcbiAgICByZXR1cm4gY29sb3JNb2RlQ2xhc3MgIT09IG51bGwgPyBjb2xvck1vZGVDbGFzcyA6IGdldE1lZGlhUXVlcnkoKT8ubWF0Y2hlcyA/ICdkYXJrJyA6ICdsaWdodCc7XG59XG5cbmNvbnN0IGRlZmF1bHREb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsO1xuLyoqXG4gKiBUaGlzIGhvb2sgbGV0cyB5b3UgbGlzdGVuIGZvciBzcGVjaWZpYyBrZXkgY29kZXMgYW5kIHRlbGxzIHlvdSB3aGV0aGVyIHRoZXkgYXJlXG4gKiBjdXJyZW50bHkgcHJlc3NlZCBvciBub3QuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VLZXlQcmVzcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IHNwYWNlUHJlc3NlZCA9IHVzZUtleVByZXNzKCdTcGFjZScpO1xuICogIGNvbnN0IGNtZEFuZFNQcmVzc2VkID0gdXNlS2V5UHJlc3MoWydNZXRhK3MnLCAnU3RyZytzJ10pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICB7c3BhY2VQcmVzc2VkICYmIDxwPlNwYWNlIHByZXNzZWQhPC9wPn1cbiAqICAgICB7Y21kQW5kU1ByZXNzZWQgJiYgPHA+Q21kICsgUyBwcmVzc2VkITwvcD59XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VLZXlQcmVzcyhcbi8qKlxuICogVGhlIGtleSBjb2RlIChzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncykgc3BlY2lmaWVzIHdoaWNoIGtleShzKSBzaG91bGQgdHJpZ2dlclxuICogYW4gYWN0aW9uLlxuICpcbiAqIEEgKipzdHJpbmcqKiBjYW4gcmVwcmVzZW50OlxuICogLSBBICoqc2luZ2xlIGtleSoqLCBlLmcuIGAnYSdgXG4gKiAtIEEgKiprZXkgY29tYmluYXRpb24qKiwgdXNpbmcgYCcrJ2AgdG8gc2VwYXJhdGUga2V5cywgZS5nLiBgJ2ErZCdgXG4gKlxuICogQW4gICoqYXJyYXkgb2Ygc3RyaW5ncyoqIHJlcHJlc2VudHMgKiptdWx0aXBsZSBwb3NzaWJsZSBrZXkgaW5wdXRzKiouIEZvciBleGFtcGxlLCBgWydhJywgJ2QrcyddYFxuICogbWVhbnMgdGhlIHVzZXIgY2FuIHByZXNzIGVpdGhlciB0aGUgc2luZ2xlIGtleSBgJ2EnYCBvciB0aGUgY29tYmluYXRpb24gb2YgYCdkJ2AgYW5kIGAncydgLlxuICogQGRlZmF1bHQgbnVsbFxuICovXG5rZXlDb2RlID0gbnVsbCwgb3B0aW9ucyA9IHsgdGFyZ2V0OiBkZWZhdWx0RG9jLCBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcjogdHJ1ZSB9KSB7XG4gICAgY29uc3QgW2tleVByZXNzZWQsIHNldEtleVByZXNzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgaWYgYSBtb2RpZmllciBrZXkgaXMgcHJlc3NlZCBpbiBvcmRlciB0byB0cmFjayBpdFxuICAgIGNvbnN0IG1vZGlmaWVyUHJlc3NlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gd2UgbmVlZCB0byByZW1lbWJlciB0aGUgcHJlc3NlZCBrZXlzIGluIG9yZGVyIHRvIHN1cHBvcnQgY29tYmluYXRpb25zXG4gICAgY29uc3QgcHJlc3NlZEtleXMgPSB1c2VSZWYobmV3IFNldChbXSkpO1xuICAgIC8qXG4gICAgICoga2V5Q29kZXMgPSBhcnJheSB3aXRoIHNpbmdsZSBrZXlzIFtbJ2EnXV0gb3Iga2V5IGNvbWJpbmF0aW9ucyBbWydhJywgJ3MnXV1cbiAgICAgKiBrZXlzVG9XYXRjaCA9IGFycmF5IHdpdGggYWxsIGtleXMgZmxhdHRlbmVkIFsnYScsICdkJywgJ1NoaWZ0TGVmdCddXG4gICAgICogdXNlZCB0byBjaGVjayBpZiB3ZSBzdG9yZSBldmVudC5jb2RlIG9yIGV2ZW50LmtleS4gV2hlbiB0aGUgY29kZSBpcyBpbiB0aGUgbGlzdCBvZiBrZXlzVG9XYXRjaFxuICAgICAqIHdlIHVzZSB0aGUgY29kZSBvdGhlcndpc2UgdGhlIGtleS4gRXhwbGFpbmVyOiBXaGVuIHlvdSBwcmVzcyB0aGUgbGVmdCBcImNvbW1hbmRcIiBrZXksIHRoZSBjb2RlIGlzIFwiTWV0YUxlZnRcIlxuICAgICAqIGFuZCB0aGUga2V5IGlzIFwiTWV0YVwiLiBXZSB3YW50IHVzZXJzIHRvIGJlIGFibGUgdG8gcGFzcyBrZXlzIGFuZCBjb2RlcyBzbyB3ZSBhc3N1bWUgdGhhdCB0aGUga2V5IGlzIG1lYW50IHdoZW5cbiAgICAgKiB3ZSBjYW4ndCBmaW5kIGl0IGluIHRoZSBsaXN0IG9mIGtleXNUb1dhdGNoLlxuICAgICAqL1xuICAgIGNvbnN0IFtrZXlDb2Rlcywga2V5c1RvV2F0Y2hdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlDb2RlQXJyID0gQXJyYXkuaXNBcnJheShrZXlDb2RlKSA/IGtleUNvZGUgOiBba2V5Q29kZV07XG4gICAgICAgICAgICBjb25zdCBrZXlzID0ga2V5Q29kZUFyclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGtjKSA9PiB0eXBlb2Yga2MgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogd2UgZmlyc3QgcmVwbGFjZSBhbGwgJysnIHdpdGggJ1xcbicgIHdoaWNoIHdlIHdpbGwgdXNlIHRvIHNwbGl0IHRoZSBrZXlzIG9uXG4gICAgICAgICAgICAgICAgICogdGhlbiB3ZSByZXBsYWNlICdcXG5cXG4nIHdpdGggJ1xcbisnLCB0aGlzIHdheSB3ZSBjYW4gYWxzbyBzdXBwb3J0IHRoZSBjb21iaW5hdGlvbiAna2V5KysnXG4gICAgICAgICAgICAgICAgICogaW4gdGhlIGVuZCB3ZSBzaW1wbHkgc3BsaXQgb24gJ1xcbicgdG8gZ2V0IHRoZSBrZXkgYXJyYXlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAubWFwKChrYykgPT4ga2MucmVwbGFjZSgnKycsICdcXG4nKS5yZXBsYWNlKCdcXG5cXG4nLCAnXFxuKycpLnNwbGl0KCdcXG4nKSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzRmxhdCA9IGtleXMucmVkdWNlKChyZXMsIGl0ZW0pID0+IHJlcy5jb25jYXQoLi4uaXRlbSksIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBba2V5cywga2V5c0ZsYXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbW10sIFtdXTtcbiAgICB9LCBba2V5Q29kZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnM/LnRhcmdldCA/PyBkZWZhdWx0RG9jO1xuICAgICAgICBjb25zdCBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciA9IG9wdGlvbnM/LmFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyID8/IHRydWU7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkb3duSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ZW50QWN0aW9uID0gKCFtb2RpZmllclByZXNzZWQuY3VycmVudCB8fCAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgJiYgIWFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNJbnB1dERPTU5vZGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5T3JDb2RlID0gdXNlS2V5T3JDb2RlKGV2ZW50LmNvZGUsIGtleXNUb1dhdGNoKTtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmFkZChldmVudFtrZXlPckNvZGVdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMuY3VycmVudCwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChldmVudC5jb21wb3NlZFBhdGg/LigpPy5bMF0gfHwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNJbnRlcmFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ/Lm5vZGVOYW1lID09PSAnQlVUVE9OJyB8fCB0YXJnZXQ/Lm5vZGVOYW1lID09PSAnQSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByZXZlbnREZWZhdWx0ICE9PSBmYWxzZSAmJiAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgfHwgIWlzSW50ZXJhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1cEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlPckNvZGUgPSB1c2VLZXlPckNvZGUoZXZlbnQuY29kZSwga2V5c1RvV2F0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cy5jdXJyZW50LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5kZWxldGUoZXZlbnRba2V5T3JDb2RlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZpeCBmb3IgTWFjOiB3aGVuIGNtZCBrZXkgaXMgcHJlc3NlZCwga2V5dXAgaXMgbm90IHRyaWdnZXJlZCBmb3IgYW55IG90aGVyIGtleSwgc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzM4MDAxOC93aGVuLWNtZC1rZXktaXMta2VwdC1wcmVzc2VkLWtleXVwLWlzLW5vdC10cmlnZ2VyZWQtZm9yLWFueS1vdGhlci1rZXlcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnTWV0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW2tleUNvZGUsIHNldEtleVByZXNzZWRdKTtcbiAgICByZXR1cm4ga2V5UHJlc3NlZDtcbn1cbi8vIHV0aWxzXG5mdW5jdGlvbiBpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cywgaXNVcCkge1xuICAgIHJldHVybiAoa2V5Q29kZXNcbiAgICAgICAgLypcbiAgICAgICAgICogd2Ugb25seSB3YW50IHRvIGNvbXBhcmUgc2FtZSBzaXplcyBvZiBrZXlDb2RlIGRlZmluaXRpb25zXG4gICAgICAgICAqIGFuZCBwcmVzc2VkIGtleXMuIFdoZW4gdGhlIHVzZXIgc3BlY2lmaWVkICdNZXRhJyBhcyBhIGtleSBzb21ld2hlcmVcbiAgICAgICAgICogdGhpcyB3b3VsZCBhbHNvIGJlIHRydXRoeSB3aXRob3V0IHRoaXMgZmlsdGVyIHdoZW4gdXNlciBwcmVzc2VzICdNZXRhJyArICdyJ1xuICAgICAgICAgKi9cbiAgICAgICAgLmZpbHRlcigoa2V5cykgPT4gaXNVcCB8fCBrZXlzLmxlbmd0aCA9PT0gcHJlc3NlZEtleXMuc2l6ZSlcbiAgICAgICAgLypcbiAgICAgICAgICogc2luY2Ugd2Ugd2FudCB0byBzdXBwb3J0IG11bHRpcGxlIHBvc3NpYmlsaXRpZXMgb25seSBvbmUgb2YgdGhlXG4gICAgICAgICAqIGNvbWJpbmF0aW9ucyBuZWVkIHRvIGJlIHBhcnQgb2YgdGhlIHByZXNzZWQga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAgLnNvbWUoKGtleXMpID0+IGtleXMuZXZlcnkoKGspID0+IHByZXNzZWRLZXlzLmhhcyhrKSkpKTtcbn1cbmZ1bmN0aW9uIHVzZUtleU9yQ29kZShldmVudENvZGUsIGtleXNUb1dhdGNoKSB7XG4gICAgcmV0dXJuIGtleXNUb1dhdGNoLmluY2x1ZGVzKGV2ZW50Q29kZSkgPyAnY29kZScgOiAna2V5Jztcbn1cblxuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHZpZXdwb3J0IGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyB2aWV3cG9ydCBoZWxwZXIgZnVuY3Rpb25zXG4gKi9cbmNvbnN0IHVzZVZpZXdwb3J0SGVscGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6b29tSW46IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZUJ5KDEuMiwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSkgOiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpvb21PdXQ6IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZUJ5KDEgLyAxLjIsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pIDogUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6b29tVG86ICh6b29tTGV2ZWwsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhblpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhblpvb20gPyBwYW5ab29tLnNjYWxlVG8oem9vbUxldmVsLCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KSA6IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Wm9vbTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICBzZXRWaWV3cG9ydDogYXN5bmMgKHZpZXdwb3J0LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm06IFt0WCwgdFksIHRab29tXSwgcGFuWm9vbSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgeDogdmlld3BvcnQueCA/PyB0WCxcbiAgICAgICAgICAgICAgICAgICAgeTogdmlld3BvcnQueSA/PyB0WSxcbiAgICAgICAgICAgICAgICAgICAgem9vbTogdmlld3BvcnQuem9vbSA/PyB0Wm9vbSxcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFZpZXdwb3J0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3gsIHksIHpvb21dID0gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSwgem9vbSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldENlbnRlcjogYXN5bmMgKHgsIHksIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuZ2V0U3RhdGUoKS5zZXRDZW50ZXIoeCwgeSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0Qm91bmRzOiBhc3luYyAoYm91bmRzLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBvcHRpb25zPy5wYWRkaW5nID8/IDAuMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHZpZXdwb3J0LCB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZWFzZTogb3B0aW9ucz8uZWFzZSxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnM/LmludGVycG9sYXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NyZWVuVG9GbG93UG9zaXRpb246IChjbGllbnRQb3NpdGlvbiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgeDogZG9tWCwgeTogZG9tWSB9ID0gZG9tTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0ZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY2xpZW50UG9zaXRpb24ueCAtIGRvbVgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNsaWVudFBvc2l0aW9uLnkgLSBkb21ZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgX3NuYXBHcmlkID0gb3B0aW9ucy5zbmFwR3JpZCA/PyBzbmFwR3JpZDtcbiAgICAgICAgICAgICAgICBjb25zdCBfc25hcFRvR3JpZCA9IG9wdGlvbnMuc25hcFRvR3JpZCA/PyBzbmFwVG9HcmlkO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludFRvUmVuZGVyZXJQb2ludChjb3JyZWN0ZWRQb3NpdGlvbiwgdHJhbnNmb3JtLCBfc25hcFRvR3JpZCwgX3NuYXBHcmlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmbG93VG9TY3JlZW5Qb3NpdGlvbjogKGZsb3dQb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvd1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IGRvbVgsIHk6IGRvbVkgfSA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJQb3NpdGlvbiA9IHJlbmRlcmVyUG9pbnRUb1BvaW50KGZsb3dQb3NpdGlvbiwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiByZW5kZXJlclBvc2l0aW9uLnggKyBkb21YLFxuICAgICAgICAgICAgICAgICAgICB5OiByZW5kZXJlclBvc2l0aW9uLnkgKyBkb21ZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn07XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgY2hhbmdlcyB0byBub2RlcyBvciBlZGdlcyB0aGF0IGFyZSB0cmlnZ2VyZWQgYnkgUmVhY3QgRmxvdyBpbnRlcm5hbGx5LlxuICogV2hlbiB5b3UgZHJhZyBhIG5vZGUgZm9yIGV4YW1wbGUsIFJlYWN0IEZsb3cgd2lsbCBzZW5kIGEgcG9zaXRpb24gY2hhbmdlIHVwZGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gdGhlbiBhcHBsaWVzIHRoZSBjaGFuZ2VzIGFuZCByZXR1cm5zIHRoZSB1cGRhdGVkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBhcHBseUNoYW5nZXMoY2hhbmdlcywgZWxlbWVudHMpIHtcbiAgICBjb25zdCB1cGRhdGVkRWxlbWVudHMgPSBbXTtcbiAgICAvKlxuICAgICAqIEJ5IHN0b3JpbmcgYSBtYXAgb2YgY2hhbmdlcyBmb3IgZWFjaCBlbGVtZW50LCB3ZSBjYW4gYSBxdWljayBsb29rdXAgYXMgd2VcbiAgICAgKiBpdGVyYXRlIG92ZXIgdGhlIGVsZW1lbnRzIGFycmF5IVxuICAgICAqL1xuICAgIGNvbnN0IGNoYW5nZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYWRkSXRlbUNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIGFkZEl0ZW1DaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAncmVtb3ZlJyB8fCBjaGFuZ2UudHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogRm9yIGEgJ3JlbW92ZScgY2hhbmdlIHdlIGNhbiBzYWZlbHkgaWdub3JlIGFueSBvdGhlciBjaGFuZ2VzIHF1ZXVlZCBmb3JcbiAgICAgICAgICAgICAqIHRoZSBzYW1lIGVsZW1lbnQsIGl0J3MgZ29pbmcgdG8gYmUgcmVtb3ZlZCBhbnl3YXkhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNoYW5nZXNNYXAuc2V0KGNoYW5nZS5pZCwgW2NoYW5nZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudENoYW5nZXMgPSBjaGFuZ2VzTWFwLmdldChjaGFuZ2UuaWQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIHNvbWUgY2hhbmdlcyBxdWV1ZWQgYWxyZWFkeSwgd2UgY2FuIGRvIGEgbXV0YWJsZSB1cGRhdGUgb2ZcbiAgICAgICAgICAgICAgICAgKiB0aGF0IGFycmF5IGFuZCBzYXZlIG91cnNlbHZlcyBzb21lIGNvcHlpbmcuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxlbWVudENoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlc01hcC5zZXQoY2hhbmdlLmlkLCBbY2hhbmdlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBjaGFuZ2VzTWFwLmdldChlbGVtZW50LmlkKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2hlbiB0aGVyZSBhcmUgbm8gY2hhbmdlcyBmb3IgYW4gZWxlbWVudCB3ZSBjYW4ganVzdCBwdXNoIGl0IHVubW9kaWZpZWQsXG4gICAgICAgICAqIG5vIG5lZWQgdG8gY29weSBpdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghY2hhbmdlcykge1xuICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgJ3JlbW92ZScgY2hhbmdlIHF1ZXVlZCwgaXQnbGwgYmUgdGhlIG9ubHkgY2hhbmdlIGluIHRoZSBhcnJheVxuICAgICAgICBpZiAoY2hhbmdlc1swXS50eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbMF0udHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICB1cGRhdGVkRWxlbWVudHMucHVzaCh7IC4uLmNoYW5nZXNbMF0uaXRlbSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3Igb3RoZXIgdHlwZXMgb2YgY2hhbmdlcywgd2Ugd2FudCB0byBzdGFydCB3aXRoIGEgc2hhbGxvdyBjb3B5IG9mIHRoZVxuICAgICAgICAgKiBvYmplY3Qgc28gUmVhY3Qga25vd3MgdGhpcyBlbGVtZW50IGhhcyBjaGFuZ2VkLiBTZXF1ZW50aWFsIGNoYW5nZXMgd2lsbFxuICAgICAgICAgKiBlYWNoIF9tdXRhdGVfIHRoaXMgb2JqZWN0LCBzbyB0aGVyZSdzIG9ubHkgZXZlciBvbmUgY29weS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRFbGVtZW50ID0geyAuLi5lbGVtZW50IH07XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGFwcGx5Q2hhbmdlKGNoYW5nZSwgdXBkYXRlZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKHVwZGF0ZWRFbGVtZW50KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiB3ZSBuZWVkIHRvIHdhaXQgZm9yIGFsbCBjaGFuZ2VzIHRvIGJlIGFwcGxpZWQgYmVmb3JlIGFkZGluZyBuZXcgaXRlbXNcbiAgICAgKiB0byBiZSBhYmxlIHRvIGFkZCB0aGVtIGF0IHRoZSBjb3JyZWN0IGluZGV4XG4gICAgICovXG4gICAgaWYgKGFkZEl0ZW1DaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICBhZGRJdGVtQ2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2UuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5zcGxpY2UoY2hhbmdlLmluZGV4LCAwLCB7IC4uLmNoYW5nZS5pdGVtIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goeyAuLi5jaGFuZ2UuaXRlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVkRWxlbWVudHM7XG59XG4vLyBBcHBsaWVzIGEgc2luZ2xlIGNoYW5nZSB0byBhbiBlbGVtZW50LiBUaGlzIGlzIGEgKm11dGFibGUqIHVwZGF0ZS5cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlKGNoYW5nZSwgZWxlbWVudCkge1xuICAgIHN3aXRjaCAoY2hhbmdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZCA9IGNoYW5nZS5zZWxlY3RlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UucG9zaXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wb3NpdGlvbiA9IGNoYW5nZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLmRyYWdnaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZHJhZ2dpbmcgPSBjaGFuZ2UuZHJhZ2dpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdkaW1lbnNpb25zJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UuZGltZW5zaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1lYXN1cmVkID8/PSB7fTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1lYXN1cmVkLndpZHRoID0gY2hhbmdlLmRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tZWFzdXJlZC5oZWlnaHQgPSBjaGFuZ2UuZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5zZXRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gdHJ1ZSB8fCBjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gJ3dpZHRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC53aWR0aCA9IGNoYW5nZS5kaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gdHJ1ZSB8fCBjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaGVpZ2h0ID0gY2hhbmdlLmRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UucmVzaXppbmcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXppbmcgPSBjaGFuZ2UucmVzaXppbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRHJvcCBpbiBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgbm9kZSBjaGFuZ2VzIHRvIGFuIGFycmF5IG9mIG5vZGVzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGNoYW5nZXMgLSBBcnJheSBvZiBjaGFuZ2VzIHRvIGFwcGx5LlxuICogQHBhcmFtIG5vZGVzIC0gQXJyYXkgb2Ygbm9kZXMgdG8gYXBwbHkgdGhlIGNoYW5nZXMgdG8uXG4gKiBAcmV0dXJucyBBcnJheSBvZiB1cGRhdGVkIG5vZGVzLlxuICogQGV4YW1wbGVcbiAqYGBgdHN4XG4gKmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBhcHBseU5vZGVDaGFuZ2VzLCB0eXBlIE5vZGUsIHR5cGUgRWRnZSwgdHlwZSBPbk5vZGVzQ2hhbmdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXNdID0gdXNlU3RhdGU8Tm9kZVtdPihbXSk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlc10gPSB1c2VTdGF0ZTxFZGdlW10+KFtdKTtcbiAqICBjb25zdCBvbk5vZGVzQ2hhbmdlOiBPbk5vZGVzQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gKiAgICAoY2hhbmdlcykgPT4ge1xuICogICAgICBzZXROb2Rlcygob2xkTm9kZXMpID0+IGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgb2xkTm9kZXMpKTtcbiAqICAgIH0sXG4gKiAgICBbc2V0Tm9kZXNdLFxuICogICk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtub2Rlc30gZWRnZXM9e2VkZ2VzfSBvbk5vZGVzQ2hhbmdlPXtvbk5vZGVzQ2hhbmdlfSAvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKiBAcmVtYXJrcyBWYXJpb3VzIGV2ZW50cyBvbiB0aGUgPFJlYWN0RmxvdyAvPiBjb21wb25lbnQgY2FuIHByb2R1Y2UgYW4ge0BsaW5rIE5vZGVDaGFuZ2V9XG4gKiB0aGF0IGRlc2NyaWJlcyBob3cgdG8gdXBkYXRlIHRoZSBlZGdlcyBvZiB5b3VyIGZsb3cgaW4gc29tZSB3YXkuXG4gKiBJZiB5b3UgZG9uJ3QgbmVlZCBhbnkgY3VzdG9tIGJlaGF2aW91ciwgdGhpcyB1dGlsIGNhbiBiZSB1c2VkIHRvIHRha2UgYW4gYXJyYXlcbiAqIG9mIHRoZXNlIGNoYW5nZXMgYW5kIGFwcGx5IHRoZW0gdG8geW91ciBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBub2Rlcykge1xuICAgIHJldHVybiBhcHBseUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpO1xufVxuLyoqXG4gKiBEcm9wIGluIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBlZGdlIGNoYW5nZXMgdG8gYW4gYXJyYXkgb2YgZWRnZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gY2hhbmdlcyAtIEFycmF5IG9mIGNoYW5nZXMgdG8gYXBwbHkuXG4gKiBAcGFyYW0gZWRnZXMgLSBBcnJheSBvZiBlZGdlIHRvIGFwcGx5IHRoZSBjaGFuZ2VzIHRvLlxuICogQHJldHVybnMgQXJyYXkgb2YgdXBkYXRlZCBlZGdlcy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBSZWFjdEZsb3csIGFwcGx5RWRnZUNoYW5nZXMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlc10gPSB1c2VTdGF0ZShbXSk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlc10gPSB1c2VTdGF0ZShbXSk7XG4gKiAgY29uc3Qgb25FZGdlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICogICAgKGNoYW5nZXMpID0+IHtcbiAqICAgICAgc2V0RWRnZXMoKG9sZEVkZ2VzKSA9PiBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIG9sZEVkZ2VzKSk7XG4gKiAgICB9LFxuICogICAgW3NldEVkZ2VzXSxcbiAqICApO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17bm9kZXN9IGVkZ2VzPXtlZGdlc30gb25FZGdlc0NoYW5nZT17b25FZGdlc0NoYW5nZX0gLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICogQHJlbWFya3MgVmFyaW91cyBldmVudHMgb24gdGhlIDxSZWFjdEZsb3cgLz4gY29tcG9uZW50IGNhbiBwcm9kdWNlIGFuIHtAbGluayBFZGdlQ2hhbmdlfVxuICogdGhhdCBkZXNjcmliZXMgaG93IHRvIHVwZGF0ZSB0aGUgZWRnZXMgb2YgeW91ciBmbG93IGluIHNvbWUgd2F5LlxuICogSWYgeW91IGRvbid0IG5lZWQgYW55IGN1c3RvbSBiZWhhdmlvdXIsIHRoaXMgdXRpbCBjYW4gYmUgdXNlZCB0byB0YWtlIGFuIGFycmF5XG4gKiBvZiB0aGVzZSBjaGFuZ2VzIGFuZCBhcHBseSB0aGVtIHRvIHlvdXIgZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShpZCwgc2VsZWN0ZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZCxcbiAgICAgICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgICAgIHNlbGVjdGVkLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25DaGFuZ2VzKGl0ZW1zLCBzZWxlY3RlZElkcyA9IG5ldyBTZXQoKSwgbXV0YXRlSXRlbSA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2lkLCBpdGVtXSBvZiBpdGVtcykge1xuICAgICAgICBjb25zdCB3aWxsQmVTZWxlY3RlZCA9IHNlbGVjdGVkSWRzLmhhcyhpZCk7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gc2V0IGFsbCBpdGVtcyB0byBzZWxlY3RlZD1mYWxzZSBvbiB0aGUgZmlyc3Qgc2VsZWN0aW9uXG4gICAgICAgIGlmICghKGl0ZW0uc2VsZWN0ZWQgPT09IHVuZGVmaW5lZCAmJiAhd2lsbEJlU2VsZWN0ZWQpICYmIGl0ZW0uc2VsZWN0ZWQgIT09IHdpbGxCZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpZiAobXV0YXRlSXRlbSkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogdGhpcyBoYWNrIGlzIG5lZWRlZCBmb3Igbm9kZXMuIFdoZW4gdGhlIHVzZXIgZHJhZ2dlZCBhIG5vZGUsIGl0J3Mgc2VsZWN0ZWQuXG4gICAgICAgICAgICAgICAgICogV2hlbiBhbm90aGVyIG5vZGUgZ2V0cyBkcmFnZ2VkLCB3ZSBuZWVkIHRvIGRlc2VsZWN0IHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgICAgICAgICAgICogaW4gb3JkZXIgdG8gaGF2ZSBvbmx5IG9uZSBzZWxlY3RlZCBub2RlIGF0IGEgdGltZSAtIHRoZSBvbk5vZGVzQ2hhbmdlIGNhbGxiYWNrIGNvbWVzIHRvbyBsYXRlIGhlcmUgOi9cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gd2lsbEJlU2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGl0ZW0uaWQsIHdpbGxCZVNlbGVjdGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZXM7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50c0RpZmZDaGFuZ2VzKHsgaXRlbXMgPSBbXSwgbG9va3VwLCB9KSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGl0ZW1zTG9va3VwID0gbmV3IE1hcChpdGVtcy5tYXAoKGl0ZW0pID0+IFtpdGVtLmlkLCBpdGVtXSkpO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCBpdGVtXSBvZiBpdGVtcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgbG9va3VwSXRlbSA9IGxvb2t1cC5nZXQoaXRlbS5pZCk7XG4gICAgICAgIGNvbnN0IHN0b3JlSXRlbSA9IGxvb2t1cEl0ZW0/LmludGVybmFscz8udXNlck5vZGUgPz8gbG9va3VwSXRlbTtcbiAgICAgICAgaWYgKHN0b3JlSXRlbSAhPT0gdW5kZWZpbmVkICYmIHN0b3JlSXRlbSAhPT0gaXRlbSkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgaWQ6IGl0ZW0uaWQsIGl0ZW06IGl0ZW0sIHR5cGU6ICdyZXBsYWNlJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcmVJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGl0ZW06IGl0ZW0sIHR5cGU6ICdhZGQnLCBpbmRleCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZF0gb2YgbG9va3VwKSB7XG4gICAgICAgIGNvbnN0IG5leHROb2RlID0gaXRlbXNMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgaWYgKG5leHROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGlkLCB0eXBlOiAncmVtb3ZlJyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGVsZW1lbnRUb1JlbW92ZUNoYW5nZShpdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgIH07XG59XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2FibGUgYXMgYW4gW2BOb2RlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvbm9kZSkuXG4gKiBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG9cbiAqIFtgTm9kZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL25vZGUpIGlmIGl0IHJldHVybnMgYHRydWVgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBOb2RlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0LlxuICogQHJldHVybnMgVGVzdHMgd2hldGhlciB0aGUgcHJvdmlkZWQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYSBgTm9kZWAuIElmIHlvdSdyZSB1c2luZyBUeXBlU2NyaXB0LFxuICogdGhpcyBmdW5jdGlvbiBhY3RzIGFzIGEgdHlwZSBndWFyZCBhbmQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGBOb2RlYCBpZiBpdCByZXR1cm5zXG4gKiBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqaWYgKGlzTm9kZShub2RlKSkge1xuICogLy8gLi4uXG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IGlzTm9kZSA9IChlbGVtZW50KSA9PiBpc05vZGVCYXNlKGVsZW1lbnQpO1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzYWJsZSBhcyBhbiBbYEVkZ2VgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlKS5cbiAqIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0b1xuICogW2BFZGdlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZSkgaWYgaXQgcmV0dXJucyBgdHJ1ZWAuXG4gKlxuICogQHB1YmxpY1xuICogQHJlbWFya3MgSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvIEVkZ2UgaWYgaXQgcmV0dXJucyB0cnVlXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHRlc3RcbiAqIEByZXR1cm5zIFRlc3RzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGBFZGdlYC4gSWYgeW91J3JlIHVzaW5nIFR5cGVTY3JpcHQsXG4gKiB0aGlzIGZ1bmN0aW9uIGFjdHMgYXMgYSB0eXBlIGd1YXJkIGFuZCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYEVkZ2VgIGlmIGl0IHJldHVybnNcbiAqIGB0cnVlYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqaW1wb3J0IHsgaXNFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICppZiAoaXNFZGdlKGVkZ2UpKSB7XG4gKiAvLyAuLi5cbiAqfVxuICpgYGBcbiAqL1xuY29uc3QgaXNFZGdlID0gKGVsZW1lbnQpID0+IGlzRWRnZUJhc2UoZWxlbWVudCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LW9iamVjdC10eXBlXG5mdW5jdGlvbiBmaXhlZEZvcndhcmRSZWYocmVuZGVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gZm9yd2FyZFJlZihyZW5kZXIpO1xufVxuXG4vLyB3ZSBuZWVkIHRoaXMgaG9vayB0byBwcmV2ZW50IGEgd2FybmluZyB3aGVuIHVzaW5nIHJlYWN0LWZsb3cgaW4gU1NSXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYSBxdWV1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJhdGNoIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIHJ1blF1ZXVlIC0gYSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGZsdXNoZWRcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEByZXR1cm5zIGEgUXVldWUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHVzZVF1ZXVlKHJ1blF1ZXVlKSB7XG4gICAgLypcbiAgICAgKiBCZWNhdXNlIHdlJ3JlIHVzaW5nIGEgcmVmIGFib3ZlLCB3ZSBuZWVkIHNvbWUgd2F5IHRvIGxldCBSZWFjdCBrbm93IHdoZW4gdG9cbiAgICAgKiBhY3R1YWxseSBwcm9jZXNzIHRoZSBxdWV1ZS4gV2UgaW5jcmVtZW50IHRoaXMgbnVtYmVyIGFueSB0aW1lIHdlIG11dGF0ZSB0aGVcbiAgICAgKiBxdWV1ZSwgY3JlYXRpbmcgYSBuZXcgc3RhdGUgdG8gdHJpZ2dlciB0aGUgbGF5b3V0IGVmZmVjdCBiZWxvdy5cbiAgICAgKiBVc2luZyBhIGJvb2xlYW4gZGlydHkgZmxhZyBoZXJlIGluc3RlYWQgd291bGQgbGVhZCB0byBpc3N1ZXMgcmVsYXRlZCB0b1xuICAgICAqIGF1dG9tYXRpYyBiYXRjaGluZy4gKGh0dHBzOi8vZ2l0aHViLmNvbS94eWZsb3cveHlmbG93L2lzc3Vlcy80Nzc5KVxuICAgICAqL1xuICAgIGNvbnN0IFtzZXJpYWwsIHNldFNlcmlhbF0gPSB1c2VTdGF0ZShCaWdJbnQoMCkpO1xuICAgIC8qXG4gICAgICogQSByZWZlcmVuY2Ugb2YgYWxsIHRoZSBiYXRjaGVkIHVwZGF0ZXMgdG8gcHJvY2VzcyBiZWZvcmUgdGhlIG5leHQgcmVuZGVyLiBXZVxuICAgICAqIHdhbnQgYSByZWZlcmVuY2UgaGVyZSBzbyBtdWx0aXBsZSBzeW5jaHJvbm91cyBjYWxscyB0byBgc2V0Tm9kZXNgIGV0YyBjYW4gYmVcbiAgICAgKiBiYXRjaGVkIHRvZ2V0aGVyLlxuICAgICAqL1xuICAgIGNvbnN0IFtxdWV1ZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVRdWV1ZSgoKSA9PiBzZXRTZXJpYWwobiA9PiBuICsgQmlnSW50KDEpKSkpO1xuICAgIC8qXG4gICAgICogTGF5b3V0IGVmZmVjdHMgYXJlIGd1YXJhbnRlZWQgdG8gcnVuIGJlZm9yZSB0aGUgbmV4dCByZW5kZXIgd2hpY2ggbWVhbnMgd2VcbiAgICAgKiBzaG91bGRuJ3QgcnVuIGludG8gYW55IGlzc3VlcyB3aXRoIHN0YWxlIHN0YXRlIG9yIHdlaXJkIGlzc3VlcyB0aGF0IGNvbWUgZnJvbVxuICAgICAqIHJlbmRlcmluZyB0aGluZ3Mgb25lIGZyYW1lIGxhdGVyIHRoYW4gZXhwZWN0ZWQgKHdlIHVzZWQgdG8gdXNlIGBzZXRUaW1lb3V0YCkuXG4gICAgICovXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXVlSXRlbXMgPSBxdWV1ZS5nZXQoKTtcbiAgICAgICAgaWYgKHF1ZXVlSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBydW5RdWV1ZShxdWV1ZUl0ZW1zKTtcbiAgICAgICAgICAgIHF1ZXVlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9LCBbc2VyaWFsXSk7XG4gICAgcmV0dXJuIHF1ZXVlO1xufVxuZnVuY3Rpb24gY3JlYXRlUXVldWUoY2IpIHtcbiAgICBsZXQgcXVldWUgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6ICgpID0+IHF1ZXVlLFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVzaDogKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNvbnN0IEJhdGNoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIFRoaXMgaXMgYSBjb250ZXh0IHByb3ZpZGVyIHRoYXQgaG9sZHMgYW5kIHByb2Nlc3NlcyB0aGUgbm9kZSBhbmQgZWRnZSB1cGRhdGUgcXVldWVzXG4gKiB0aGF0IGFyZSBuZWVkZWQgdG8gaGFuZGxlIHNldE5vZGVzLCBhZGROb2Rlcywgc2V0RWRnZXMgYW5kIGFkZEVkZ2VzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBCYXRjaFByb3ZpZGVyKHsgY2hpbGRyZW4sIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlSGFuZGxlciA9IHVzZUNhbGxiYWNrKChxdWV1ZUl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgPSBbXSwgc2V0Tm9kZXMsIGhhc0RlZmF1bHROb2Rlcywgb25Ob2Rlc0NoYW5nZSwgbm9kZUxvb2t1cCwgZml0Vmlld1F1ZXVlZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhpcyBpcyBlc3NlbnRpYWxseSBhbiBgQXJyYXkucmVkdWNlYCBpbiBpbXBlcmF0aXZlIGNsb3RoaW5nLiBQcm9jZXNzaW5nXG4gICAgICAgICAqIHRoaXMgcXVldWUgaXMgYSByZWxhdGl2ZWx5IGhvdCBwYXRoIHNvIHdlJ2QgbGlrZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWQgb2ZcbiAgICAgICAgICogYXJyYXkgbWV0aG9kcyB3aGVyZSB3ZSBjYW4uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGVzO1xuICAgICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2YgcXVldWVJdGVtcykge1xuICAgICAgICAgICAgbmV4dCA9IHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nID8gcGF5bG9hZChuZXh0KSA6IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldEVsZW1lbnRzRGlmZkNoYW5nZXMoe1xuICAgICAgICAgICAgaXRlbXM6IG5leHQsXG4gICAgICAgICAgICBsb29rdXA6IG5vZGVMb29rdXAsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICBzZXROb2RlcyhuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gZmlyZSBvbk5vZGVzQ2hhbmdlIGlmIHRoZXJlIGFyZSBjaGFuZ2VzIHRvIHRoZSBub2Rlc1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNoYW5nZXMgdG8gdGhlIG5vZGVzLCB3ZSBzdGlsbCBuZWVkIHRvIGNhbGwgc2V0Tm9kZXNcbiAgICAgICAgICAgIC8vIHRvIHRyaWdnZXIgYSByZS1yZW5kZXIgYW5kIGZpdFZpZXcuXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZpdFZpZXdRdWV1ZWQsIG5vZGVzLCBzZXROb2RlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXROb2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlID0gdXNlUXVldWUobm9kZVF1ZXVlSGFuZGxlcik7XG4gICAgY29uc3QgZWRnZVF1ZXVlSGFuZGxlciA9IHVzZUNhbGxiYWNrKChxdWV1ZUl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSwgc2V0RWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgb25FZGdlc0NoYW5nZSwgZWRnZUxvb2t1cCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgbGV0IG5leHQgPSBlZGdlcztcbiAgICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHF1ZXVlSXRlbXMpIHtcbiAgICAgICAgICAgIG5leHQgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJyA/IHBheWxvYWQobmV4dCkgOiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uRWRnZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2UoZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyh7XG4gICAgICAgICAgICAgICAgaXRlbXM6IG5leHQsXG4gICAgICAgICAgICAgICAgbG9va3VwOiBlZGdlTG9va3VwLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGVkZ2VRdWV1ZSA9IHVzZVF1ZXVlKGVkZ2VRdWV1ZUhhbmRsZXIpO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiAoeyBub2RlUXVldWUsIGVkZ2VRdWV1ZSB9KSwgW10pO1xuICAgIHJldHVybiBqc3goQmF0Y2hDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xufVxuZnVuY3Rpb24gdXNlQmF0Y2hDb250ZXh0KCkge1xuICAgIGNvbnN0IGJhdGNoQ29udGV4dCA9IHVzZUNvbnRleHQoQmF0Y2hDb250ZXh0KTtcbiAgICBpZiAoIWJhdGNoQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUJhdGNoQ29udGV4dCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgQmF0Y2hQcm92aWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gYmF0Y2hDb250ZXh0O1xufVxuXG5jb25zdCBzZWxlY3RvciRrID0gKHMpID0+ICEhcy5wYW5ab29tO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhIFJlYWN0Rmxvd0luc3RhbmNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIG5vZGVzIGFuZCBlZGdlcywgbWFuaXB1bGF0ZSB0aGUgdmlld3BvcnQsIG9yIHF1ZXJ5IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBmbG93LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyB1c2VSZWFjdEZsb3cgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBmdW5jdGlvbiBOb2RlQ291bnRlcigpIHtcbiAqICBjb25zdCByZWFjdEZsb3cgPSB1c2VSZWFjdEZsb3coKTtcbiAqICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDApO1xuICogIGNvbnN0IGNvdW50Tm9kZXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gKiAgICBzZXRDb3VudChyZWFjdEZsb3cuZ2V0Tm9kZXMoKS5sZW5ndGgpO1xuICogICAgLy8geW91IG5lZWQgdG8gcGFzcyBpdCBhcyBhIGRlcGVuZGVuY3kgaWYgeW91IGFyZSB1c2luZyBpdCB3aXRoIHVzZUVmZmVjdCBvciB1c2VDYWxsYmFja1xuICogICAgLy8gYmVjYXVzZSBhdCB0aGUgZmlyc3QgcmVuZGVyLCBpdCdzIG5vdCBpbml0aWFsaXplZCB5ZXQgYW5kIHNvbWUgZnVuY3Rpb25zIG1pZ2h0IG5vdCB3b3JrLlxuICogIH0sIFtyZWFjdEZsb3ddKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIDxidXR0b24gb25DbGljaz17Y291bnROb2Rlc30+VXBkYXRlIGNvdW50PC9idXR0b24+XG4gKiAgICAgIDxwPlRoZXJlIGFyZSB7Y291bnR9IG5vZGVzIGluIHRoZSBmbG93LjwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZVJlYWN0RmxvdygpIHtcbiAgICBjb25zdCB2aWV3cG9ydEhlbHBlciA9IHVzZVZpZXdwb3J0SGVscGVyKCk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGJhdGNoQ29udGV4dCA9IHVzZUJhdGNoQ29udGV4dCgpO1xuICAgIGNvbnN0IHZpZXdwb3J0SW5pdGlhbGl6ZWQgPSB1c2VTdG9yZShzZWxlY3RvciRrKTtcbiAgICBjb25zdCBnZW5lcmFsSGVscGVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGdldEludGVybmFsTm9kZSA9IChpZCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgIGNvbnN0IHNldE5vZGVzID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0RWRnZXMgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgYmF0Y2hDb250ZXh0LmVkZ2VRdWV1ZS5wdXNoKHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZXROb2RlUmVjdCA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBub2RlVG9Vc2UgPSBpc05vZGUobm9kZSkgPyBub2RlIDogbm9kZUxvb2t1cC5nZXQobm9kZS5pZCk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG5vZGVUb1VzZS5wYXJlbnRJZFxuICAgICAgICAgICAgICAgID8gZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uKG5vZGVUb1VzZS5wb3NpdGlvbiwgbm9kZVRvVXNlLm1lYXN1cmVkLCBub2RlVG9Vc2UucGFyZW50SWQsIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4pXG4gICAgICAgICAgICAgICAgOiBub2RlVG9Vc2UucG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCBub2RlV2l0aFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIC4uLm5vZGVUb1VzZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB3aWR0aDogbm9kZVRvVXNlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlVG9Vc2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlVG9Vc2UubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlVG9Vc2UuaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBub2RlVG9SZWN0KG5vZGVXaXRoUG9zaXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVOb2RlID0gKGlkLCBub2RlVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICBzZXROb2RlcygocHJldk5vZGVzKSA9PiBwcmV2Tm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gdHlwZW9mIG5vZGVVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBub2RlVXBkYXRlKG5vZGUpIDogbm9kZVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSAmJiBpc05vZGUobmV4dE5vZGUpID8gbmV4dE5vZGUgOiB7IC4uLm5vZGUsIC4uLm5leHROb2RlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVFZGdlID0gKGlkLCBlZGdlVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICBzZXRFZGdlcygocHJldkVkZ2VzKSA9PiBwcmV2RWRnZXMubWFwKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRFZGdlID0gdHlwZW9mIGVkZ2VVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBlZGdlVXBkYXRlKGVkZ2UpIDogZWRnZVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSAmJiBpc0VkZ2UobmV4dEVkZ2UpID8gbmV4dEVkZ2UgOiB7IC4uLmVkZ2UsIC4uLm5leHRFZGdlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0Tm9kZXM6ICgpID0+IHN0b3JlLmdldFN0YXRlKCkubm9kZXMubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgIGdldE5vZGU6IChpZCkgPT4gZ2V0SW50ZXJuYWxOb2RlKGlkKT8uaW50ZXJuYWxzLnVzZXJOb2RlLFxuICAgICAgICAgICAgZ2V0SW50ZXJuYWxOb2RlLFxuICAgICAgICAgICAgZ2V0RWRnZXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZSB9KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RWRnZTogKGlkKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmVkZ2VMb29rdXAuZ2V0KGlkKSxcbiAgICAgICAgICAgIHNldE5vZGVzLFxuICAgICAgICAgICAgc2V0RWRnZXMsXG4gICAgICAgICAgICBhZGROb2RlczogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaCgobm9kZXMpID0+IFsuLi5ub2RlcywgLi4ubmV3Tm9kZXNdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRFZGdlczogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFZGdlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5lZGdlUXVldWUucHVzaCgoZWRnZXMpID0+IFsuLi5lZGdlcywgLi4ubmV3RWRnZXNdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b09iamVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMgPSBbXSwgZWRnZXMgPSBbXSwgdHJhbnNmb3JtIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBub2Rlczogbm9kZXMubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXM6IGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZSB9KSksXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb20sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVFbGVtZW50czogYXN5bmMgKHsgbm9kZXM6IG5vZGVzVG9SZW1vdmUgPSBbXSwgZWRnZXM6IGVkZ2VzVG9SZW1vdmUgPSBbXSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlcywgZWRnZXMsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzLCBvbkRlbGV0ZSwgb25CZWZvcmVEZWxldGUsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXM6IG1hdGNoaW5nTm9kZXMsIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH0gPSBhd2FpdCBnZXRFbGVtZW50c1RvUmVtb3ZlKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZURlbGV0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNNYXRjaGluZ0VkZ2VzID0gbWF0Y2hpbmdFZGdlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc01hdGNoaW5nTm9kZXMgPSBtYXRjaGluZ05vZGVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhhc01hdGNoaW5nRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBtYXRjaGluZ0VkZ2VzLm1hcChlbGVtZW50VG9SZW1vdmVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBvbkVkZ2VzRGVsZXRlPy4obWF0Y2hpbmdFZGdlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhlZGdlQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNNYXRjaGluZ05vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gbWF0Y2hpbmdOb2Rlcy5tYXAoZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgb25Ob2Rlc0RlbGV0ZT8uKG1hdGNoaW5nTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWF0Y2hpbmdOb2RlcyB8fCBoYXNNYXRjaGluZ0VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlPy4oeyBub2RlczogbWF0Y2hpbmdOb2RlcywgZWRnZXM6IG1hdGNoaW5nRWRnZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRlbGV0ZWROb2RlczogbWF0Y2hpbmdOb2RlcywgZGVsZXRlZEVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYXJ0aWFsIGlzIGRlZmluZWQgYXMgXCJ0aGUgMiBub2Rlcy9hcmVhcyBhcmUgaW50ZXJzZWN0aW5nIHBhcnRpYWxseVwiLlxuICAgICAgICAgICAgICogSWYgYSBpcyBjb250YWluZWQgaW4gYiBvciBiIGlzIGNvbnRhaW5lZCBpbiBhLCB0aGV5IGFyZSBib3RoXG4gICAgICAgICAgICAgKiBjb25zaWRlcmVkIGZ1bGx5IGludGVyc2VjdGluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0SW50ZXJzZWN0aW5nTm9kZXM6IChub2RlT3JSZWN0LCBwYXJ0aWFsbHkgPSB0cnVlLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVjdCA9IGlzUmVjdE9iamVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVjdCA9IGlzUmVjdCA/IG5vZGVPclJlY3QgOiBnZXROb2RlUmVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNOb2Rlc09wdGlvbiA9IG5vZGVzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAobm9kZXMgfHwgc3RvcmUuZ2V0U3RhdGUoKS5ub2RlcykuZmlsdGVyKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsTm9kZSA9IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQobi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUgJiYgIWlzUmVjdCAmJiAobi5pZCA9PT0gbm9kZU9yUmVjdC5pZCB8fCAhaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlUmVjdCA9IG5vZGVUb1JlY3QoaGFzTm9kZXNPcHRpb24gPyBuIDogaW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKGN1cnJOb2RlUmVjdCwgbm9kZVJlY3QpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocGFydGlhbGx5VmlzaWJsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdBcmVhID49IGN1cnJOb2RlUmVjdC53aWR0aCAqIGN1cnJOb2RlUmVjdC5oZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQXJlYSA+PSBub2RlUmVjdC53aWR0aCAqIG5vZGVSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNOb2RlSW50ZXJzZWN0aW5nOiAobm9kZU9yUmVjdCwgYXJlYSwgcGFydGlhbGx5ID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVjdCA9IGlzUmVjdE9iamVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVjdCA9IGlzUmVjdCA/IG5vZGVPclJlY3QgOiBnZXROb2RlUmVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKG5vZGVSZWN0LCBhcmVhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwYXJ0aWFsbHlWaXNpYmxlIHx8XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQXJlYSA+PSBhcmVhLndpZHRoICogYXJlYS5oZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdBcmVhID49IG5vZGVSZWN0LndpZHRoICogbm9kZVJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVOb2RlLFxuICAgICAgICAgICAgdXBkYXRlTm9kZURhdGE6IChpZCwgZGF0YVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGUoaWQsIChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREYXRhID0gdHlwZW9mIGRhdGFVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBkYXRhVXBkYXRlKG5vZGUpIDogZGF0YVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSA/IHsgLi4ubm9kZSwgZGF0YTogbmV4dERhdGEgfSA6IHsgLi4ubm9kZSwgZGF0YTogeyAuLi5ub2RlLmRhdGEsIC4uLm5leHREYXRhIH0gfTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVFZGdlLFxuICAgICAgICAgICAgdXBkYXRlRWRnZURhdGE6IChpZCwgZGF0YVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUVkZ2UoaWQsIChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREYXRhID0gdHlwZW9mIGRhdGFVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBkYXRhVXBkYXRlKGVkZ2UpIDogZGF0YVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSA/IHsgLi4uZWRnZSwgZGF0YTogbmV4dERhdGEgfSA6IHsgLi4uZWRnZSwgZGF0YTogeyAuLi5lZGdlLmRhdGEsIC4uLm5leHREYXRhIH0gfTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXROb2Rlc0JvdW5kczogKG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXROb2Rlc0JvdW5kcyhub2RlcywgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEhhbmRsZUNvbm5lY3Rpb25zOiAoeyB0eXBlLCBpZCwgbm9kZUlkIH0pID0+IEFycmF5LmZyb20oc3RvcmVcbiAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgIC5jb25uZWN0aW9uTG9va3VwLmdldChgJHtub2RlSWR9LSR7dHlwZX0ke2lkID8gYC0ke2lkfWAgOiAnJ31gKVxuICAgICAgICAgICAgICAgID8udmFsdWVzKCkgPz8gW10pLFxuICAgICAgICAgICAgZ2V0Tm9kZUNvbm5lY3Rpb25zOiAoeyB0eXBlLCBoYW5kbGVJZCwgbm9kZUlkIH0pID0+IEFycmF5LmZyb20oc3RvcmVcbiAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgIC5jb25uZWN0aW9uTG9va3VwLmdldChgJHtub2RlSWR9JHt0eXBlID8gKGhhbmRsZUlkID8gYC0ke3R5cGV9LSR7aGFuZGxlSWR9YCA6IGAtJHt0eXBlfWApIDogJyd9YClcbiAgICAgICAgICAgICAgICA/LnZhbHVlcygpID8/IFtdKSxcbiAgICAgICAgICAgIGZpdFZpZXc6IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZWl0aGVyIGNyZWF0ZSBhIG5ldyBQcm9taXNlIG9yIHJldXNlIHRoZSBleGlzdGluZyBvbmVcbiAgICAgICAgICAgICAgICAvLyBFdmVuIGlmIGZpdFZpZXcgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIGEgcm93LCB3ZSBvbmx5IGVuZCB1cCB3aXRoIGEgc2luZ2xlIFByb21pc2VcbiAgICAgICAgICAgICAgICBjb25zdCBmaXRWaWV3UmVzb2x2ZXIgPSBzdG9yZS5nZXRTdGF0ZSgpLmZpdFZpZXdSZXNvbHZlciA/PyB3aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2NoZWR1bGUgYSBmaXRWaWV3IGJ5IHNldHRpbmcgZml0Vmlld1F1ZXVlZCBhbmQgdHJpZ2dlcmluZyBhIHNldE5vZGVzXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBmaXRWaWV3UXVldWVkOiB0cnVlLCBmaXRWaWV3T3B0aW9uczogb3B0aW9ucywgZml0Vmlld1Jlc29sdmVyIH0pO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaCgobm9kZXMpID0+IFsuLi5ub2Rlc10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXRWaWV3UmVzb2x2ZXIucHJvbWlzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmdlbmVyYWxIZWxwZXIsXG4gICAgICAgICAgICAuLi52aWV3cG9ydEhlbHBlcixcbiAgICAgICAgICAgIHZpZXdwb3J0SW5pdGlhbGl6ZWQsXG4gICAgICAgIH07XG4gICAgfSwgW3ZpZXdwb3J0SW5pdGlhbGl6ZWRdKTtcbn1cblxuY29uc3Qgc2VsZWN0ZWQgPSAoaXRlbSkgPT4gaXRlbS5zZWxlY3RlZDtcbmNvbnN0IHdpbiQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4vKipcbiAqIEhvb2sgZm9yIGhhbmRsaW5nIGdsb2JhbCBrZXkgZXZlbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VHbG9iYWxLZXlIYW5kbGVyKHsgZGVsZXRlS2V5Q29kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgZGVsZXRlRWxlbWVudHMgfSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIGNvbnN0IGRlbGV0ZUtleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhkZWxldGVLZXlDb2RlLCB7IGFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyOiBmYWxzZSB9KTtcbiAgICBjb25zdCBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhtdWx0aVNlbGVjdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4kMSB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGVsZXRlS2V5UHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgbm9kZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBkZWxldGVFbGVtZW50cyh7IG5vZGVzOiBub2Rlcy5maWx0ZXIoc2VsZWN0ZWQpLCBlZGdlczogZWRnZXMuZmlsdGVyKHNlbGVjdGVkKSB9KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2RlbGV0ZUtleVByZXNzZWRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG11bHRpU2VsZWN0aW9uQWN0aXZlOiBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgfSk7XG4gICAgfSwgW211bHRpU2VsZWN0aW9uS2V5UHJlc3NlZF0pO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGhhbmRsaW5nIHJlc2l6ZSBldmVudHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZVJlc2l6ZUhhbmRsZXIoZG9tTm9kZSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkb21Ob2RlLmN1cnJlbnQgfHwgIShkb21Ob2RlLmN1cnJlbnQuY2hlY2tWaXNpYmlsaXR5Py4oKSA/PyB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBnZXREaW1lbnNpb25zKGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoc2l6ZS5oZWlnaHQgPT09IDAgfHwgc2l6ZS53aWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMDQnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNCddKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB3aWR0aDogc2l6ZS53aWR0aCB8fCA1MDAsIGhlaWdodDogc2l6ZS5oZWlnaHQgfHwgNTAwIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZG9tTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICB1cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB1cGRhdGVEaW1lbnNpb25zKCkpO1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZU9ic2VydmVyICYmIGRvbU5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW10pO1xufVxuXG5jb25zdCBjb250YWluZXJTdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxufTtcblxuY29uc3Qgc2VsZWN0b3IkaiA9IChzKSA9PiAoe1xuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICBsaWI6IHMubGliLFxuICAgIGNvbm5lY3Rpb25JblByb2dyZXNzOiBzLmNvbm5lY3Rpb24uaW5Qcm9ncmVzcyxcbn0pO1xuZnVuY3Rpb24gWm9vbVBhbmUoeyBvblBhbmVDb250ZXh0TWVudSwgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBwYW5PbkRyYWcgPSB0cnVlLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZSwgY2hpbGRyZW4sIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgcGFuZUNsaWNrRGlzdGFuY2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgem9vbVBhbmUgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCBsaWIsIGNvbm5lY3Rpb25JblByb2dyZXNzIH0gPSB1c2VTdG9yZShzZWxlY3RvciRqLCBzaGFsbG93KTtcbiAgICBjb25zdCB6b29tQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyh6b29tQWN0aXZhdGlvbktleUNvZGUpO1xuICAgIGNvbnN0IHBhblpvb20gPSB1c2VSZWYoKTtcbiAgICB1c2VSZXNpemVIYW5kbGVyKHpvb21QYW5lKTtcbiAgICBjb25zdCBvblRyYW5zZm9ybUNoYW5nZSA9IHVzZUNhbGxiYWNrKCh0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZT8uKHsgeDogdHJhbnNmb3JtWzBdLCB5OiB0cmFuc2Zvcm1bMV0sIHpvb206IHRyYW5zZm9ybVsyXSB9KTtcbiAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWRWaWV3cG9ydCkge1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB0cmFuc2Zvcm0gfSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoem9vbVBhbmUuY3VycmVudCkge1xuICAgICAgICAgICAgcGFuWm9vbS5jdXJyZW50ID0gWFlQYW5ab29tKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiB6b29tUGFuZS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCxcbiAgICAgICAgICAgICAgICBwYW5lQ2xpY2tEaXN0YW5jZSxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlOiAocGFuZURyYWdnaW5nKSA9PiBzdG9yZS5zZXRTdGF0ZSh7IHBhbmVEcmFnZ2luZyB9KSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21TdGFydDogKGV2ZW50LCB2cCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9uVmlld3BvcnRDaGFuZ2VTdGFydCwgb25Nb3ZlU3RhcnQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZVN0YXJ0Py4oZXZlbnQsIHZwKTtcbiAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZVN0YXJ0Py4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tOiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZSwgb25Nb3ZlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmU/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPy4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kOiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZUVuZCwgb25Nb3ZlRW5kIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmVFbmQ/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlRW5kPy4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gcGFuWm9vbS5jdXJyZW50LmdldFZpZXdwb3J0KCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcGFuWm9vbTogcGFuWm9vbS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogW3gsIHksIHpvb21dLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHpvb21QYW5lLmN1cnJlbnQuY2xvc2VzdCgnLnJlYWN0LWZsb3cnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBwYW5ab29tLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcGFuWm9vbS5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgICAgIHpvb21PbkRvdWJsZUNsaWNrLFxuICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICAgICAgcHJldmVudFNjcm9sbGluZyxcbiAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JblByb2dyZXNzLFxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIG9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICB6b29tT25Eb3VibGVDbGljayxcbiAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgIHByZXZlbnRTY3JvbGxpbmcsXG4gICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICBsaWIsXG4gICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgICAgICBjb25uZWN0aW9uSW5Qcm9ncmVzcyxcbiAgICBdKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19yZW5kZXJlclwiLCByZWY6IHpvb21QYW5lLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJGkgPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgdXNlclNlbGVjdGlvblJlY3Q6IHMudXNlclNlbGVjdGlvblJlY3QsXG59KTtcbmZ1bmN0aW9uIFVzZXJTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCB1c2VyU2VsZWN0aW9uUmVjdCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkaSwgc2hhbGxvdyk7XG4gICAgY29uc3QgaXNBY3RpdmUgPSB1c2VyU2VsZWN0aW9uQWN0aXZlICYmIHVzZXJTZWxlY3Rpb25SZWN0O1xuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3NlbGVjdGlvbiByZWFjdC1mbG93X19jb250YWluZXJcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiB1c2VyU2VsZWN0aW9uUmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdXNlclNlbGVjdGlvblJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7dXNlclNlbGVjdGlvblJlY3QueH1weCwgJHt1c2VyU2VsZWN0aW9uUmVjdC55fXB4KWAsXG4gICAgICAgIH0gfSkpO1xufVxuXG5jb25zdCB3cmFwSGFuZGxlciA9IChoYW5kbGVyLCBjb250YWluZXJSZWYpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcj8uKGV2ZW50KTtcbiAgICB9O1xufTtcbmNvbnN0IHNlbGVjdG9yJGggPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBjb25uZWN0aW9uSW5Qcm9ncmVzczogcy5jb25uZWN0aW9uLmluUHJvZ3Jlc3MsXG4gICAgZHJhZ2dpbmc6IHMucGFuZURyYWdnaW5nLFxufSk7XG5mdW5jdGlvbiBQYW5lKHsgaXNTZWxlY3RpbmcsIHNlbGVjdGlvbktleVByZXNzZWQsIHNlbGVjdGlvbk1vZGUgPSBTZWxlY3Rpb25Nb2RlLkZ1bGwsIHBhbk9uRHJhZywgc2VsZWN0aW9uT25EcmFnLCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgb25QYW5lQ2xpY2ssIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgY2hpbGRyZW4sIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCBlbGVtZW50c1NlbGVjdGFibGUsIGRyYWdnaW5nLCBjb25uZWN0aW9uSW5Qcm9ncmVzcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkaCwgc2hhbGxvdyk7XG4gICAgY29uc3QgaGFzQWN0aXZlU2VsZWN0aW9uID0gZWxlbWVudHNTZWxlY3RhYmxlICYmIChpc1NlbGVjdGluZyB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29udGFpbmVyQm91bmRzID0gdXNlUmVmKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlSWRzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRFZGdlSWRzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gICAgLy8gVXNlZCB0byBwcmV2ZW50IGNsaWNrIGV2ZW50cyB3aGVuIHRoZSB1c2VyIGxldHMgZ28gb2YgdGhlIHNlbGVjdGlvbktleSBkdXJpbmcgYSBzZWxlY3Rpb25cbiAgICBjb25zdCBzZWxlY3Rpb25JblByb2dyZXNzID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBzZWxlY3Rpb25TdGFydGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIFdlIHByZXZlbnQgY2xpY2sgZXZlbnRzIHdoZW4gdGhlIHVzZXIgbGV0IGdvIG9mIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIGEgc2VsZWN0aW9uXG4gICAgICAgIC8vIFdlIGFsc28gcHJldmVudCBjbGljayBldmVudHMgd2hlbiBhIGNvbm5lY3Rpb24gaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgaWYgKHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCB8fCBjb25uZWN0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ2xpY2s/LihldmVudCk7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkucmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZz8uaW5jbHVkZXMoMikpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ29udGV4dE1lbnU/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvbldoZWVsID0gb25QYW5lU2Nyb2xsID8gKGV2ZW50KSA9PiBvblBhbmVTY3JvbGwoZXZlbnQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXNldFNlbGVjdGVkRWxlbWVudHMsIGRvbU5vZGUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50ID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghZWxlbWVudHNTZWxlY3RhYmxlIHx8XG4gICAgICAgICAgICAhaXNTZWxlY3RpbmcgfHxcbiAgICAgICAgICAgIGV2ZW50LmJ1dHRvbiAhPT0gMCB8fFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ICE9PSBjb250YWluZXIuY3VycmVudCB8fFxuICAgICAgICAgICAgIWNvbnRhaW5lckJvdW5kcy5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0Py5zZXRQb2ludGVyQ2FwdHVyZT8uKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQubmF0aXZlRXZlbnQsIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50KTtcbiAgICAgICAgcmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0WDogeCxcbiAgICAgICAgICAgICAgICBzdGFydFk6IHksXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uU2VsZWN0aW9uU3RhcnQ/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QsIHRyYW5zZm9ybSwgbm9kZUxvb2t1cCwgZWRnZUxvb2t1cCwgY29ubmVjdGlvbkxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMsIGRlZmF1bHRFZGdlT3B0aW9ucywgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghY29udGFpbmVyQm91bmRzLmN1cnJlbnQgfHwgIXVzZXJTZWxlY3Rpb25SZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB4OiBtb3VzZVgsIHk6IG1vdXNlWSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5uYXRpdmVFdmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICBjb25zdCB7IHN0YXJ0WCwgc3RhcnRZIH0gPSB1c2VyU2VsZWN0aW9uUmVjdDtcbiAgICAgICAgY29uc3QgbmV4dFVzZXJTZWxlY3RSZWN0ID0ge1xuICAgICAgICAgICAgc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZLFxuICAgICAgICAgICAgeDogbW91c2VYIDwgc3RhcnRYID8gbW91c2VYIDogc3RhcnRYLFxuICAgICAgICAgICAgeTogbW91c2VZIDwgc3RhcnRZID8gbW91c2VZIDogc3RhcnRZLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKG1vdXNlWCAtIHN0YXJ0WCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGguYWJzKG1vdXNlWSAtIHN0YXJ0WSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3RlZE5vZGVJZHMgPSBzZWxlY3RlZE5vZGVJZHMuY3VycmVudDtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGVkRWRnZUlkcyA9IHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50O1xuICAgICAgICBzZWxlY3RlZE5vZGVJZHMuY3VycmVudCA9IG5ldyBTZXQoZ2V0Tm9kZXNJbnNpZGUobm9kZUxvb2t1cCwgbmV4dFVzZXJTZWxlY3RSZWN0LCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuUGFydGlhbCwgdHJ1ZSkubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gICAgICAgIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50ID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBlZGdlc1NlbGVjdGFibGUgPSBkZWZhdWx0RWRnZU9wdGlvbnM/LnNlbGVjdGFibGUgPz8gdHJ1ZTtcbiAgICAgICAgLy8gV2UgbG9vayBmb3IgYWxsIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAgZm9yIChjb25zdCBub2RlSWQgb2Ygc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gY29ubmVjdGlvbkxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbnMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgZWRnZUlkIH0gb2YgY29ubmVjdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGdlID0gZWRnZUxvb2t1cC5nZXQoZWRnZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZSAmJiAoZWRnZS5zZWxlY3RhYmxlID8/IGVkZ2VzU2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQuYWRkKGVkZ2VJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlU2V0c0VxdWFsKHByZXZTZWxlY3RlZE5vZGVJZHMsIHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMobm9kZUxvb2t1cCwgc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQsIHRydWUpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlU2V0c0VxdWFsKHByZXZTZWxlY3RlZEVkZ2VJZHMsIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCwgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBuZXh0VXNlclNlbGVjdFJlY3QsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlclVwID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgIXNlbGVjdGlvblN0YXJ0ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldD8ucmVsZWFzZVBvaW50ZXJDYXB0dXJlPy4oZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uUmVjdCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2Ugb25seSB3YW50IHRvIHRyaWdnZXIgY2xpY2sgZnVuY3Rpb25zIHdoZW4gaW4gc2VsZWN0aW9uIG1vZGUgaWZcbiAgICAgICAgICogdGhlIHVzZXIgZGlkIG5vdCBtb3ZlIHRoZSBtb3VzZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdCAmJiBldmVudC50YXJnZXQgPT09IGNvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkNsaWNrPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQuc2l6ZSA+IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBvblNlbGVjdGlvbkVuZD8uKGV2ZW50KTtcbiAgICAgICAgLypcbiAgICAgICAgICogSWYgdGhlIHVzZXIga2VwdCBob2xkaW5nIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgICAqIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHNlbGVjdGlvbkluUHJvZ3Jlc3MsIHNvIHRoZSBuZXh0IGNsaWNrIGV2ZW50IGlzIG5vdCBwcmV2ZW50ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChzZWxlY3Rpb25LZXlQcmVzc2VkIHx8IHNlbGVjdGlvbk9uRHJhZykge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uU3RhcnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBkcmFnZ2FibGUgPSBwYW5PbkRyYWcgPT09IHRydWUgfHwgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoMCkpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19wYW5lJywgeyBkcmFnZ2FibGUsIGRyYWdnaW5nLCBzZWxlY3Rpb246IGlzU2VsZWN0aW5nIH1dKSwgb25DbGljazogaGFzQWN0aXZlU2VsZWN0aW9uID8gdW5kZWZpbmVkIDogd3JhcEhhbmRsZXIob25DbGljaywgY29udGFpbmVyKSwgb25Db250ZXh0TWVudTogd3JhcEhhbmRsZXIob25Db250ZXh0TWVudSwgY29udGFpbmVyKSwgb25XaGVlbDogd3JhcEhhbmRsZXIob25XaGVlbCwgY29udGFpbmVyKSwgb25Qb2ludGVyRW50ZXI6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IHVuZGVmaW5lZCA6IG9uUGFuZU1vdXNlRW50ZXIsIG9uUG9pbnRlckRvd246IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlckRvd24gOiBvblBhbmVNb3VzZU1vdmUsIG9uUG9pbnRlck1vdmU6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlck1vdmUgOiBvblBhbmVNb3VzZU1vdmUsIG9uUG9pbnRlclVwOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyBvblBvaW50ZXJVcCA6IHVuZGVmaW5lZCwgb25Qb2ludGVyTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIHJlZjogY29udGFpbmVyLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBbY2hpbGRyZW4sIGpzeChVc2VyU2VsZWN0aW9uLCB7fSldIH0pKTtcbn1cblxuLypcbiAqIHRoaXMgaGFuZGxlciBpcyBjYWxsZWQgYnlcbiAqIDEuIHRoZSBjbGljayBoYW5kbGVyIHdoZW4gbm9kZSBpcyBub3QgZHJhZ2dhYmxlIG9yIHNlbGVjdE5vZGVzT25EcmFnID0gZmFsc2VcbiAqIG9yXG4gKiAyLiB0aGUgb24gZHJhZyBzdGFydCBoYW5kbGVyIHdoZW4gbm9kZSBpcyBkcmFnZ2FibGUgYW5kIHNlbGVjdE5vZGVzT25EcmFnID0gdHJ1ZVxuICovXG5mdW5jdGlvbiBoYW5kbGVOb2RlQ2xpY2soeyBpZCwgc3RvcmUsIHVuc2VsZWN0ID0gZmFsc2UsIG5vZGVSZWYsIH0pIHtcbiAgICBjb25zdCB7IGFkZFNlbGVjdGVkTm9kZXMsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIG5vZGVMb29rdXAsIG9uRXJyb3IgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTInLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMiddKGlkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgaWYgKCFub2RlLnNlbGVjdGVkKSB7XG4gICAgICAgIGFkZFNlbGVjdGVkTm9kZXMoW2lkXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVuc2VsZWN0IHx8IChub2RlLnNlbGVjdGVkICYmIG11bHRpU2VsZWN0aW9uQWN0aXZlKSkge1xuICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW25vZGVdLCBlZGdlczogW10gfSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBub2RlUmVmPy5jdXJyZW50Py5ibHVyKCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIb29rIGZvciBjYWxsaW5nIFhZRHJhZyBoZWxwZXIgZnJvbSBAeHlmbG93L3N5c3RlbS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlRHJhZyh7IG5vZGVSZWYsIGRpc2FibGVkID0gZmFsc2UsIG5vRHJhZ0NsYXNzTmFtZSwgaGFuZGxlU2VsZWN0b3IsIG5vZGVJZCwgaXNTZWxlY3RhYmxlLCBub2RlQ2xpY2tEaXN0YW5jZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBbZHJhZ2dpbmcsIHNldERyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCB4eURyYWcgPSB1c2VSZWYoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB4eURyYWcuY3VycmVudCA9IFhZRHJhZyh7XG4gICAgICAgICAgICBnZXRTdG9yZUl0ZW1zOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgb25Ob2RlTW91c2VEb3duOiAoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXREcmFnZ2luZyh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdTdG9wOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0RHJhZ2dpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgeHlEcmFnLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHh5RHJhZy5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBub2RlUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBub2RlQ2xpY2tEaXN0YW5jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB4eURyYWcuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtub0RyYWdDbGFzc05hbWUsIGhhbmRsZVNlbGVjdG9yLCBkaXNhYmxlZCwgaXNTZWxlY3RhYmxlLCBub2RlUmVmLCBub2RlSWRdKTtcbiAgICByZXR1cm4gZHJhZ2dpbmc7XG59XG5cbmNvbnN0IHNlbGVjdGVkQW5kRHJhZ2dhYmxlID0gKG5vZGVzRHJhZ2dhYmxlKSA9PiAobikgPT4gbi5zZWxlY3RlZCAmJiAobi5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBuLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbi8qKlxuICogSG9vayBmb3IgdXBkYXRpbmcgbm9kZSBwb3NpdGlvbnMgYnkgcGFzc2luZyBhIGRpcmVjdGlvbiBhbmQgZmFjdG9yXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyBmdW5jdGlvbiBmb3IgdXBkYXRpbmcgbm9kZSBwb3NpdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlQ2FsbGJhY2soKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVFeHRlbnQsIHNuYXBUb0dyaWQsIHNuYXBHcmlkLCBub2Rlc0RyYWdnYWJsZSwgb25FcnJvciwgdXBkYXRlTm9kZVBvc2l0aW9ucywgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3Qgbm9kZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZEFuZERyYWdnYWJsZShub2Rlc0RyYWdnYWJsZSk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGJ5IGRlZmF1bHQgYSBub2RlIG1vdmVzIDVweCBvbiBlYWNoIGtleSBwcmVzc1xuICAgICAgICAgKiBpZiBzbmFwIGdyaWQgaXMgZW5hYmxlZCwgd2UgdXNlIHRoYXQgZm9yIHRoZSB2ZWxvY2l0eVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeFZlbG8gPSBzbmFwVG9HcmlkID8gc25hcEdyaWRbMF0gOiA1O1xuICAgICAgICBjb25zdCB5VmVsbyA9IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFsxXSA6IDU7XG4gICAgICAgIGNvbnN0IHhEaWZmID0gcGFyYW1zLmRpcmVjdGlvbi54ICogeFZlbG8gKiBwYXJhbXMuZmFjdG9yO1xuICAgICAgICBjb25zdCB5RGlmZiA9IHBhcmFtcy5kaXJlY3Rpb24ueSAqIHlWZWxvICogcGFyYW1zLmZhY3RvcjtcbiAgICAgICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgICAgICBpZiAoIWlzU2VsZWN0ZWQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54ICsgeERpZmYsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55ICsgeURpZmYsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBzbmFwUG9zaXRpb24obmV4dFBvc2l0aW9uLCBzbmFwR3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCBwb3NpdGlvbkFic29sdXRlIH0gPSBjYWxjdWxhdGVOb2RlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIG5vZGVJZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbm9kZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA9IHBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICBub2RlVXBkYXRlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhub2RlVXBkYXRlcyk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBtb3ZlU2VsZWN0ZWROb2Rlcztcbn1cblxuY29uc3QgTm9kZUlkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBQcm92aWRlciA9IE5vZGVJZENvbnRleHQuUHJvdmlkZXI7XG5Ob2RlSWRDb250ZXh0LkNvbnN1bWVyO1xuLyoqXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGhvb2sgdG8gZ2V0IHRoZSBpZCBvZiB0aGUgbm9kZSBpdCBpcyB1c2VkIGluc2lkZS4gSXQgaXMgdXNlZnVsXG4gKiBpZiB5b3UgbmVlZCB0aGUgbm9kZSdzIGlkIGRlZXBlciBpbiB0aGUgcmVuZGVyIHRyZWUgYnV0IGRvbid0IHdhbnQgdG8gbWFudWFsbHlcbiAqIGRyaWxsIGRvd24gdGhlIGlkIGFzIGEgcHJvcC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBUaGUgaWQgZm9yIGEgbm9kZSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgdXNlTm9kZUlkIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDdXN0b21Ob2RlKCkge1xuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8c3Bhbj5UaGlzIG5vZGUgaGFzIGFuIGlkIG9mIDwvc3Bhbj5cbiAqICAgICAgPE5vZGVJZERpc3BsYXkgLz5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqXG4gKmZ1bmN0aW9uIE5vZGVJZERpc3BsYXkoKSB7XG4gKiAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gKlxuICogIHJldHVybiA8c3Bhbj57bm9kZUlkfTwvc3Bhbj47XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IHVzZU5vZGVJZCA9ICgpID0+IHtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VDb250ZXh0KE5vZGVJZENvbnRleHQpO1xuICAgIHJldHVybiBub2RlSWQ7XG59O1xuXG5jb25zdCBzZWxlY3RvciRnID0gKHMpID0+ICh7XG4gICAgY29ubmVjdE9uQ2xpY2s6IHMuY29ubmVjdE9uQ2xpY2ssXG4gICAgbm9QYW5DbGFzc05hbWU6IHMubm9QYW5DbGFzc05hbWUsXG4gICAgcmZJZDogcy5yZklkLFxufSk7XG5jb25zdCBjb25uZWN0aW5nU2VsZWN0b3IgPSAobm9kZUlkLCBoYW5kbGVJZCwgdHlwZSkgPT4gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogY2xpY2tIYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICBjb25zdCB7IGZyb21IYW5kbGUsIHRvSGFuZGxlLCBpc1ZhbGlkIH0gPSBjb25uZWN0aW9uO1xuICAgIGNvbnN0IGNvbm5lY3RpbmdUbyA9IHRvSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiB0b0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIHRvSGFuZGxlPy50eXBlID09PSB0eXBlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbm5lY3RpbmdGcm9tOiBmcm9tSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBmcm9tSGFuZGxlPy5pZCA9PT0gaGFuZGxlSWQgJiYgZnJvbUhhbmRsZT8udHlwZSA9PT0gdHlwZSxcbiAgICAgICAgY29ubmVjdGluZ1RvLFxuICAgICAgICBjbGlja0Nvbm5lY3Rpbmc6IGNsaWNrSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBjbGlja0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIGNsaWNrSGFuZGxlPy50eXBlID09PSB0eXBlLFxuICAgICAgICBpc1Bvc3NpYmxlRW5kSGFuZGxlOiBjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgICAgICA/IGZyb21IYW5kbGU/LnR5cGUgIT09IHR5cGVcbiAgICAgICAgICAgIDogbm9kZUlkICE9PSBmcm9tSGFuZGxlPy5ub2RlSWQgfHwgaGFuZGxlSWQgIT09IGZyb21IYW5kbGU/LmlkLFxuICAgICAgICBjb25uZWN0aW9uSW5Qcm9jZXNzOiAhIWZyb21IYW5kbGUsXG4gICAgICAgIGNsaWNrQ29ubmVjdGlvbkluUHJvY2VzczogISFjbGlja0hhbmRsZSxcbiAgICAgICAgdmFsaWQ6IGNvbm5lY3RpbmdUbyAmJiBpc1ZhbGlkLFxuICAgIH07XG59O1xuZnVuY3Rpb24gSGFuZGxlQ29tcG9uZW50KHsgdHlwZSA9ICdzb3VyY2UnLCBwb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgaXNWYWxpZENvbm5lY3Rpb24sIGlzQ29ubmVjdGFibGUgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlU3RhcnQgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlRW5kID0gdHJ1ZSwgaWQsIG9uQ29ubmVjdCwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgb25Nb3VzZURvd24sIG9uVG91Y2hTdGFydCwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCBoYW5kbGVJZCA9IGlkIHx8IG51bGw7XG4gICAgY29uc3QgaXNUYXJnZXQgPSB0eXBlID09PSAndGFyZ2V0JztcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgeyBjb25uZWN0T25DbGljaywgbm9QYW5DbGFzc05hbWUsIHJmSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGcsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHsgY29ubmVjdGluZ0Zyb20sIGNvbm5lY3RpbmdUbywgY2xpY2tDb25uZWN0aW5nLCBpc1Bvc3NpYmxlRW5kSGFuZGxlLCBjb25uZWN0aW9uSW5Qcm9jZXNzLCBjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MsIHZhbGlkLCB9ID0gdXNlU3RvcmUoY29ubmVjdGluZ1NlbGVjdG9yKG5vZGVJZCwgaGFuZGxlSWQsIHR5cGUpLCBzaGFsbG93KTtcbiAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDEwJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTAnXSgpKTtcbiAgICB9XG4gICAgY29uc3Qgb25Db25uZWN0RXh0ZW5kZWQgPSAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdEVkZ2VPcHRpb25zLCBvbkNvbm5lY3Q6IG9uQ29ubmVjdEFjdGlvbiwgaGFzRGVmYXVsdEVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBlZGdlUGFyYW1zID0ge1xuICAgICAgICAgICAgLi4uZGVmYXVsdEVkZ2VPcHRpb25zLFxuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzLCBzZXRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHNldEVkZ2VzKGFkZEVkZ2UoZWRnZVBhcmFtcywgZWRnZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBvbkNvbm5lY3RBY3Rpb24/LihlZGdlUGFyYW1zKTtcbiAgICAgICAgb25Db25uZWN0Py4oZWRnZVBhcmFtcyk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNNb3VzZVRyaWdnZXJlZCA9IGlzTW91c2VFdmVudChldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RhYmxlU3RhcnQgJiZcbiAgICAgICAgICAgICgoaXNNb3VzZVRyaWdnZXJlZCAmJiBldmVudC5idXR0b24gPT09IDApIHx8ICFpc01vdXNlVHJpZ2dlcmVkKSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0b3JlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIFhZSGFuZGxlLm9uUG9pbnRlckRvd24oZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVEb21Ob2RlOiBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgICAgIGF1dG9QYW5PbkNvbm5lY3Q6IGN1cnJlbnRTdG9yZS5hdXRvUGFuT25Db25uZWN0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlOiBjdXJyZW50U3RvcmUuY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvblJhZGl1czogY3VycmVudFN0b3JlLmNvbm5lY3Rpb25SYWRpdXMsXG4gICAgICAgICAgICAgICAgZG9tTm9kZTogY3VycmVudFN0b3JlLmRvbU5vZGUsXG4gICAgICAgICAgICAgICAgbm9kZUxvb2t1cDogY3VycmVudFN0b3JlLm5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgbGliOiBjdXJyZW50U3RvcmUubGliLFxuICAgICAgICAgICAgICAgIGlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGhhbmRsZUlkLFxuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBmbG93SWQ6IGN1cnJlbnRTdG9yZS5yZklkLFxuICAgICAgICAgICAgICAgIHBhbkJ5OiBjdXJyZW50U3RvcmUucGFuQnksXG4gICAgICAgICAgICAgICAgY2FuY2VsQ29ubmVjdGlvbjogY3VycmVudFN0b3JlLmNhbmNlbENvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgb25Db25uZWN0U3RhcnQ6IGN1cnJlbnRTdG9yZS5vbkNvbm5lY3RTdGFydCxcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3RFbmQ6IGN1cnJlbnRTdG9yZS5vbkNvbm5lY3RFbmQsXG4gICAgICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbjogY3VycmVudFN0b3JlLnVwZGF0ZUNvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgb25Db25uZWN0OiBvbkNvbm5lY3RFeHRlbmRlZCxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb24gfHwgY3VycmVudFN0b3JlLmlzVmFsaWRDb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgIGdldFRyYW5zZm9ybTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgZ2V0RnJvbUhhbmRsZTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5jb25uZWN0aW9uLmZyb21IYW5kbGUsXG4gICAgICAgICAgICAgICAgYXV0b1BhblNwZWVkOiBjdXJyZW50U3RvcmUuYXV0b1BhblNwZWVkLFxuICAgICAgICAgICAgICAgIGRyYWdUaHJlc2hvbGQ6IGN1cnJlbnRTdG9yZS5jb25uZWN0aW9uRHJhZ1RocmVzaG9sZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc01vdXNlVHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICBvbk1vdXNlRG93bj8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydD8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25DbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kLCBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSwgY29ubmVjdGlvbk1vZGUsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvblN0b3JlLCBsaWIsIHJmSWQ6IGZsb3dJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbjogY29ubmVjdGlvblN0YXRlLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFub2RlSWQgfHwgKCFjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSAmJiAhaXNDb25uZWN0YWJsZVN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUpIHtcbiAgICAgICAgICAgIG9uQ2xpY2tDb25uZWN0U3RhcnQ/LihldmVudC5uYXRpdmVFdmVudCwgeyBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlOiB0eXBlIH0pO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogeyBub2RlSWQsIHR5cGUsIGlkOiBoYW5kbGVJZCB9IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvYyA9IGdldEhvc3RGb3JFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciA9IGlzVmFsaWRDb25uZWN0aW9uIHx8IGlzVmFsaWRDb25uZWN0aW9uU3RvcmU7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbiwgaXNWYWxpZCB9ID0gWFlIYW5kbGUuaXNWYWxpZChldmVudC5uYXRpdmVFdmVudCwge1xuICAgICAgICAgICAgaGFuZGxlOiB7XG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIGlkOiBoYW5kbGVJZCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgZnJvbU5vZGVJZDogY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUubm9kZUlkLFxuICAgICAgICAgICAgZnJvbUhhbmRsZUlkOiBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZS5pZCB8fCBudWxsLFxuICAgICAgICAgICAgZnJvbVR5cGU6IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLnR5cGUsXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyLFxuICAgICAgICAgICAgZmxvd0lkLFxuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1ZhbGlkICYmIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIG9uQ29ubmVjdEV4dGVuZGVkKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25DbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICBkZWxldGUgY29ubmVjdGlvbkNsb25lLmluUHJvZ3Jlc3M7XG4gICAgICAgIGNvbm5lY3Rpb25DbG9uZS50b1Bvc2l0aW9uID0gY29ubmVjdGlvbkNsb25lLnRvSGFuZGxlID8gY29ubmVjdGlvbkNsb25lLnRvSGFuZGxlLnBvc2l0aW9uIDogbnVsbDtcbiAgICAgICAgb25DbGlja0Nvbm5lY3RFbmQ/LihldmVudCwgY29ubmVjdGlvbkNsb25lKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogbnVsbCB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgXCJkYXRhLWhhbmRsZWlkXCI6IGhhbmRsZUlkLCBcImRhdGEtbm9kZWlkXCI6IG5vZGVJZCwgXCJkYXRhLWhhbmRsZXBvc1wiOiBwb3NpdGlvbiwgXCJkYXRhLWlkXCI6IGAke3JmSWR9LSR7bm9kZUlkfS0ke2hhbmRsZUlkfS0ke3R5cGV9YCwgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAncmVhY3QtZmxvd19faGFuZGxlJyxcbiAgICAgICAgICAgIGByZWFjdC1mbG93X19oYW5kbGUtJHtwb3NpdGlvbn1gLFxuICAgICAgICAgICAgJ25vZHJhZycsXG4gICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICFpc1RhcmdldCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlc3RhcnQ6IGlzQ29ubmVjdGFibGVTdGFydCxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZWVuZDogaXNDb25uZWN0YWJsZUVuZCxcbiAgICAgICAgICAgICAgICBjbGlja2Nvbm5lY3Rpbmc6IGNsaWNrQ29ubmVjdGluZyxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW5nZnJvbTogY29ubmVjdGluZ0Zyb20sXG4gICAgICAgICAgICAgICAgY29ubmVjdGluZ3RvOiBjb25uZWN0aW5nVG8sXG4gICAgICAgICAgICAgICAgdmFsaWQsXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBzaG93cyB3aGVyZSB5b3UgY2FuIHN0YXJ0IGEgY29ubmVjdGlvbiBmcm9tXG4gICAgICAgICAgICAgICAgICogYW5kIHdoZXJlIHlvdSBjYW4gZW5kIGl0IHdoaWxlIGNvbm5lY3RpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uaW5kaWNhdG9yOiBpc0Nvbm5lY3RhYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICghY29ubmVjdGlvbkluUHJvY2VzcyB8fCBpc1Bvc3NpYmxlRW5kSGFuZGxlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoY29ubmVjdGlvbkluUHJvY2VzcyB8fCBjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MgPyBpc0Nvbm5lY3RhYmxlRW5kIDogaXNDb25uZWN0YWJsZVN0YXJ0KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLCBvbk1vdXNlRG93bjogb25Qb2ludGVyRG93biwgb25Ub3VjaFN0YXJ0OiBvblBvaW50ZXJEb3duLCBvbkNsaWNrOiBjb25uZWN0T25DbGljayA/IG9uQ2xpY2sgOiB1bmRlZmluZWQsIHJlZjogcmVmLCAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuLyoqXG4gKiBUaGUgYDxIYW5kbGUgLz5gIGNvbXBvbmVudCBpcyB1c2VkIGluIHlvdXIgW2N1c3RvbSBub2Rlc10oL2xlYXJuL2N1c3RvbWl6YXRpb24vY3VzdG9tLW5vZGVzKVxuICogdG8gZGVmaW5lIGNvbm5lY3Rpb24gcG9pbnRzLlxuICpcbiAqQHB1YmxpY1xuICpcbiAqQGV4YW1wbGVcbiAqXG4gKmBgYGpzeFxuICppbXBvcnQgeyBIYW5kbGUsIFBvc2l0aW9uIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZnVuY3Rpb24gQ3VzdG9tTm9kZSh7IGRhdGEgfSkge1xuICogIHJldHVybiAoXG4gKiAgICA8PlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4IDIwcHgnIH19PlxuICogICAgICAgIHtkYXRhLmxhYmVsfVxuICogICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpgYGBcbiAqL1xuY29uc3QgSGFuZGxlID0gbWVtbyhmaXhlZEZvcndhcmRSZWYoSGFuZGxlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIElucHV0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtkYXRhPy5sYWJlbCwganN4KEhhbmRsZSwgeyB0eXBlOiBcInNvdXJjZVwiLCBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSldIH0pKTtcbn1cblxuZnVuY3Rpb24gRGVmYXVsdE5vZGUoeyBkYXRhLCBpc0Nvbm5lY3RhYmxlLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goSGFuZGxlLCB7IHR5cGU6IFwidGFyZ2V0XCIsIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSwgZGF0YT8ubGFiZWwsIGpzeChIYW5kbGUsIHsgdHlwZTogXCJzb3VyY2VcIiwgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pXSB9KSk7XG59XG5cbmZ1bmN0aW9uIEdyb3VwTm9kZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gT3V0cHV0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goSGFuZGxlLCB7IHR5cGU6IFwidGFyZ2V0XCIsIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSwgZGF0YT8ubGFiZWxdIH0pKTtcbn1cblxuY29uc3QgYXJyb3dLZXlEaWZmcyA9IHtcbiAgICBBcnJvd1VwOiB7IHg6IDAsIHk6IC0xIH0sXG4gICAgQXJyb3dEb3duOiB7IHg6IDAsIHk6IDEgfSxcbiAgICBBcnJvd0xlZnQ6IHsgeDogLTEsIHk6IDAgfSxcbiAgICBBcnJvd1JpZ2h0OiB7IHg6IDEsIHk6IDAgfSxcbn07XG5jb25zdCBidWlsdGluTm9kZVR5cGVzID0ge1xuICAgIGlucHV0OiBJbnB1dE5vZGUsXG4gICAgZGVmYXVsdDogRGVmYXVsdE5vZGUsXG4gICAgb3V0cHV0OiBPdXRwdXROb2RlLFxuICAgIGdyb3VwOiBHcm91cE5vZGUsXG59O1xuZnVuY3Rpb24gZ2V0Tm9kZUlubGluZVN0eWxlRGltZW5zaW9ucyhub2RlKSB7XG4gICAgaWYgKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyBub2RlLnN0eWxlPy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IG5vZGUuc3R5bGU/LmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IG5vZGUud2lkdGggPz8gbm9kZS5zdHlsZT8ud2lkdGgsXG4gICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgPz8gbm9kZS5zdHlsZT8uaGVpZ2h0LFxuICAgIH07XG59XG5cbmNvbnN0IHNlbGVjdG9yJGYgPSAocykgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgeCwgeSB9ID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhzLm5vZGVMb29rdXAsIHtcbiAgICAgICAgZmlsdGVyOiAobm9kZSkgPT4gISFub2RlLnNlbGVjdGVkLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBpc051bWVyaWMod2lkdGgpID8gd2lkdGggOiBudWxsLFxuICAgICAgICBoZWlnaHQ6IGlzTnVtZXJpYyhoZWlnaHQpID8gaGVpZ2h0IDogbnVsbCxcbiAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICB0cmFuc2Zvcm1TdHJpbmc6IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSkgdHJhbnNsYXRlKCR7eH1weCwke3l9cHgpYCxcbiAgICB9O1xufTtcbmZ1bmN0aW9uIE5vZGVzU2VsZWN0aW9uKHsgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB0cmFuc2Zvcm1TdHJpbmcsIHVzZXJTZWxlY3Rpb25BY3RpdmUgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGYsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZUtleWJvYXJkQTExeSkge1xuICAgICAgICAgICAgbm9kZVJlZi5jdXJyZW50Py5mb2N1cyh7XG4gICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2Rpc2FibGVLZXlib2FyZEExMXldKTtcbiAgICB1c2VEcmFnKHtcbiAgICAgICAgbm9kZVJlZixcbiAgICB9KTtcbiAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IG9uU2VsZWN0aW9uQ29udGV4dE1lbnVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVzLmZpbHRlcigobikgPT4gbi5zZWxlY3RlZCk7XG4gICAgICAgICAgICBvblNlbGVjdGlvbkNvbnRleHRNZW51KGV2ZW50LCBzZWxlY3RlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbktleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcnJvd0tleURpZmZzLCBldmVudC5rZXkpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbW92ZVNlbGVjdGVkTm9kZXMoe1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogYXJyb3dLZXlEaWZmc1tldmVudC5rZXldLFxuICAgICAgICAgICAgICAgIGZhY3RvcjogZXZlbnQuc2hpZnRLZXkgPyA0IDogMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19ub2Rlc3NlbGVjdGlvbicsICdyZWFjdC1mbG93X19jb250YWluZXInLCBub1BhbkNsYXNzTmFtZV0pLCBzdHlsZToge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1TdHJpbmcsXG4gICAgICAgIH0sIGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyByZWY6IG5vZGVSZWYsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19ub2Rlc3NlbGVjdGlvbi1yZWN0XCIsIG9uQ29udGV4dE1lbnU6IG9uQ29udGV4dE1lbnUsIHRhYkluZGV4OiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogLTEsIG9uS2V5RG93bjogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IG9uS2V5RG93biwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB9IH0pIH0pKTtcbn1cblxuY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG5jb25zdCBzZWxlY3RvciRlID0gKHMpID0+IHtcbiAgICByZXR1cm4geyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogcy5ub2Rlc1NlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlIH07XG59O1xuZnVuY3Rpb24gRmxvd1JlbmRlcmVyQ29tcG9uZW50KHsgY2hpbGRyZW4sIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIHBhbmVDbGlja0Rpc3RhbmNlLCBkZWxldGVLZXlDb2RlLCBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaCwgcGFuT25TY3JvbGw6IF9wYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnOiBfcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZywgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0LCB9KSB7XG4gICAgY29uc3QgeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHNlbGVjdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4gfSk7XG4gICAgY29uc3QgcGFuQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhwYW5BY3RpdmF0aW9uS2V5Q29kZSwgeyB0YXJnZXQ6IHdpbiB9KTtcbiAgICBjb25zdCBwYW5PbkRyYWcgPSBwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCBfcGFuT25EcmFnO1xuICAgIGNvbnN0IHBhbk9uU2Nyb2xsID0gcGFuQWN0aXZhdGlvbktleVByZXNzZWQgfHwgX3Bhbk9uU2Nyb2xsO1xuICAgIGNvbnN0IF9zZWxlY3Rpb25PbkRyYWcgPSBzZWxlY3Rpb25PbkRyYWcgJiYgcGFuT25EcmFnICE9PSB0cnVlO1xuICAgIGNvbnN0IGlzU2VsZWN0aW5nID0gc2VsZWN0aW9uS2V5UHJlc3NlZCB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlIHx8IF9zZWxlY3Rpb25PbkRyYWc7XG4gICAgdXNlR2xvYmFsS2V5SGFuZGxlcih7IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSB9KTtcbiAgICByZXR1cm4gKGpzeChab29tUGFuZSwgeyBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGw6IHpvb21PblNjcm9sbCwgem9vbU9uUGluY2g6IHpvb21PblBpbmNoLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljazogem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZzogIXNlbGVjdGlvbktleVByZXNzZWQgJiYgcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub1doZWVsQ2xhc3NOYW1lOiBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0OiBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBjaGlsZHJlbjoganN4cyhQYW5lLCB7IG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGw6IG9uUGFuZVNjcm9sbCwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIGlzU2VsZWN0aW5nOiAhIWlzU2VsZWN0aW5nLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBzZWxlY3Rpb25LZXlQcmVzc2VkOiBzZWxlY3Rpb25LZXlQcmVzc2VkLCBzZWxlY3Rpb25PbkRyYWc6IF9zZWxlY3Rpb25PbkRyYWcsIGNoaWxkcmVuOiBbY2hpbGRyZW4sIG5vZGVzU2VsZWN0aW9uQWN0aXZlICYmIChqc3goTm9kZXNTZWxlY3Rpb24sIHsgb25TZWxlY3Rpb25Db250ZXh0TWVudTogb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pKV0gfSkgfSkpO1xufVxuRmxvd1JlbmRlcmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0Zsb3dSZW5kZXJlcic7XG5jb25zdCBGbG93UmVuZGVyZXIgPSBtZW1vKEZsb3dSZW5kZXJlckNvbXBvbmVudCk7XG5cbmNvbnN0IHNlbGVjdG9yJGQgPSAob25seVJlbmRlclZpc2libGUpID0+IChzKSA9PiB7XG4gICAgcmV0dXJuIG9ubHlSZW5kZXJWaXNpYmxlXG4gICAgICAgID8gZ2V0Tm9kZXNJbnNpZGUocy5ub2RlTG9va3VwLCB7IHg6IDAsIHk6IDAsIHdpZHRoOiBzLndpZHRoLCBoZWlnaHQ6IHMuaGVpZ2h0IH0sIHMudHJhbnNmb3JtLCB0cnVlKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpXG4gICAgICAgIDogQXJyYXkuZnJvbShzLm5vZGVMb29rdXAua2V5cygpKTtcbn07XG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIHZpc2libGUgbm9kZSBpZHMgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gb25seVJlbmRlclZpc2libGVcbiAqIEByZXR1cm5zIGFycmF5IHdpdGggdmlzaWJsZSBub2RlIGlkc1xuICovXG5mdW5jdGlvbiB1c2VWaXNpYmxlTm9kZUlkcyhvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VTdG9yZSh1c2VDYWxsYmFjayhzZWxlY3RvciRkKG9ubHlSZW5kZXJWaXNpYmxlKSwgW29ubHlSZW5kZXJWaXNpYmxlXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2RlSWRzO1xufVxuXG5jb25zdCBzZWxlY3RvciRjID0gKHMpID0+IHMudXBkYXRlTm9kZUludGVybmFscztcbmZ1bmN0aW9uIHVzZVJlc2l6ZU9ic2VydmVyKCkge1xuICAgIGNvbnN0IHVwZGF0ZU5vZGVJbnRlcm5hbHMgPSB1c2VTdG9yZShzZWxlY3RvciRjKTtcbiAgICBjb25zdCBbcmVzaXplT2JzZXJ2ZXJdID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGVudHJ5LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnNldChpZCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUVsZW1lbnQ6IGVudHJ5LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtyZXNpemVPYnNlcnZlcl0pO1xuICAgIHJldHVybiByZXNpemVPYnNlcnZlcjtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGhhbmRsZSB0aGUgcmVzaXplIG9ic2VydmF0aW9uICsgaW50ZXJuYWwgdXBkYXRlcyBmb3IgdGhlIHBhc3NlZCBub2RlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgbm9kZVJlZiAtIHJlZmVyZW5jZSB0byB0aGUgbm9kZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVPYnNlcnZlcih7IG5vZGUsIG5vZGVUeXBlLCBoYXNEaW1lbnNpb25zLCByZXNpemVPYnNlcnZlciwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IG9ic2VydmVkTm9kZSA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBwcmV2U291cmNlUG9zaXRpb24gPSB1c2VSZWYobm9kZS5zb3VyY2VQb3NpdGlvbik7XG4gICAgY29uc3QgcHJldlRhcmdldFBvc2l0aW9uID0gdXNlUmVmKG5vZGUudGFyZ2V0UG9zaXRpb24pO1xuICAgIGNvbnN0IHByZXZUeXBlID0gdXNlUmVmKG5vZGVUeXBlKTtcbiAgICBjb25zdCBpc0luaXRpYWxpemVkID0gaGFzRGltZW5zaW9ucyAmJiAhIW5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcztcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobm9kZVJlZi5jdXJyZW50ICYmICFub2RlLmhpZGRlbiAmJiAoIWlzSW5pdGlhbGl6ZWQgfHwgb2JzZXJ2ZWROb2RlLmN1cnJlbnQgIT09IG5vZGVSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlZE5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy51bm9ic2VydmUob2JzZXJ2ZWROb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/Lm9ic2VydmUobm9kZVJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIG9ic2VydmVkTm9kZS5jdXJyZW50ID0gbm9kZVJlZi5jdXJyZW50O1xuICAgICAgICB9XG4gICAgfSwgW2lzSW5pdGlhbGl6ZWQsIG5vZGUuaGlkZGVuXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlZE5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy51bm9ic2VydmUob2JzZXJ2ZWROb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVkTm9kZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG5vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHdoZW4gdGhlIHVzZXIgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VzIHRoZSBzb3VyY2Ugb3IgaGFuZGxlIHBvc2l0aW9uLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaW50ZXJuYWxzXG4gICAgICAgICAgICAgKiB0byBtYWtlIHN1cmUgdGhlIGVkZ2VzIGFyZSB1cGRhdGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB0eXBlQ2hhbmdlZCA9IHByZXZUeXBlLmN1cnJlbnQgIT09IG5vZGVUeXBlO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9zQ2hhbmdlZCA9IHByZXZTb3VyY2VQb3NpdGlvbi5jdXJyZW50ICE9PSBub2RlLnNvdXJjZVBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zQ2hhbmdlZCA9IHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ICE9PSBub2RlLnRhcmdldFBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGVDaGFuZ2VkIHx8IHNvdXJjZVBvc0NoYW5nZWQgfHwgdGFyZ2V0UG9zQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByZXZUeXBlLmN1cnJlbnQgPSBub2RlVHlwZTtcbiAgICAgICAgICAgICAgICBwcmV2U291cmNlUG9zaXRpb24uY3VycmVudCA9IG5vZGUuc291cmNlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgcHJldlRhcmdldFBvc2l0aW9uLmN1cnJlbnQgPSBub2RlLnRhcmdldFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgIC5nZXRTdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIC51cGRhdGVOb2RlSW50ZXJuYWxzKG5ldyBNYXAoW1tub2RlLmlkLCB7IGlkOiBub2RlLmlkLCBub2RlRWxlbWVudDogbm9kZVJlZi5jdXJyZW50LCBmb3JjZTogdHJ1ZSB9XV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtub2RlLmlkLCBub2RlVHlwZSwgbm9kZS5zb3VyY2VQb3NpdGlvbiwgbm9kZS50YXJnZXRQb3NpdGlvbl0pO1xuICAgIHJldHVybiBub2RlUmVmO1xufVxuXG5mdW5jdGlvbiBOb2RlV3JhcHBlcih7IGlkLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmUsIG9uQ29udGV4dE1lbnUsIG9uRG91YmxlQ2xpY2ssIG5vZGVzRHJhZ2dhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCByZXNpemVPYnNlcnZlciwgbm9EcmFnQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgcmZJZCwgbm9kZVR5cGVzLCBub2RlQ2xpY2tEaXN0YW5jZSwgb25FcnJvciwgfSkge1xuICAgIGNvbnN0IHsgbm9kZSwgaW50ZXJuYWxzLCBpc1BhcmVudCB9ID0gdXNlU3RvcmUoKHMpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBpc1BhcmVudCA9IHMucGFyZW50TG9va3VwLmhhcyhpZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgaW50ZXJuYWxzOiBub2RlLmludGVybmFscyxcbiAgICAgICAgICAgIGlzUGFyZW50LFxuICAgICAgICB9O1xuICAgIH0sIHNoYWxsb3cpO1xuICAgIGxldCBub2RlVHlwZSA9IG5vZGUudHlwZSB8fCAnZGVmYXVsdCc7XG4gICAgbGV0IE5vZGVDb21wb25lbnQgPSBub2RlVHlwZXM/Lltub2RlVHlwZV0gfHwgYnVpbHRpbk5vZGVUeXBlc1tub2RlVHlwZV07XG4gICAgaWYgKE5vZGVDb21wb25lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbkVycm9yPy4oJzAwMycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAzJ10obm9kZVR5cGUpKTtcbiAgICAgICAgbm9kZVR5cGUgPSAnZGVmYXVsdCc7XG4gICAgICAgIE5vZGVDb21wb25lbnQgPSBub2RlVHlwZXM/LlsnZGVmYXVsdCddIHx8IGJ1aWx0aW5Ob2RlVHlwZXMuZGVmYXVsdDtcbiAgICB9XG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIShub2RlLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG5vZGUuZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9ICEhKG5vZGUuc2VsZWN0YWJsZSB8fCAoZWxlbWVudHNTZWxlY3RhYmxlICYmIHR5cGVvZiBub2RlLnNlbGVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNDb25uZWN0YWJsZSA9ICEhKG5vZGUuY29ubmVjdGFibGUgfHwgKG5vZGVzQ29ubmVjdGFibGUgJiYgdHlwZW9mIG5vZGUuY29ubmVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNGb2N1c2FibGUgPSAhIShub2RlLmZvY3VzYWJsZSB8fCAobm9kZXNGb2N1c2FibGUgJiYgdHlwZW9mIG5vZGUuZm9jdXNhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBoYXNEaW1lbnNpb25zID0gbm9kZUhhc0RpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3Qgbm9kZVJlZiA9IHVzZU5vZGVPYnNlcnZlcih7IG5vZGUsIG5vZGVUeXBlLCBoYXNEaW1lbnNpb25zLCByZXNpemVPYnNlcnZlciB9KTtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHVzZURyYWcoe1xuICAgICAgICBub2RlUmVmLFxuICAgICAgICBkaXNhYmxlZDogbm9kZS5oaWRkZW4gfHwgIWlzRHJhZ2dhYmxlLFxuICAgICAgICBub0RyYWdDbGFzc05hbWUsXG4gICAgICAgIGhhbmRsZVNlbGVjdG9yOiBub2RlLmRyYWdIYW5kbGUsXG4gICAgICAgIG5vZGVJZDogaWQsXG4gICAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgICAgbm9kZUNsaWNrRGlzdGFuY2UsXG4gICAgfSk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpO1xuICAgIGlmIChub2RlLmhpZGRlbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZURpbWVuc2lvbnMgPSBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBpbmxpbmVEaW1lbnNpb25zID0gZ2V0Tm9kZUlubGluZVN0eWxlRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBoYXNQb2ludGVyRXZlbnRzID0gaXNTZWxlY3RhYmxlIHx8IGlzRHJhZ2dhYmxlIHx8IG9uQ2xpY2sgfHwgb25Nb3VzZUVudGVyIHx8IG9uTW91c2VNb3ZlIHx8IG9uTW91c2VMZWF2ZTtcbiAgICBjb25zdCBvbk1vdXNlRW50ZXJIYW5kbGVyID0gb25Nb3VzZUVudGVyXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbk1vdXNlRW50ZXIoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlSGFuZGxlciA9IG9uTW91c2VNb3ZlXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbk1vdXNlTW92ZShldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlSGFuZGxlciA9IG9uTW91c2VMZWF2ZVxuICAgICAgICA/IChldmVudCkgPT4gb25Nb3VzZUxlYXZlKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkNvbnRleHRNZW51SGFuZGxlciA9IG9uQ29udGV4dE1lbnVcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uQ29udGV4dE1lbnUoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uRG91YmxlQ2xpY2tIYW5kbGVyID0gb25Eb3VibGVDbGlja1xuICAgICAgICA/IChldmVudCkgPT4gb25Eb3VibGVDbGljayhldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25TZWxlY3ROb2RlSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNlbGVjdE5vZGVzT25EcmFnLCBub2RlRHJhZ1RocmVzaG9sZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKGlzU2VsZWN0YWJsZSAmJiAoIXNlbGVjdE5vZGVzT25EcmFnIHx8ICFpc0RyYWdnYWJsZSB8fCBub2RlRHJhZ1RocmVzaG9sZCA+IDApKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogdGhpcyBoYW5kbGVyIGdldHMgY2FsbGVkIGJ5IFhZRHJhZyBvbiBkcmFnIHN0YXJ0IHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9dHJ1ZVxuICAgICAgICAgICAgICogaGVyZSB3ZSBvbmx5IG5lZWQgdG8gY2FsbCBpdCB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPWZhbHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChpc0lucHV0RE9NTm9kZShldmVudC5uYXRpdmVFdmVudCkgfHwgZGlzYWJsZUtleWJvYXJkQTExeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgdW5zZWxlY3QgPSBldmVudC5rZXkgPT09ICdFc2NhcGUnO1xuICAgICAgICAgICAgaGFuZGxlTm9kZUNsaWNrKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICB1bnNlbGVjdCxcbiAgICAgICAgICAgICAgICBub2RlUmVmLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEcmFnZ2FibGUgJiYgbm9kZS5zZWxlY3RlZCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJyb3dLZXlEaWZmcywgZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgLy8gcHJldmVudCBkZWZhdWx0IHNjcm9sbGluZyBiZWhhdmlvciBvbiBhcnJvdyBrZXkgcHJlc3Mgd2hlbiBub2RlIGlzIG1vdmVkXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY29uc3QgeyBhcmlhTGFiZWxDb25maWcgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYXJpYUxpdmVNZXNzYWdlOiBhcmlhTGFiZWxDb25maWdbJ25vZGUuYTExeURlc2NyaXB0aW9uLmFyaWFMaXZlTWVzc2FnZSddKHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBldmVudC5rZXkucmVwbGFjZSgnQXJyb3cnLCAnJykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgeDogfn5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54LFxuICAgICAgICAgICAgICAgICAgICB5OiB+fmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vdmVTZWxlY3RlZE5vZGVzKHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGFycm93S2V5RGlmZnNbZXZlbnQua2V5XSxcbiAgICAgICAgICAgICAgICBmYWN0b3I6IGV2ZW50LnNoaWZ0S2V5ID8gNCA6IDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25Gb2N1cyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGVLZXlib2FyZEExMXkgfHwgIW5vZGVSZWYuY3VycmVudD8ubWF0Y2hlcygnOmZvY3VzLXZpc2libGUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCB3aWR0aCwgaGVpZ2h0LCBhdXRvUGFuT25Ob2RlRm9jdXMsIHNldENlbnRlciB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFhdXRvUGFuT25Ob2RlRm9jdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aXRoaW5WaWV3cG9ydCA9IGdldE5vZGVzSW5zaWRlKG5ldyBNYXAoW1tpZCwgbm9kZV1dKSwgeyB4OiAwLCB5OiAwLCB3aWR0aCwgaGVpZ2h0IH0sIHRyYW5zZm9ybSwgdHJ1ZSkubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKCF3aXRoaW5WaWV3cG9ydCkge1xuICAgICAgICAgICAgc2V0Q2VudGVyKG5vZGUucG9zaXRpb24ueCArIG5vZGVEaW1lbnNpb25zLndpZHRoIC8gMiwgbm9kZS5wb3NpdGlvbi55ICsgbm9kZURpbWVuc2lvbnMuaGVpZ2h0IC8gMiwge1xuICAgICAgICAgICAgICAgIHpvb206IHRyYW5zZm9ybVsyXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoW1xuICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX25vZGUnLFxuICAgICAgICAgICAgYHJlYWN0LWZsb3dfX25vZGUtJHtub2RlVHlwZX1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgb3ZlcndyaXRhYmxlIGJ5IHBhc3NpbmcgYG5vcGFuYCBhcyBhIGNsYXNzIG5hbWVcbiAgICAgICAgICAgICAgICBbbm9QYW5DbGFzc05hbWVdOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub2RlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogbm9kZS5zZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpc1BhcmVudCxcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGlzRHJhZ2dhYmxlLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSksIHJlZjogbm9kZVJlZiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHpJbmRleDogaW50ZXJuYWxzLnosXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54fXB4LCR7aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueX1weClgLFxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogaGFzUG9pbnRlckV2ZW50cyA/ICdhbGwnIDogJ25vbmUnLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogaGFzRGltZW5zaW9ucyA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgLi4ubm9kZS5zdHlsZSxcbiAgICAgICAgICAgIC4uLmlubGluZURpbWVuc2lvbnMsXG4gICAgICAgIH0sIFwiZGF0YS1pZFwiOiBpZCwgXCJkYXRhLXRlc3RpZFwiOiBgcmZfX25vZGUtJHtpZH1gLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlckhhbmRsZXIsIG9uTW91c2VNb3ZlOiBvbk1vdXNlTW92ZUhhbmRsZXIsIG9uTW91c2VMZWF2ZTogb25Nb3VzZUxlYXZlSGFuZGxlciwgb25Db250ZXh0TWVudTogb25Db250ZXh0TWVudUhhbmRsZXIsIG9uQ2xpY2s6IG9uU2VsZWN0Tm9kZUhhbmRsZXIsIG9uRG91YmxlQ2xpY2s6IG9uRG91YmxlQ2xpY2tIYW5kbGVyLCBvbktleURvd246IGlzRm9jdXNhYmxlID8gb25LZXlEb3duIDogdW5kZWZpbmVkLCB0YWJJbmRleDogaXNGb2N1c2FibGUgPyAwIDogdW5kZWZpbmVkLCBvbkZvY3VzOiBpc0ZvY3VzYWJsZSA/IG9uRm9jdXMgOiB1bmRlZmluZWQsIHJvbGU6IG5vZGUuYXJpYVJvbGUgPz8gKGlzRm9jdXNhYmxlID8gJ2dyb3VwJyA6IHVuZGVmaW5lZCksIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJub2RlXCIsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogYCR7QVJJQV9OT0RFX0RFU0NfS0VZfS0ke3JmSWR9YCwgXCJhcmlhLWxhYmVsXCI6IG5vZGUuYXJpYUxhYmVsLCAuLi5ub2RlLmRvbUF0dHJpYnV0ZXMsIGNoaWxkcmVuOiBqc3goUHJvdmlkZXIsIHsgdmFsdWU6IGlkLCBjaGlsZHJlbjoganN4KE5vZGVDb21wb25lbnQsIHsgaWQ6IGlkLCBkYXRhOiBub2RlLmRhdGEsIHR5cGU6IG5vZGVUeXBlLCBwb3NpdGlvbkFic29sdXRlWDogaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCwgcG9zaXRpb25BYnNvbHV0ZVk6IGludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnksIHNlbGVjdGVkOiBub2RlLnNlbGVjdGVkID8/IGZhbHNlLCBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsIGRyYWdnYWJsZTogaXNEcmFnZ2FibGUsIGRlbGV0YWJsZTogbm9kZS5kZWxldGFibGUgPz8gdHJ1ZSwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSwgc291cmNlUG9zaXRpb246IG5vZGUuc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiBub2RlLnRhcmdldFBvc2l0aW9uLCBkcmFnZ2luZzogZHJhZ2dpbmcsIGRyYWdIYW5kbGU6IG5vZGUuZHJhZ0hhbmRsZSwgekluZGV4OiBpbnRlcm5hbHMueiwgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsIC4uLm5vZGVEaW1lbnNpb25zIH0pIH0pIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkYiA9IChzKSA9PiAoe1xuICAgIG5vZGVzRHJhZ2dhYmxlOiBzLm5vZGVzRHJhZ2dhYmxlLFxuICAgIG5vZGVzQ29ubmVjdGFibGU6IHMubm9kZXNDb25uZWN0YWJsZSxcbiAgICBub2Rlc0ZvY3VzYWJsZTogcy5ub2Rlc0ZvY3VzYWJsZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIG9uRXJyb3I6IHMub25FcnJvcixcbn0pO1xuZnVuY3Rpb24gTm9kZVJlbmRlcmVyQ29tcG9uZW50KHByb3BzKSB7XG4gICAgY29uc3QgeyBub2Rlc0RyYWdnYWJsZSwgbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgb25FcnJvciB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkYiwgc2hhbGxvdyk7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHVzZVZpc2libGVOb2RlSWRzKHByb3BzLm9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMpO1xuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdXNlUmVzaXplT2JzZXJ2ZXIoKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19ub2Rlc1wiLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBub2RlSWRzLm1hcCgobm9kZUlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRoZSBzcGxpdCBvZiByZXNwb25zaWJpbGl0aWVzIGJldHdlZW4gTm9kZVJlbmRlcmVyIGFuZFxuICAgICAgICAgICAgICogTm9kZUNvbXBvbmVudFdyYXBwZXIgbWF5IGFwcGVhciB3ZWlyZC4gSG93ZXZlciwgaXTigJlzIGRlc2lnbmVkIHRvXG4gICAgICAgICAgICAgKiBtaW5pbWl6ZSB0aGUgY29zdCBvZiB1cGRhdGVzIHdoZW4gaW5kaXZpZHVhbCBub2RlcyBjaGFuZ2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogRm9yIGV4YW1wbGUsIHdoZW4geW914oCZcmUgZHJhZ2dpbmcgYSBzaW5nbGUgbm9kZSwgdGhhdCBub2RlIGdldHNcbiAgICAgICAgICAgICAqIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgcGVyIHNlY29uZC4gSWYgYE5vZGVSZW5kZXJlcmAgd2VyZSB0byB1cGRhdGVcbiAgICAgICAgICAgICAqIGV2ZXJ5IHRpbWUsIGl0IHdvdWxkIGhhdmUgdG8gcmUtcnVuIHRoZSBgbm9kZXMubWFwKClgIGxvb3AgZXZlcnlcbiAgICAgICAgICAgICAqIHRpbWUuIFRoaXMgZ2V0cyBwcmljZXkgd2l0aCBodW5kcmVkcyBvZiBub2RlcywgZXNwZWNpYWxseSBpZiBldmVyeVxuICAgICAgICAgICAgICogbG9vcCBjeWNsZSBkb2VzIG1vcmUgdGhhbiBqdXN0IHJlbmRlcmluZyBhIEpTWCBlbGVtZW50IVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEFzIGEgcmVzdWx0IG9mIHRoaXMgY2hvaWNlLCB3ZSB0b29rIHRoZSBmb2xsb3dpbmcgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAqIGRlY2lzaW9uczpcbiAgICAgICAgICAgICAqIC0gTm9kZVJlbmRlcmVyIHN1YnNjcmliZXMgKm9ubHkqIHRvIG5vZGUgSURzIOKAkyBhbmQgdGhlcmVmb3JlXG4gICAgICAgICAgICAgKiAgIHJlcmVuZGVyICpvbmx5KiB3aGVuIHZpc2libGUgbm9kZXMgYXJlIGFkZGVkIG9yIHJlbW92ZWQuXG4gICAgICAgICAgICAgKiAtIE5vZGVSZW5kZXJlciBwZXJmb3JtcyBhbGwgb3BlcmF0aW9ucyB0aGUgcmVzdWx0IG9mIHdoaWNoIGNhbiBiZVxuICAgICAgICAgICAgICogICBzaGFyZWQgYmV0d2VlbiBub2RlcyAoc3VjaCBhcyBjcmVhdGluZyB0aGUgYFJlc2l6ZU9ic2VydmVyYFxuICAgICAgICAgICAgICogICBpbnN0YW5jZSwgb3Igc3Vic2NyaWJpbmcgdG8gYHNlbGVjdG9yYCkuIFRoaXMgbWVhbnMgZXh0cmEgcHJvcFxuICAgICAgICAgICAgICogICBkcmlsbGluZyBpbnRvIGBOb2RlQ29tcG9uZW50V3JhcHBlcmAsIGJ1dCBpdCBtZWFucyB3ZSBuZWVkIHRvIHJ1blxuICAgICAgICAgICAgICogICB0aGVzZSBvcGVyYXRpb25zIG9ubHkgb25jZSDigJMgaW5zdGVhZCBvZiBvbmNlIHBlciBub2RlLlxuICAgICAgICAgICAgICogLSBBbnkgb3BlcmF0aW9ucyB0aGF0IHlvdeKAmWQgbm9ybWFsbHkgd3JpdGUgaW5zaWRlIGBub2Rlcy5tYXBgIGFyZVxuICAgICAgICAgICAgICogICBtb3ZlZCBpbnRvIGBOb2RlQ29tcG9uZW50V3JhcHBlcmAuIFRoaXMgZW5zdXJlcyB0aGV5IGFyZVxuICAgICAgICAgICAgICogICBtZW1vcml6ZWQg4oCTIHNvIGlmIGBOb2RlUmVuZGVyZXJgICpoYXMqIHRvIHJlcmVuZGVyLCBpdCBvbmx5XG4gICAgICAgICAgICAgKiAgIG5lZWRzIHRvIHJlZ2VuZXJhdGUgdGhlIGxpc3Qgb2Ygbm9kZXMsIG5vdGhpbmcgZWxzZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAganN4KE5vZGVXcmFwcGVyLCB7IGlkOiBub2RlSWQsIG5vZGVUeXBlczogcHJvcHMubm9kZVR5cGVzLCBub2RlRXh0ZW50OiBwcm9wcy5ub2RlRXh0ZW50LCBvbkNsaWNrOiBwcm9wcy5vbk5vZGVDbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5vbk5vZGVNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogcHJvcHMub25Ob2RlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IHByb3BzLm9uTm9kZU1vdXNlTGVhdmUsIG9uQ29udGV4dE1lbnU6IHByb3BzLm9uTm9kZUNvbnRleHRNZW51LCBvbkRvdWJsZUNsaWNrOiBwcm9wcy5vbk5vZGVEb3VibGVDbGljaywgbm9EcmFnQ2xhc3NOYW1lOiBwcm9wcy5ub0RyYWdDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBwcm9wcy5ub1BhbkNsYXNzTmFtZSwgcmZJZDogcHJvcHMucmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeTogcHJvcHMuZGlzYWJsZUtleWJvYXJkQTExeSwgcmVzaXplT2JzZXJ2ZXI6IHJlc2l6ZU9ic2VydmVyLCBub2Rlc0RyYWdnYWJsZTogbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGU6IG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlOiBub2Rlc0ZvY3VzYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIG5vZGVDbGlja0Rpc3RhbmNlOiBwcm9wcy5ub2RlQ2xpY2tEaXN0YW5jZSwgb25FcnJvcjogb25FcnJvciB9LCBub2RlSWQpKTtcbiAgICAgICAgfSkgfSkpO1xufVxuTm9kZVJlbmRlcmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ05vZGVSZW5kZXJlcic7XG5jb25zdCBOb2RlUmVuZGVyZXIgPSBtZW1vKE5vZGVSZW5kZXJlckNvbXBvbmVudCk7XG5cbi8qKlxuICogSG9vayBmb3IgZ2V0dGluZyB0aGUgdmlzaWJsZSBlZGdlIGlkcyBmcm9tIHRoZSBzdG9yZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBvbmx5UmVuZGVyVmlzaWJsZVxuICogQHJldHVybnMgYXJyYXkgd2l0aCB2aXNpYmxlIGVkZ2UgaWRzXG4gKi9cbmZ1bmN0aW9uIHVzZVZpc2libGVFZGdlSWRzKG9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgZWRnZUlkcyA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiB7XG4gICAgICAgIGlmICghb25seVJlbmRlclZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzLmVkZ2VzLm1hcCgoZWRnZSkgPT4gZWRnZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlzaWJsZUVkZ2VJZHMgPSBbXTtcbiAgICAgICAgaWYgKHMud2lkdGggJiYgcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWRnZSBvZiBzLmVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoZWRnZS5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIGlzRWRnZVZpc2libGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHMudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlRWRnZUlkcy5wdXNoKGVkZ2UuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlzaWJsZUVkZ2VJZHM7XG4gICAgfSwgW29ubHlSZW5kZXJWaXNpYmxlXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBlZGdlSWRzO1xufVxuXG5jb25zdCBBcnJvd1N5bWJvbCA9ICh7IGNvbG9yID0gJ25vbmUnLCBzdHJva2VXaWR0aCA9IDEgfSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgLi4uKGNvbG9yICYmIHsgc3Ryb2tlOiBjb2xvciB9KSxcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwicG9seWxpbmVcIiwgeyBjbGFzc05hbWU6IFwiYXJyb3dcIiwgc3R5bGU6IHN0eWxlLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBwb2ludHM6IFwiLTUsLTQgMCwwIC01LDRcIiB9KSk7XG59O1xuY29uc3QgQXJyb3dDbG9zZWRTeW1ib2wgPSAoeyBjb2xvciA9ICdub25lJywgc3Ryb2tlV2lkdGggPSAxIH0pID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIC4uLihjb2xvciAmJiB7IHN0cm9rZTogY29sb3IsIGZpbGw6IGNvbG9yIH0pLFxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJwb2x5bGluZVwiLCB7IGNsYXNzTmFtZTogXCJhcnJvd2Nsb3NlZFwiLCBzdHlsZTogc3R5bGUsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgcG9pbnRzOiBcIi01LC00IDAsMCAtNSw0IC01LC00XCIgfSkpO1xufTtcbmNvbnN0IE1hcmtlclN5bWJvbHMgPSB7XG4gICAgW01hcmtlclR5cGUuQXJyb3ddOiBBcnJvd1N5bWJvbCxcbiAgICBbTWFya2VyVHlwZS5BcnJvd0Nsb3NlZF06IEFycm93Q2xvc2VkU3ltYm9sLFxufTtcbmZ1bmN0aW9uIHVzZU1hcmtlclN5bWJvbCh0eXBlKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHN5bWJvbCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzeW1ib2xFeGlzdHMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTWFya2VyU3ltYm9scywgdHlwZSk7XG4gICAgICAgIGlmICghc3ltYm9sRXhpc3RzKSB7XG4gICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDA5JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDknXSh0eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWFya2VyU3ltYm9sc1t0eXBlXTtcbiAgICB9LCBbdHlwZV0pO1xuICAgIHJldHVybiBzeW1ib2w7XG59XG5cbmNvbnN0IE1hcmtlciA9ICh7IGlkLCB0eXBlLCBjb2xvciwgd2lkdGggPSAxMi41LCBoZWlnaHQgPSAxMi41LCBtYXJrZXJVbml0cyA9ICdzdHJva2VXaWR0aCcsIHN0cm9rZVdpZHRoLCBvcmllbnQgPSAnYXV0by1zdGFydC1yZXZlcnNlJywgfSkgPT4ge1xuICAgIGNvbnN0IFN5bWJvbCA9IHVzZU1hcmtlclN5bWJvbCh0eXBlKTtcbiAgICBpZiAoIVN5bWJvbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJtYXJrZXJcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fYXJyb3doZWFkXCIsIGlkOiBpZCwgbWFya2VyV2lkdGg6IGAke3dpZHRofWAsIG1hcmtlckhlaWdodDogYCR7aGVpZ2h0fWAsIHZpZXdCb3g6IFwiLTEwIC0xMCAyMCAyMFwiLCBtYXJrZXJVbml0czogbWFya2VyVW5pdHMsIG9yaWVudDogb3JpZW50LCByZWZYOiBcIjBcIiwgcmVmWTogXCIwXCIsIGNoaWxkcmVuOiBqc3goU3ltYm9sLCB7IGNvbG9yOiBjb2xvciwgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoIH0pIH0pKTtcbn07XG4vKlxuICogd2hlbiB5b3UgaGF2ZSBtdWx0aXBsZSBmbG93cyBvbiBhIHBhZ2UgYW5kIHlvdSBoaWRlIHRoZSBmaXJzdCBvbmUsIHRoZSBvdGhlciBvbmVzIGhhdmUgbm8gbWFya2VycyBhbnltb3JlXG4gKiB3aGVuIHRoZXkgZG8gaGF2ZSBtYXJrZXJzIHdpdGggdGhlIHNhbWUgaWRzLiBUbyBwcmV2ZW50IHRoaXMgdGhlIHVzZXIgY2FuIHBhc3MgYSB1bmlxdWUgaWQgdG8gdGhlIHJlYWN0IGZsb3cgd3JhcHBlclxuICogdGhhdCB3ZSBjYW4gdGhlbiB1c2UgZm9yIGNyZWF0aW5nIG91ciB1bmlxdWUgbWFya2VyIGlkc1xuICovXG5jb25zdCBNYXJrZXJEZWZpbml0aW9ucyA9ICh7IGRlZmF1bHRDb2xvciwgcmZJZCB9KSA9PiB7XG4gICAgY29uc3QgZWRnZXMgPSB1c2VTdG9yZSgocykgPT4gcy5lZGdlcyk7XG4gICAgY29uc3QgZGVmYXVsdEVkZ2VPcHRpb25zID0gdXNlU3RvcmUoKHMpID0+IHMuZGVmYXVsdEVkZ2VPcHRpb25zKTtcbiAgICBjb25zdCBtYXJrZXJzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcmtlcnMgPSBjcmVhdGVNYXJrZXJJZHMoZWRnZXMsIHtcbiAgICAgICAgICAgIGlkOiByZklkLFxuICAgICAgICAgICAgZGVmYXVsdENvbG9yLFxuICAgICAgICAgICAgZGVmYXVsdE1hcmtlclN0YXJ0OiBkZWZhdWx0RWRnZU9wdGlvbnM/Lm1hcmtlclN0YXJ0LFxuICAgICAgICAgICAgZGVmYXVsdE1hcmtlckVuZDogZGVmYXVsdEVkZ2VPcHRpb25zPy5tYXJrZXJFbmQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFya2VycztcbiAgICB9LCBbZWRnZXMsIGRlZmF1bHRFZGdlT3B0aW9ucywgcmZJZCwgZGVmYXVsdENvbG9yXSk7XG4gICAgaWYgKCFtYXJrZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbWFya2VyXCIsIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsIGNoaWxkcmVuOiBqc3goXCJkZWZzXCIsIHsgY2hpbGRyZW46IG1hcmtlcnMubWFwKChtYXJrZXIpID0+IChqc3goTWFya2VyLCB7IGlkOiBtYXJrZXIuaWQsIHR5cGU6IG1hcmtlci50eXBlLCBjb2xvcjogbWFya2VyLmNvbG9yLCB3aWR0aDogbWFya2VyLndpZHRoLCBoZWlnaHQ6IG1hcmtlci5oZWlnaHQsIG1hcmtlclVuaXRzOiBtYXJrZXIubWFya2VyVW5pdHMsIHN0cm9rZVdpZHRoOiBtYXJrZXIuc3Ryb2tlV2lkdGgsIG9yaWVudDogbWFya2VyLm9yaWVudCB9LCBtYXJrZXIuaWQpKSkgfSkgfSkpO1xufTtcbk1hcmtlckRlZmluaXRpb25zLmRpc3BsYXlOYW1lID0gJ01hcmtlckRlZmluaXRpb25zJztcbnZhciBNYXJrZXJEZWZpbml0aW9ucyQxID0gbWVtbyhNYXJrZXJEZWZpbml0aW9ucyk7XG5cbmZ1bmN0aW9uIEVkZ2VUZXh0Q29tcG9uZW50KHsgeCwgeSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnID0gdHJ1ZSwgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZyA9IFsyLCA0XSwgbGFiZWxCZ0JvcmRlclJhZGl1cyA9IDIsIGNoaWxkcmVuLCBjbGFzc05hbWUsIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IFtlZGdlVGV4dEJib3gsIHNldEVkZ2VUZXh0QmJveF0gPSB1c2VTdGF0ZSh7IHg6IDEsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gICAgY29uc3QgZWRnZVRleHRDbGFzc2VzID0gY2MoWydyZWFjdC1mbG93X19lZGdlLXRleHR3cmFwcGVyJywgY2xhc3NOYW1lXSk7XG4gICAgY29uc3QgZWRnZVRleHRSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGVkZ2VUZXh0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRCYm94ID0gZWRnZVRleHRSZWYuY3VycmVudC5nZXRCQm94KCk7XG4gICAgICAgICAgICBzZXRFZGdlVGV4dEJib3goe1xuICAgICAgICAgICAgICAgIHg6IHRleHRCYm94LngsXG4gICAgICAgICAgICAgICAgeTogdGV4dEJib3gueSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGV4dEJib3gud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0ZXh0QmJveC5oZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtsYWJlbF0pO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4cyhcImdcIiwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt4IC0gZWRnZVRleHRCYm94LndpZHRoIC8gMn0gJHt5IC0gZWRnZVRleHRCYm94LmhlaWdodCAvIDJ9KWAsIGNsYXNzTmFtZTogZWRnZVRleHRDbGFzc2VzLCB2aXNpYmlsaXR5OiBlZGdlVGV4dEJib3gud2lkdGggPyAndmlzaWJsZScgOiAnaGlkZGVuJywgLi4ucmVzdCwgY2hpbGRyZW46IFtsYWJlbFNob3dCZyAmJiAoanN4KFwicmVjdFwiLCB7IHdpZHRoOiBlZGdlVGV4dEJib3gud2lkdGggKyAyICogbGFiZWxCZ1BhZGRpbmdbMF0sIHg6IC1sYWJlbEJnUGFkZGluZ1swXSwgeTogLWxhYmVsQmdQYWRkaW5nWzFdLCBoZWlnaHQ6IGVkZ2VUZXh0QmJveC5oZWlnaHQgKyAyICogbGFiZWxCZ1BhZGRpbmdbMV0sIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXRleHRiZ1wiLCBzdHlsZTogbGFiZWxCZ1N0eWxlLCByeDogbGFiZWxCZ0JvcmRlclJhZGl1cywgcnk6IGxhYmVsQmdCb3JkZXJSYWRpdXMgfSkpLCBqc3goXCJ0ZXh0XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtdGV4dFwiLCB5OiBlZGdlVGV4dEJib3guaGVpZ2h0IC8gMiwgZHk6IFwiMC4zZW1cIiwgcmVmOiBlZGdlVGV4dFJlZiwgc3R5bGU6IGxhYmVsU3R5bGUsIGNoaWxkcmVuOiBsYWJlbCB9KSwgY2hpbGRyZW5dIH0pKTtcbn1cbkVkZ2VUZXh0Q29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0VkZ2VUZXh0Jztcbi8qKlxuICogWW91IGNhbiB1c2UgdGhlIGA8RWRnZVRleHQgLz5gIGNvbXBvbmVudCBhcyBhIGhlbHBlciBjb21wb25lbnQgdG8gZGlzcGxheSB0ZXh0XG4gKiB3aXRoaW4geW91ciBjdXN0b20gZWRnZXMuXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IEVkZ2VUZXh0IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbUVkZ2VMYWJlbCh7IGxhYmVsIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8RWRnZVRleHRcbiAqICAgICAgIHg9ezEwMH1cbiAqICAgICAgIHk9ezEwMH1cbiAqICAgICAgIGxhYmVsPXtsYWJlbH1cbiAqICAgICAgIGxhYmVsU3R5bGU9e3sgZmlsbDogJ3doaXRlJyB9fVxuICogICAgICAgbGFiZWxTaG93QmdcbiAqICAgICAgIGxhYmVsQmdTdHlsZT17eyBmaWxsOiAncmVkJyB9fVxuICogICAgICAgbGFiZWxCZ1BhZGRpbmc9e1syLCA0XX1cbiAqICAgICAgIGxhYmVsQmdCb3JkZXJSYWRpdXM9ezJ9XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqYGBgXG4gKi9cbmNvbnN0IEVkZ2VUZXh0ID0gbWVtbyhFZGdlVGV4dENvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGA8QmFzZUVkZ2UgLz5gIGNvbXBvbmVudCBnZXRzIHVzZWQgaW50ZXJuYWxseSBmb3IgYWxsIHRoZSBlZGdlcy4gSXQgY2FuIGJlXG4gKiB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIGFuZCBoYW5kbGVzIHRoZSBpbnZpc2libGUgaGVscGVyIGVkZ2UgYW5kIHRoZSBlZGdlIGxhYmVsXG4gKiBmb3IgeW91LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgQmFzZUVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgLi4ucHJvcHMgfSkge1xuICogIGNvbnN0IFtlZGdlUGF0aF0gPSBnZXRTdHJhaWdodFBhdGgoe1xuICogICAgc291cmNlWCxcbiAqICAgIHNvdXJjZVksXG4gKiAgICB0YXJnZXRYLFxuICogICAgdGFyZ2V0WSxcbiAqICB9KTtcbiAqXG4gKiAgcmV0dXJuIDxCYXNlRWRnZSBwYXRoPXtlZGdlUGF0aH0gey4uLnByb3BzfSAvPjtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBJZiB5b3Ugd2FudCB0byB1c2UgYW4gZWRnZSBtYXJrZXIgd2l0aCB0aGUgW2A8QmFzZUVkZ2UgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2Jhc2UtZWRnZSkgY29tcG9uZW50LFxuICogeW91IGNhbiBwYXNzIHRoZSBgbWFya2VyU3RhcnRgIG9yIGBtYXJrZXJFbmRgIHByb3BzIHBhc3NlZCB0byB5b3VyIGN1c3RvbSBlZGdlXG4gKiB0aHJvdWdoIHRvIHRoZSBbYDxCYXNlRWRnZSAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvYmFzZS1lZGdlKSBjb21wb25lbnQuXG4gKiBZb3UgY2FuIHNlZSBhbGwgdGhlIHByb3BzIHBhc3NlZCB0byBhIGN1c3RvbSBlZGdlIGJ5IGxvb2tpbmcgYXQgdGhlIFtgRWRnZVByb3BzYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZS1wcm9wcykgdHlwZS5cbiAqL1xuZnVuY3Rpb24gQmFzZUVkZ2UoeyBwYXRoLCBsYWJlbFgsIGxhYmVsWSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBpbnRlcmFjdGlvbldpZHRoID0gMjAsIC4uLnByb3BzIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgLi4ucHJvcHMsIGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fZWRnZS1wYXRoJywgcHJvcHMuY2xhc3NOYW1lXSkgfSksIGludGVyYWN0aW9uV2lkdGggPyAoanN4KFwicGF0aFwiLCB7IGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBzdHJva2VPcGFjaXR5OiAwLCBzdHJva2VXaWR0aDogaW50ZXJhY3Rpb25XaWR0aCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtaW50ZXJhY3Rpb25cIiB9KSkgOiBudWxsLCBsYWJlbCAmJiBpc051bWVyaWMobGFiZWxYKSAmJiBpc051bWVyaWMobGFiZWxZKSA/IChqc3goRWRnZVRleHQsIHsgeDogbGFiZWxYLCB5OiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzIH0pKSA6IG51bGxdIH0pKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udHJvbCh7IHBvcywgeDEsIHkxLCB4MiwgeTIgfSkge1xuICAgIGlmIChwb3MgPT09IFBvc2l0aW9uLkxlZnQgfHwgcG9zID09PSBQb3NpdGlvbi5SaWdodCkge1xuICAgICAgICByZXR1cm4gWzAuNSAqICh4MSArIHgyKSwgeTFdO1xuICAgIH1cbiAgICByZXR1cm4gW3gxLCAwLjUgKiAoeTEgKyB5MildO1xufVxuLyoqXG4gKiBUaGUgYGdldFNpbXBsZUJlemllclBhdGhgIHV0aWwgcmV0dXJucyBldmVyeXRoaW5nIHlvdSBuZWVkIHRvIHJlbmRlciBhIHNpbXBsZVxuICogYmV6aWVyIGVkZ2UgYmV0d2VlbiB0d28gbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuc1xuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqL1xuZnVuY3Rpb24gZ2V0U2ltcGxlQmV6aWVyUGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRYLCB0YXJnZXRZLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgfSkge1xuICAgIGNvbnN0IFtzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFldID0gZ2V0Q29udHJvbCh7XG4gICAgICAgIHBvczogc291cmNlUG9zaXRpb24sXG4gICAgICAgIHgxOiBzb3VyY2VYLFxuICAgICAgICB5MTogc291cmNlWSxcbiAgICAgICAgeDI6IHRhcmdldFgsXG4gICAgICAgIHkyOiB0YXJnZXRZLFxuICAgIH0pO1xuICAgIGNvbnN0IFt0YXJnZXRDb250cm9sWCwgdGFyZ2V0Q29udHJvbFldID0gZ2V0Q29udHJvbCh7XG4gICAgICAgIHBvczogdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIHgxOiB0YXJnZXRYLFxuICAgICAgICB5MTogdGFyZ2V0WSxcbiAgICAgICAgeDI6IHNvdXJjZVgsXG4gICAgICAgIHkyOiBzb3VyY2VZLFxuICAgIH0pO1xuICAgIGNvbnN0IFtsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRCZXppZXJFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgc291cmNlQ29udHJvbFgsXG4gICAgICAgIHNvdXJjZUNvbnRyb2xZLFxuICAgICAgICB0YXJnZXRDb250cm9sWCxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYE0ke3NvdXJjZVh9LCR7c291cmNlWX0gQyR7c291cmNlQ29udHJvbFh9LCR7c291cmNlQ29udHJvbFl9ICR7dGFyZ2V0Q29udHJvbFh9LCR7dGFyZ2V0Q29udHJvbFl9ICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsXG4gICAgICAgIGxhYmVsWCxcbiAgICAgICAgbGFiZWxZLFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgIF07XG59XG5mdW5jdGlvbiBjcmVhdGVTaW1wbGVCZXppZXJFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTaW1wbGVCZXppZXJQYXRoKHtcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgICAgICB0YXJnZXRYLFxuICAgICAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbmNvbnN0IFNpbXBsZUJlemllckVkZ2UgPSBjcmVhdGVTaW1wbGVCZXppZXJFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG5jb25zdCBTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwgPSBjcmVhdGVTaW1wbGVCZXppZXJFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblNpbXBsZUJlemllckVkZ2UuZGlzcGxheU5hbWUgPSAnU2ltcGxlQmV6aWVyRWRnZSc7XG5TaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU2ltcGxlQmV6aWVyRWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlU21vb3RoU3RlcEVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIHBhdGhPcHRpb25zLCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gICAgICAgICAgICBzb3VyY2VYLFxuICAgICAgICAgICAgc291cmNlWSxcbiAgICAgICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgICAgIHRhcmdldFksXG4gICAgICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogcGF0aE9wdGlvbnM/LmJvcmRlclJhZGl1cyxcbiAgICAgICAgICAgIG9mZnNldDogcGF0aE9wdGlvbnM/Lm9mZnNldCxcbiAgICAgICAgICAgIHN0ZXBQb3NpdGlvbjogcGF0aE9wdGlvbnM/LnN0ZXBQb3NpdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIHRvIHJlbmRlciBhIHNtb290aCBzdGVwIGVkZ2UuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFNtb290aFN0ZXBFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9KSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPFNtb290aFN0ZXBFZGdlXG4gKiAgICAgICBzb3VyY2VYPXtzb3VyY2VYfVxuICogICAgICAgc291cmNlWT17c291cmNlWX1cbiAqICAgICAgIHRhcmdldFg9e3RhcmdldFh9XG4gKiAgICAgICB0YXJnZXRZPXt0YXJnZXRZfVxuICogICAgICAgc291cmNlUG9zaXRpb249e3NvdXJjZVBvc2l0aW9ufVxuICogICAgICAgdGFyZ2V0UG9zaXRpb249e3RhcmdldFBvc2l0aW9ufVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgU21vb3RoU3RlcEVkZ2UgPSBjcmVhdGVTbW9vdGhTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVNtb290aFN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblNtb290aFN0ZXBFZGdlLmRpc3BsYXlOYW1lID0gJ1Ntb290aFN0ZXBFZGdlJztcblNtb290aFN0ZXBFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0ZXBFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgLi4ucHJvcHMgfSkgPT4ge1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChTbW9vdGhTdGVwRWRnZSwgeyAuLi5wcm9wcywgaWQ6IF9pZCwgcGF0aE9wdGlvbnM6IHVzZU1lbW8oKCkgPT4gKHsgYm9yZGVyUmFkaXVzOiAwLCBvZmZzZXQ6IHByb3BzLnBhdGhPcHRpb25zPy5vZmZzZXQgfSksIFtwcm9wcy5wYXRoT3B0aW9ucz8ub2Zmc2V0XSkgfSkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnNpZGUgYSBjdXN0b20gZWRnZSB0byByZW5kZXIgYSBzdGVwIGVkZ2UuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFN0ZXBFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9KSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPFN0ZXBFZGdlXG4gKiAgICAgICBzb3VyY2VYPXtzb3VyY2VYfVxuICogICAgICAgc291cmNlWT17c291cmNlWX1cbiAqICAgICAgIHRhcmdldFg9e3RhcmdldFh9XG4gKiAgICAgICB0YXJnZXRZPXt0YXJnZXRZfVxuICogICAgICAgc291cmNlUG9zaXRpb249e3NvdXJjZVBvc2l0aW9ufVxuICogICAgICAgdGFyZ2V0UG9zaXRpb249e3RhcmdldFBvc2l0aW9ufVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgU3RlcEVkZ2UgPSBjcmVhdGVTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU3RlcEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblN0ZXBFZGdlLmRpc3BsYXlOYW1lID0gJ1N0ZXBFZGdlJztcblN0ZXBFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU3RlcEVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmFpZ2h0RWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFN0cmFpZ2h0UGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFkgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIHRvIHJlbmRlciBhIHN0cmFpZ2h0IGxpbmUuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFN0cmFpZ2h0RWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8U3RyYWlnaHRFZGdlXG4gKiAgICAgICBzb3VyY2VYPXtzb3VyY2VYfVxuICogICAgICAgc291cmNlWT17c291cmNlWX1cbiAqICAgICAgIHRhcmdldFg9e3RhcmdldFh9XG4gKiAgICAgICB0YXJnZXRZPXt0YXJnZXRZfVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgU3RyYWlnaHRFZGdlID0gY3JlYXRlU3RyYWlnaHRFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTdHJhaWdodEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVN0cmFpZ2h0RWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TdHJhaWdodEVkZ2UuZGlzcGxheU5hbWUgPSAnU3RyYWlnaHRFZGdlJztcblN0cmFpZ2h0RWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1N0cmFpZ2h0RWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlQmV6aWVyRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldEJlemllclBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICBjdXJ2YXR1cmU6IHBhdGhPcHRpb25zPy5jdXJ2YXR1cmUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnNpZGUgYSBjdXN0b20gZWRnZSB0byByZW5kZXIgYSBiZXppZXIgY3VydmUuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IEJlemllckVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8QmV6aWVyRWRnZVxuICogICAgICAgc291cmNlWD17c291cmNlWH1cbiAqICAgICAgIHNvdXJjZVk9e3NvdXJjZVl9XG4gKiAgICAgICB0YXJnZXRYPXt0YXJnZXRYfVxuICogICAgICAgdGFyZ2V0WT17dGFyZ2V0WX1cbiAqICAgICAgIHNvdXJjZVBvc2l0aW9uPXtzb3VyY2VQb3NpdGlvbn1cbiAqICAgICAgIHRhcmdldFBvc2l0aW9uPXt0YXJnZXRQb3NpdGlvbn1cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IEJlemllckVkZ2UgPSBjcmVhdGVCZXppZXJFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBCZXppZXJFZGdlSW50ZXJuYWwgPSBjcmVhdGVCZXppZXJFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcbkJlemllckVkZ2UuZGlzcGxheU5hbWUgPSAnQmV6aWVyRWRnZSc7XG5CZXppZXJFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnQmV6aWVyRWRnZUludGVybmFsJztcblxuY29uc3QgYnVpbHRpbkVkZ2VUeXBlcyA9IHtcbiAgICBkZWZhdWx0OiBCZXppZXJFZGdlSW50ZXJuYWwsXG4gICAgc3RyYWlnaHQ6IFN0cmFpZ2h0RWRnZUludGVybmFsLFxuICAgIHN0ZXA6IFN0ZXBFZGdlSW50ZXJuYWwsXG4gICAgc21vb3Roc3RlcDogU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCxcbiAgICBzaW1wbGViZXppZXI6IFNpbXBsZUJlemllckVkZ2VJbnRlcm5hbCxcbn07XG5jb25zdCBudWxsUG9zaXRpb24gPSB7XG4gICAgc291cmNlWDogbnVsbCxcbiAgICBzb3VyY2VZOiBudWxsLFxuICAgIHRhcmdldFg6IG51bGwsXG4gICAgdGFyZ2V0WTogbnVsbCxcbiAgICBzb3VyY2VQb3NpdGlvbjogbnVsbCxcbiAgICB0YXJnZXRQb3NpdGlvbjogbnVsbCxcbn07XG5cbmNvbnN0IHNoaWZ0WCA9ICh4LCBzaGlmdCwgcG9zaXRpb24pID0+IHtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkxlZnQpXG4gICAgICAgIHJldHVybiB4IC0gc2hpZnQ7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5SaWdodClcbiAgICAgICAgcmV0dXJuIHggKyBzaGlmdDtcbiAgICByZXR1cm4geDtcbn07XG5jb25zdCBzaGlmdFkgPSAoeSwgc2hpZnQsIHBvc2l0aW9uKSA9PiB7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5Ub3ApXG4gICAgICAgIHJldHVybiB5IC0gc2hpZnQ7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5Cb3R0b20pXG4gICAgICAgIHJldHVybiB5ICsgc2hpZnQ7XG4gICAgcmV0dXJuIHk7XG59O1xuY29uc3QgRWRnZVVwZGF0ZXJDbGFzc05hbWUgPSAncmVhY3QtZmxvd19fZWRnZXVwZGF0ZXInO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gRWRnZUFuY2hvcih7IHBvc2l0aW9uLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMgPSAxMCwgb25Nb3VzZURvd24sIG9uTW91c2VFbnRlciwgb25Nb3VzZU91dCwgdHlwZSwgfSkge1xuICAgIHJldHVybiAoanN4KFwiY2lyY2xlXCIsIHsgb25Nb3VzZURvd246IG9uTW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlciwgb25Nb3VzZU91dDogb25Nb3VzZU91dCwgY2xhc3NOYW1lOiBjYyhbRWRnZVVwZGF0ZXJDbGFzc05hbWUsIGAke0VkZ2VVcGRhdGVyQ2xhc3NOYW1lfS0ke3R5cGV9YF0pLCBjeDogc2hpZnRYKGNlbnRlclgsIHJhZGl1cywgcG9zaXRpb24pLCBjeTogc2hpZnRZKGNlbnRlclksIHJhZGl1cywgcG9zaXRpb24pLCByOiByYWRpdXMsIHN0cm9rZTogXCJ0cmFuc3BhcmVudFwiLCBmaWxsOiBcInRyYW5zcGFyZW50XCIgfSkpO1xufVxuXG5mdW5jdGlvbiBFZGdlVXBkYXRlQW5jaG9ycyh7IGlzUmVjb25uZWN0YWJsZSwgcmVjb25uZWN0UmFkaXVzLCBlZGdlLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgc2V0UmVjb25uZWN0aW5nLCBzZXRVcGRhdGVIb3ZlciwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBoYW5kbGVFZGdlVXBkYXRlciA9IChldmVudCwgb3Bwb3NpdGVIYW5kbGUpID0+IHtcbiAgICAgICAgLy8gYXZvaWQgdHJpZ2dlcmluZyBlZGdlIHVwZGF0ZXIgaWYgbW91c2UgYnRuIGlzIG5vdCBsZWZ0XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGF1dG9QYW5PbkNvbm5lY3QsIGRvbU5vZGUsIGlzVmFsaWRDb25uZWN0aW9uLCBjb25uZWN0aW9uTW9kZSwgY29ubmVjdGlvblJhZGl1cywgbGliLCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kLCBjYW5jZWxDb25uZWN0aW9uLCBub2RlTG9va3VwLCByZklkOiBmbG93SWQsIHBhbkJ5LCB1cGRhdGVDb25uZWN0aW9uLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgaXNUYXJnZXQgPSBvcHBvc2l0ZUhhbmRsZS50eXBlID09PSAndGFyZ2V0JztcbiAgICAgICAgY29uc3QgX29uUmVjb25uZWN0RW5kID0gKGV2dCwgY29ubmVjdGlvblN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzZXRSZWNvbm5lY3RpbmcoZmFsc2UpO1xuICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ/LihldnQsIGVkZ2UsIG9wcG9zaXRlSGFuZGxlLnR5cGUsIGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uQ29ubmVjdEVkZ2UgPSAoY29ubmVjdGlvbikgPT4gb25SZWNvbm5lY3Q/LihlZGdlLCBjb25uZWN0aW9uKTtcbiAgICAgICAgY29uc3QgX29uQ29ubmVjdFN0YXJ0ID0gKF9ldmVudCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBzZXRSZWNvbm5lY3RpbmcodHJ1ZSk7XG4gICAgICAgICAgICBvblJlY29ubmVjdFN0YXJ0Py4oZXZlbnQsIGVkZ2UsIG9wcG9zaXRlSGFuZGxlLnR5cGUpO1xuICAgICAgICAgICAgb25Db25uZWN0U3RhcnQ/LihfZXZlbnQsIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIFhZSGFuZGxlLm9uUG9pbnRlckRvd24oZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgIGF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25SYWRpdXMsXG4gICAgICAgICAgICBkb21Ob2RlLFxuICAgICAgICAgICAgaGFuZGxlSWQ6IG9wcG9zaXRlSGFuZGxlLmlkLFxuICAgICAgICAgICAgbm9kZUlkOiBvcHBvc2l0ZUhhbmRsZS5ub2RlSWQsXG4gICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICBlZGdlVXBkYXRlclR5cGU6IG9wcG9zaXRlSGFuZGxlLnR5cGUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBmbG93SWQsXG4gICAgICAgICAgICBjYW5jZWxDb25uZWN0aW9uLFxuICAgICAgICAgICAgcGFuQnksXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RWRnZSxcbiAgICAgICAgICAgIG9uQ29ubmVjdFN0YXJ0OiBfb25Db25uZWN0U3RhcnQsXG4gICAgICAgICAgICBvbkNvbm5lY3RFbmQsXG4gICAgICAgICAgICBvblJlY29ubmVjdEVuZDogX29uUmVjb25uZWN0RW5kLFxuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGdldFRyYW5zZm9ybTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm0sXG4gICAgICAgICAgICBnZXRGcm9tSGFuZGxlOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmNvbm5lY3Rpb24uZnJvbUhhbmRsZSxcbiAgICAgICAgICAgIGRyYWdUaHJlc2hvbGQ6IHN0b3JlLmdldFN0YXRlKCkuY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQsXG4gICAgICAgICAgICBoYW5kbGVEb21Ob2RlOiBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUmVjb25uZWN0U291cmNlTW91c2VEb3duID0gKGV2ZW50KSA9PiBoYW5kbGVFZGdlVXBkYXRlcihldmVudCwgeyBub2RlSWQ6IGVkZ2UudGFyZ2V0LCBpZDogZWRnZS50YXJnZXRIYW5kbGUgPz8gbnVsbCwgdHlwZTogJ3RhcmdldCcgfSk7XG4gICAgY29uc3Qgb25SZWNvbm5lY3RUYXJnZXRNb3VzZURvd24gPSAoZXZlbnQpID0+IGhhbmRsZUVkZ2VVcGRhdGVyKGV2ZW50LCB7IG5vZGVJZDogZWRnZS5zb3VyY2UsIGlkOiBlZGdlLnNvdXJjZUhhbmRsZSA/PyBudWxsLCB0eXBlOiAnc291cmNlJyB9KTtcbiAgICBjb25zdCBvblJlY29ubmVjdE1vdXNlRW50ZXIgPSAoKSA9PiBzZXRVcGRhdGVIb3Zlcih0cnVlKTtcbiAgICBjb25zdCBvblJlY29ubmVjdE1vdXNlT3V0ID0gKCkgPT4gc2V0VXBkYXRlSG92ZXIoZmFsc2UpO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogWyhpc1JlY29ubmVjdGFibGUgPT09IHRydWUgfHwgaXNSZWNvbm5lY3RhYmxlID09PSAnc291cmNlJykgJiYgKGpzeChFZGdlQW5jaG9yLCB7IHBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgY2VudGVyWDogc291cmNlWCwgY2VudGVyWTogc291cmNlWSwgcmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uTW91c2VEb3duOiBvblJlY29ubmVjdFNvdXJjZU1vdXNlRG93biwgb25Nb3VzZUVudGVyOiBvblJlY29ubmVjdE1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uUmVjb25uZWN0TW91c2VPdXQsIHR5cGU6IFwic291cmNlXCIgfSkpLCAoaXNSZWNvbm5lY3RhYmxlID09PSB0cnVlIHx8IGlzUmVjb25uZWN0YWJsZSA9PT0gJ3RhcmdldCcpICYmIChqc3goRWRnZUFuY2hvciwgeyBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGNlbnRlclg6IHRhcmdldFgsIGNlbnRlclk6IHRhcmdldFksIHJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvbk1vdXNlRG93bjogb25SZWNvbm5lY3RUYXJnZXRNb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25SZWNvbm5lY3RNb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvblJlY29ubmVjdE1vdXNlT3V0LCB0eXBlOiBcInRhcmdldFwiIH0pKV0gfSkpO1xufVxuXG5mdW5jdGlvbiBFZGdlV3JhcHBlcih7IGlkLCBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG9uQ2xpY2ssIG9uRG91YmxlQ2xpY2ssIG9uQ29udGV4dE1lbnUsIG9uTW91c2VFbnRlciwgb25Nb3VzZU1vdmUsIG9uTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIHJmSWQsIGVkZ2VUeXBlcywgbm9QYW5DbGFzc05hbWUsIG9uRXJyb3IsIGRpc2FibGVLZXlib2FyZEExMXksIH0pIHtcbiAgICBsZXQgZWRnZSA9IHVzZVN0b3JlKChzKSA9PiBzLmVkZ2VMb29rdXAuZ2V0KGlkKSk7XG4gICAgY29uc3QgZGVmYXVsdEVkZ2VPcHRpb25zID0gdXNlU3RvcmUoKHMpID0+IHMuZGVmYXVsdEVkZ2VPcHRpb25zKTtcbiAgICBlZGdlID0gZGVmYXVsdEVkZ2VPcHRpb25zID8geyAuLi5kZWZhdWx0RWRnZU9wdGlvbnMsIC4uLmVkZ2UgfSA6IGVkZ2U7XG4gICAgbGV0IGVkZ2VUeXBlID0gZWRnZS50eXBlIHx8ICdkZWZhdWx0JztcbiAgICBsZXQgRWRnZUNvbXBvbmVudCA9IGVkZ2VUeXBlcz8uW2VkZ2VUeXBlXSB8fCBidWlsdGluRWRnZVR5cGVzW2VkZ2VUeXBlXTtcbiAgICBpZiAoRWRnZUNvbXBvbmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9uRXJyb3I/LignMDExJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTEnXShlZGdlVHlwZSkpO1xuICAgICAgICBlZGdlVHlwZSA9ICdkZWZhdWx0JztcbiAgICAgICAgRWRnZUNvbXBvbmVudCA9IGVkZ2VUeXBlcz8uWydkZWZhdWx0J10gfHwgYnVpbHRpbkVkZ2VUeXBlcy5kZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKGVkZ2UuZm9jdXNhYmxlIHx8IChlZGdlc0ZvY3VzYWJsZSAmJiB0eXBlb2YgZWRnZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNSZWNvbm5lY3RhYmxlID0gdHlwZW9mIG9uUmVjb25uZWN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAoZWRnZS5yZWNvbm5lY3RhYmxlIHx8IChlZGdlc1JlY29ubmVjdGFibGUgJiYgdHlwZW9mIGVkZ2UucmVjb25uZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSAhIShlZGdlLnNlbGVjdGFibGUgfHwgKGVsZW1lbnRzU2VsZWN0YWJsZSAmJiB0eXBlb2YgZWRnZS5zZWxlY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGVkZ2VSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgW3VwZGF0ZUhvdmVyLCBzZXRVcGRhdGVIb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3JlY29ubmVjdGluZywgc2V0UmVjb25uZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB6SW5kZXgsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9ID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHN0b3JlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnRhcmdldCk7XG4gICAgICAgIGlmICghc291cmNlTm9kZSB8fCAhdGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6IGVkZ2UuekluZGV4LFxuICAgICAgICAgICAgICAgIC4uLm51bGxQb3NpdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRnZVBvc2l0aW9uID0gZ2V0RWRnZVBvc2l0aW9uKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IGVkZ2Uuc291cmNlSGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IGVkZ2UudGFyZ2V0SGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZTogc3RvcmUuY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgekluZGV4ID0gZ2V0RWxldmF0ZWRFZGdlWkluZGV4KHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgekluZGV4OiBlZGdlLnpJbmRleCxcbiAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgZWxldmF0ZU9uU2VsZWN0OiBzdG9yZS5lbGV2YXRlRWRnZXNPblNlbGVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6SW5kZXgsXG4gICAgICAgICAgICAuLi4oZWRnZVBvc2l0aW9uIHx8IG51bGxQb3NpdGlvbiksXG4gICAgICAgIH07XG4gICAgfSwgW2VkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCwgZWRnZS5zb3VyY2VIYW5kbGUsIGVkZ2UudGFyZ2V0SGFuZGxlLCBlZGdlLnNlbGVjdGVkLCBlZGdlLnpJbmRleF0pLCBzaGFsbG93KTtcbiAgICBjb25zdCBtYXJrZXJTdGFydFVybCA9IHVzZU1lbW8oKCkgPT4gKGVkZ2UubWFya2VyU3RhcnQgPyBgdXJsKCcjJHtnZXRNYXJrZXJJZChlZGdlLm1hcmtlclN0YXJ0LCByZklkKX0nKWAgOiB1bmRlZmluZWQpLCBbZWRnZS5tYXJrZXJTdGFydCwgcmZJZF0pO1xuICAgIGNvbnN0IG1hcmtlckVuZFVybCA9IHVzZU1lbW8oKCkgPT4gKGVkZ2UubWFya2VyRW5kID8gYHVybCgnIyR7Z2V0TWFya2VySWQoZWRnZS5tYXJrZXJFbmQsIHJmSWQpfScpYCA6IHVuZGVmaW5lZCksIFtlZGdlLm1hcmtlckVuZCwgcmZJZF0pO1xuICAgIGlmIChlZGdlLmhpZGRlbiB8fCBzb3VyY2VYID09PSBudWxsIHx8IHNvdXJjZVkgPT09IG51bGwgfHwgdGFyZ2V0WCA9PT0gbnVsbCB8fCB0YXJnZXRZID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkVkZ2VDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IGFkZFNlbGVjdGVkRWRnZXMsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgbXVsdGlTZWxlY3Rpb25BY3RpdmUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGVkZ2Uuc2VsZWN0ZWQgJiYgbXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW10sIGVkZ2VzOiBbZWRnZV0gfSk7XG4gICAgICAgICAgICAgICAgZWRnZVJlZi5jdXJyZW50Py5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzKFtpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCBlZGdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25FZGdlRG91YmxlQ2xpY2sgPSBvbkRvdWJsZUNsaWNrXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlQ29udGV4dE1lbnUgPSBvbkNvbnRleHRNZW51XG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkNvbnRleHRNZW51KGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VFbnRlciA9IG9uTW91c2VFbnRlclxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VNb3ZlID0gb25Nb3VzZU1vdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VMZWF2ZSA9IG9uTW91c2VMZWF2ZVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZUxlYXZlKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZUtleWJvYXJkQTExeSAmJiBlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeyB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIGFkZFNlbGVjdGVkRWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCB1bnNlbGVjdCA9IGV2ZW50LmtleSA9PT0gJ0VzY2FwZSc7XG4gICAgICAgICAgICBpZiAodW5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBlZGdlUmVmLmN1cnJlbnQ/LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBlZGdlczogW2VkZ2VdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VsZWN0ZWRFZGdlcyhbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBzdHlsZTogeyB6SW5kZXggfSwgY2hpbGRyZW46IGpzeHMoXCJnXCIsIHsgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX2VkZ2UnLFxuICAgICAgICAgICAgICAgIGByZWFjdC1mbG93X19lZGdlLSR7ZWRnZVR5cGV9YCxcbiAgICAgICAgICAgICAgICBlZGdlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlZDogZWRnZS5hbmltYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmU6ICFpc1NlbGVjdGFibGUgJiYgIW9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0aW5nOiB1cGRhdGVIb3ZlcixcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKSwgb25DbGljazogb25FZGdlQ2xpY2ssIG9uRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25Nb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIG9uS2V5RG93bjogaXNGb2N1c2FibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsIHRhYkluZGV4OiBpc0ZvY3VzYWJsZSA/IDAgOiB1bmRlZmluZWQsIHJvbGU6IGVkZ2UuYXJpYVJvbGUgPz8gKGlzRm9jdXNhYmxlID8gJ2dyb3VwJyA6ICdpbWcnKSwgXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiOiBcImVkZ2VcIiwgXCJkYXRhLWlkXCI6IGlkLCBcImRhdGEtdGVzdGlkXCI6IGByZl9fZWRnZS0ke2lkfWAsIFwiYXJpYS1sYWJlbFwiOiBlZGdlLmFyaWFMYWJlbCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGVkZ2UuYXJpYUxhYmVsIHx8IGBFZGdlIGZyb20gJHtlZGdlLnNvdXJjZX0gdG8gJHtlZGdlLnRhcmdldH1gLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogaXNGb2N1c2FibGUgPyBgJHtBUklBX0VER0VfREVTQ19LRVl9LSR7cmZJZH1gIDogdW5kZWZpbmVkLCByZWY6IGVkZ2VSZWYsIC4uLmVkZ2UuZG9tQXR0cmlidXRlcywgY2hpbGRyZW46IFshcmVjb25uZWN0aW5nICYmIChqc3goRWRnZUNvbXBvbmVudCwgeyBpZDogaWQsIHNvdXJjZTogZWRnZS5zb3VyY2UsIHRhcmdldDogZWRnZS50YXJnZXQsIHR5cGU6IGVkZ2UudHlwZSwgc2VsZWN0ZWQ6IGVkZ2Uuc2VsZWN0ZWQsIGFuaW1hdGVkOiBlZGdlLmFuaW1hdGVkLCBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsIGRlbGV0YWJsZTogZWRnZS5kZWxldGFibGUgPz8gdHJ1ZSwgbGFiZWw6IGVkZ2UubGFiZWwsIGxhYmVsU3R5bGU6IGVkZ2UubGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGVkZ2UubGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogZWRnZS5sYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBlZGdlLmxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBlZGdlLmxhYmVsQmdCb3JkZXJSYWRpdXMsIHNvdXJjZVg6IHNvdXJjZVgsIHNvdXJjZVk6IHNvdXJjZVksIHRhcmdldFg6IHRhcmdldFgsIHRhcmdldFk6IHRhcmdldFksIHNvdXJjZVBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBkYXRhOiBlZGdlLmRhdGEsIHN0eWxlOiBlZGdlLnN0eWxlLCBzb3VyY2VIYW5kbGVJZDogZWRnZS5zb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZUlkOiBlZGdlLnRhcmdldEhhbmRsZSwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0VXJsLCBtYXJrZXJFbmQ6IG1hcmtlckVuZFVybCwgcGF0aE9wdGlvbnM6ICdwYXRoT3B0aW9ucycgaW4gZWRnZSA/IGVkZ2UucGF0aE9wdGlvbnMgOiB1bmRlZmluZWQsIGludGVyYWN0aW9uV2lkdGg6IGVkZ2UuaW50ZXJhY3Rpb25XaWR0aCB9KSksIGlzUmVjb25uZWN0YWJsZSAmJiAoanN4KEVkZ2VVcGRhdGVBbmNob3JzLCB7IGVkZ2U6IGVkZ2UsIGlzUmVjb25uZWN0YWJsZTogaXNSZWNvbm5lY3RhYmxlLCByZWNvbm5lY3RSYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIHNvdXJjZVg6IHNvdXJjZVgsIHNvdXJjZVk6IHNvdXJjZVksIHRhcmdldFg6IHRhcmdldFgsIHRhcmdldFk6IHRhcmdldFksIHNvdXJjZVBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBzZXRVcGRhdGVIb3Zlcjogc2V0VXBkYXRlSG92ZXIsIHNldFJlY29ubmVjdGluZzogc2V0UmVjb25uZWN0aW5nIH0pKV0gfSkgfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRhID0gKHMpID0+ICh7XG4gICAgZWRnZXNGb2N1c2FibGU6IHMuZWRnZXNGb2N1c2FibGUsXG4gICAgZWRnZXNSZWNvbm5lY3RhYmxlOiBzLmVkZ2VzUmVjb25uZWN0YWJsZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIGNvbm5lY3Rpb25Nb2RlOiBzLmNvbm5lY3Rpb25Nb2RlLFxuICAgIG9uRXJyb3I6IHMub25FcnJvcixcbn0pO1xuZnVuY3Rpb24gRWRnZVJlbmRlcmVyQ29tcG9uZW50KHsgZGVmYXVsdE1hcmtlckNvbG9yLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCByZklkLCBlZGdlVHlwZXMsIG5vUGFuQ2xhc3NOYW1lLCBvblJlY29ubmVjdCwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgb25FZGdlQ2xpY2ssIHJlY29ubmVjdFJhZGl1cywgb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSB7XG4gICAgY29uc3QgeyBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG9uRXJyb3IgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGEsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGVkZ2VJZHMgPSB1c2VWaXNpYmxlRWRnZUlkcyhvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZXNcIiwgY2hpbGRyZW46IFtqc3goTWFya2VyRGVmaW5pdGlvbnMkMSwgeyBkZWZhdWx0Q29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgcmZJZDogcmZJZCB9KSwgZWRnZUlkcy5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChqc3goRWRnZVdyYXBwZXIsIHsgaWQ6IGlkLCBlZGdlc0ZvY3VzYWJsZTogZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZTogZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBvblJlY29ubmVjdDogb25SZWNvbm5lY3QsIG9uQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbk1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25DbGljazogb25FZGdlQ2xpY2ssIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvbkRvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCByZklkOiByZklkLCBvbkVycm9yOiBvbkVycm9yLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9LCBpZCkpO1xuICAgICAgICAgICAgfSldIH0pKTtcbn1cbkVkZ2VSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdFZGdlUmVuZGVyZXInO1xuY29uc3QgRWRnZVJlbmRlcmVyID0gbWVtbyhFZGdlUmVuZGVyZXJDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3RvciQ5ID0gKHMpID0+IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSlgO1xuZnVuY3Rpb24gVmlld3BvcnQoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdXNlU3RvcmUoc2VsZWN0b3IkOSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fdmlld3BvcnQgeHlmbG93X192aWV3cG9ydCByZWFjdC1mbG93X19jb250YWluZXJcIiwgc3R5bGU6IHsgdHJhbnNmb3JtIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbi8qKlxuICogSG9vayBmb3IgY2FsbGluZyBvbkluaXQgaGFuZGxlci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlT25Jbml0SGFuZGxlcihvbkluaXQpIHtcbiAgICBjb25zdCByZkluc3RhbmNlID0gdXNlUmVhY3RGbG93KCk7XG4gICAgY29uc3QgaXNJbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0luaXRpYWxpemVkLmN1cnJlbnQgJiYgcmZJbnN0YW5jZS52aWV3cG9ydEluaXRpYWxpemVkICYmIG9uSW5pdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBvbkluaXQocmZJbnN0YW5jZSksIDEpO1xuICAgICAgICAgICAgaXNJbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkluaXQsIHJmSW5zdGFuY2Uudmlld3BvcnRJbml0aWFsaXplZF0pO1xufVxuXG5jb25zdCBzZWxlY3RvciQ4ID0gKHN0YXRlKSA9PiBzdGF0ZS5wYW5ab29tPy5zeW5jVmlld3BvcnQ7XG4vKipcbiAqIEhvb2sgZm9yIHN5bmNpbmcgdGhlIHZpZXdwb3J0IHdpdGggdGhlIHBhbnpvb20gaW5zdGFuY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gdmlld3BvcnRcbiAqL1xuZnVuY3Rpb24gdXNlVmlld3BvcnRTeW5jKHZpZXdwb3J0KSB7XG4gICAgY29uc3Qgc3luY1ZpZXdwb3J0ID0gdXNlU3RvcmUoc2VsZWN0b3IkOCk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgICAgICAgc3luY1ZpZXdwb3J0Py4odmlld3BvcnQpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB0cmFuc2Zvcm06IFt2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC56b29tXSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFt2aWV3cG9ydCwgc3luY1ZpZXdwb3J0XSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHN0b3JlU2VsZWN0b3IkMShzKSB7XG4gICAgcmV0dXJuIHMuY29ubmVjdGlvbi5pblByb2dyZXNzXG4gICAgICAgID8geyAuLi5zLmNvbm5lY3Rpb24sIHRvOiBwb2ludFRvUmVuZGVyZXJQb2ludChzLmNvbm5lY3Rpb24udG8sIHMudHJhbnNmb3JtKSB9XG4gICAgICAgIDogeyAuLi5zLmNvbm5lY3Rpb24gfTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKGNvbm5lY3Rpb25TZWxlY3Rvcikge1xuICAgIGlmIChjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRTZWxlY3RvciA9IChzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gc3RvcmVTZWxlY3RvciQxKHMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25TZWxlY3Rvcihjb25uZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkU2VsZWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBzdG9yZVNlbGVjdG9yJDE7XG59XG4vKipcbiAqIFRoZSBgdXNlQ29ubmVjdGlvbmAgaG9vayByZXR1cm5zIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gd2hlbiB0aGVyZSBpcyBhbiBhY3RpdmVcbiAqIGNvbm5lY3Rpb24gaW50ZXJhY3Rpb24uIElmIG5vIGNvbm5lY3Rpb24gaW50ZXJhY3Rpb24gaXMgYWN0aXZlLCBpdCByZXR1cm5zIG51bGxcbiAqIGZvciBldmVyeSBwcm9wZXJ0eS4gQSB0eXBpY2FsIHVzZSBjYXNlIGZvciB0aGlzIGhvb2sgaXMgdG8gY29sb3JpemUgaGFuZGxlc1xuICogYmFzZWQgb24gYSBjZXJ0YWluIGNvbmRpdGlvbiAoZS5nLiBpZiB0aGUgY29ubmVjdGlvbiBpcyB2YWxpZCBvciBub3QpLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBjb25uZWN0aW9uU2VsZWN0b3IgLSBBbiBvcHRpb25hbCBzZWxlY3RvciBmdW5jdGlvbiB1c2VkIHRvIGV4dHJhY3QgYSBzbGljZSBvZiB0aGVcbiAqIGBDb25uZWN0aW9uU3RhdGVgIGRhdGEuIFVzaW5nIGEgc2VsZWN0b3IgY2FuIHByZXZlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMgd2hlcmUgZGF0YSB5b3UgZG9uJ3RcbiAqIG90aGVyd2lzZSBjYXJlIGFib3V0IG1pZ2h0IGNoYW5nZS4gSWYgYSBzZWxlY3RvciBpcyBub3QgcHJvdmlkZWQsIHRoZSBlbnRpcmUgYENvbm5lY3Rpb25TdGF0ZWBcbiAqIG9iamVjdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VDb25uZWN0aW9uIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBBcHAoKSB7XG4gKiAgY29uc3QgY29ubmVjdGlvbiA9IHVzZUNvbm5lY3Rpb24oKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+IHtjb25uZWN0aW9uID8gYFNvbWVvbmUgaXMgdHJ5aW5nIHRvIG1ha2UgYSBjb25uZWN0aW9uIGZyb20gJHtjb25uZWN0aW9uLmZyb21Ob2RlfSB0byB0aGlzIG9uZS5gIDogJ1RoZXJlIGFyZSBjdXJyZW50bHkgbm8gaW5jb21pbmcgY29ubmVjdGlvbnMhJ31cbiAqXG4gKiAgIDwvZGl2PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQHJldHVybnMgQ29ubmVjdGlvblN0YXRlXG4gKi9cbmZ1bmN0aW9uIHVzZUNvbm5lY3Rpb24oY29ubmVjdGlvblNlbGVjdG9yKSB7XG4gICAgY29uc3QgY29tYmluZWRTZWxlY3RvciA9IGdldFNlbGVjdG9yKGNvbm5lY3Rpb25TZWxlY3Rvcik7XG4gICAgcmV0dXJuIHVzZVN0b3JlKGNvbWJpbmVkU2VsZWN0b3IsIHNoYWxsb3cpO1xufVxuXG5jb25zdCBzZWxlY3RvciQ3ID0gKHMpID0+ICh7XG4gICAgbm9kZXNDb25uZWN0YWJsZTogcy5ub2Rlc0Nvbm5lY3RhYmxlLFxuICAgIGlzVmFsaWQ6IHMuY29ubmVjdGlvbi5pc1ZhbGlkLFxuICAgIGluUHJvZ3Jlc3M6IHMuY29ubmVjdGlvbi5pblByb2dyZXNzLFxuICAgIHdpZHRoOiBzLndpZHRoLFxuICAgIGhlaWdodDogcy5oZWlnaHQsXG59KTtcbmZ1bmN0aW9uIENvbm5lY3Rpb25MaW5lV3JhcHBlcih7IGNvbnRhaW5lclN0eWxlLCBzdHlsZSwgdHlwZSwgY29tcG9uZW50LCB9KSB7XG4gICAgY29uc3QgeyBub2Rlc0Nvbm5lY3RhYmxlLCB3aWR0aCwgaGVpZ2h0LCBpc1ZhbGlkLCBpblByb2dyZXNzIH0gPSB1c2VTdG9yZShzZWxlY3RvciQ3LCBzaGFsbG93KTtcbiAgICBjb25zdCByZW5kZXJDb25uZWN0aW9uID0gISEod2lkdGggJiYgbm9kZXNDb25uZWN0YWJsZSAmJiBpblByb2dyZXNzKTtcbiAgICBpZiAoIXJlbmRlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgc3R5bGU6IGNvbnRhaW5lclN0eWxlLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29ubmVjdGlvbmxpbmUgcmVhY3QtZmxvd19fY29udGFpbmVyXCIsIGNoaWxkcmVuOiBqc3goXCJnXCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2Nvbm5lY3Rpb24nLCBnZXRDb25uZWN0aW9uU3RhdHVzKGlzVmFsaWQpXSksIGNoaWxkcmVuOiBqc3goQ29ubmVjdGlvbkxpbmUsIHsgc3R5bGU6IHN0eWxlLCB0eXBlOiB0eXBlLCBDdXN0b21Db21wb25lbnQ6IGNvbXBvbmVudCwgaXNWYWxpZDogaXNWYWxpZCB9KSB9KSB9KSk7XG59XG5jb25zdCBDb25uZWN0aW9uTGluZSA9ICh7IHN0eWxlLCB0eXBlID0gQ29ubmVjdGlvbkxpbmVUeXBlLkJlemllciwgQ3VzdG9tQ29tcG9uZW50LCBpc1ZhbGlkLCB9KSA9PiB7XG4gICAgY29uc3QgeyBpblByb2dyZXNzLCBmcm9tLCBmcm9tTm9kZSwgZnJvbUhhbmRsZSwgZnJvbVBvc2l0aW9uLCB0bywgdG9Ob2RlLCB0b0hhbmRsZSwgdG9Qb3NpdGlvbiB9ID0gdXNlQ29ubmVjdGlvbigpO1xuICAgIGlmICghaW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChDdXN0b21Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIChqc3goQ3VzdG9tQ29tcG9uZW50LCB7IGNvbm5lY3Rpb25MaW5lVHlwZTogdHlwZSwgY29ubmVjdGlvbkxpbmVTdHlsZTogc3R5bGUsIGZyb21Ob2RlOiBmcm9tTm9kZSwgZnJvbUhhbmRsZTogZnJvbUhhbmRsZSwgZnJvbVg6IGZyb20ueCwgZnJvbVk6IGZyb20ueSwgdG9YOiB0by54LCB0b1k6IHRvLnksIGZyb21Qb3NpdGlvbjogZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uOiB0b1Bvc2l0aW9uLCBjb25uZWN0aW9uU3RhdHVzOiBnZXRDb25uZWN0aW9uU3RhdHVzKGlzVmFsaWQpLCB0b05vZGU6IHRvTm9kZSwgdG9IYW5kbGU6IHRvSGFuZGxlIH0pKTtcbiAgICB9XG4gICAgbGV0IHBhdGggPSAnJztcbiAgICBjb25zdCBwYXRoUGFyYW1zID0ge1xuICAgICAgICBzb3VyY2VYOiBmcm9tLngsXG4gICAgICAgIHNvdXJjZVk6IGZyb20ueSxcbiAgICAgICAgc291cmNlUG9zaXRpb246IGZyb21Qb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0WDogdG8ueCxcbiAgICAgICAgdGFyZ2V0WTogdG8ueSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb246IHRvUG9zaXRpb24sXG4gICAgfTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0QmV6aWVyUGF0aChwYXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5TaW1wbGVCZXppZXI6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTaW1wbGVCZXppZXJQYXRoKHBhdGhQYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLlN0ZXA6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gICAgICAgICAgICAgICAgLi4ucGF0aFBhcmFtcyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5TbW9vdGhTdGVwOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U21vb3RoU3RlcFBhdGgocGF0aFBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFN0cmFpZ2h0UGF0aChwYXRoUGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzeChcInBhdGhcIiwgeyBkOiBwYXRoLCBmaWxsOiBcIm5vbmVcIiwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2Nvbm5lY3Rpb24tcGF0aFwiLCBzdHlsZTogc3R5bGUgfSk7XG59O1xuQ29ubmVjdGlvbkxpbmUuZGlzcGxheU5hbWUgPSAnQ29ubmVjdGlvbkxpbmUnO1xuXG5jb25zdCBlbXB0eVR5cGVzID0ge307XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyhub2RlT3JFZGdlVHlwZXMgPSBlbXB0eVR5cGVzKSB7XG4gICAgY29uc3QgdHlwZXNSZWYgPSB1c2VSZWYobm9kZU9yRWRnZVR5cGVzKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VkS2V5cyA9IG5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKHR5cGVzUmVmLmN1cnJlbnQpLCAuLi5PYmplY3Qua2V5cyhub2RlT3JFZGdlVHlwZXMpXSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1c2VkS2V5cykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlc1JlZi5jdXJyZW50W2tleV0gIT09IG5vZGVPckVkZ2VUeXBlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMDInLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwMiddKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlc1JlZi5jdXJyZW50ID0gbm9kZU9yRWRnZVR5cGVzO1xuICAgICAgICB9XG4gICAgfSwgW25vZGVPckVkZ2VUeXBlc10pO1xufVxuXG5mdW5jdGlvbiB1c2VTdHlsZXNMb2FkZWRXYXJuaW5nKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBjaGVja2VkID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X19wYW5lJyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhbmUgJiYgISh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYW5lKS56SW5kZXggPT09ICcxJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAxMycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEzJ10oJ3JlYWN0JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGVja2VkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBHcmFwaFZpZXdDb21wb25lbnQoeyBub2RlVHlwZXMsIGVkZ2VUeXBlcywgb25Jbml0LCBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2ssIG9uTm9kZURvdWJsZUNsaWNrLCBvbkVkZ2VEb3VibGVDbGljaywgb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudSwgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIGNvbm5lY3Rpb25MaW5lVHlwZSwgY29ubmVjdGlvbkxpbmVTdHlsZSwgY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZywgc2VsZWN0aW9uTW9kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBkZWxldGVLZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBlbGVtZW50c1NlbGVjdGFibGUsIGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tLCBtYXhab29tLCBwcmV2ZW50U2Nyb2xsaW5nLCBkZWZhdWx0TWFya2VyQ29sb3IsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGUsIHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PbkRyYWcsIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbCwgb25QYW5lQ29udGV4dE1lbnUsIHBhbmVDbGlja0Rpc3RhbmNlLCBub2RlQ2xpY2tEaXN0YW5jZSwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIG5vZGVFeHRlbnQsIHJmSWQsIHZpZXdwb3J0LCBvblZpZXdwb3J0Q2hhbmdlLCB9KSB7XG4gICAgdXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyhub2RlVHlwZXMpO1xuICAgIHVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmcoZWRnZVR5cGVzKTtcbiAgICB1c2VTdHlsZXNMb2FkZWRXYXJuaW5nKCk7XG4gICAgdXNlT25Jbml0SGFuZGxlcihvbkluaXQpO1xuICAgIHVzZVZpZXdwb3J0U3luYyh2aWV3cG9ydCk7XG4gICAgcmV0dXJuIChqc3goRmxvd1JlbmRlcmVyLCB7IG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIHBhbmVDbGlja0Rpc3RhbmNlOiBwYW5lQ2xpY2tEaXN0YW5jZSwgZGVsZXRlS2V5Q29kZTogZGVsZXRlS2V5Q29kZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlOiBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlOiBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlOiB6b29tQWN0aXZhdGlvbktleUNvZGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGw6IHpvb21PblNjcm9sbCwgem9vbU9uUGluY2g6IHpvb21PblBpbmNoLCB6b29tT25Eb3VibGVDbGljazogem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uU2Nyb2xsOiBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZDogcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlOiBwYW5PblNjcm9sbE1vZGUsIHBhbk9uRHJhZzogcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIG5vRHJhZ0NsYXNzTmFtZTogbm9EcmFnQ2xhc3NOYW1lLCBub1doZWVsQ2xhc3NOYW1lOiBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXksIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0OiAhIXZpZXdwb3J0LCBjaGlsZHJlbjoganN4cyhWaWV3cG9ydCwgeyBjaGlsZHJlbjogW2pzeChFZGdlUmVuZGVyZXIsIHsgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIG9uRWRnZUNsaWNrOiBvbkVkZ2VDbGljaywgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvblJlY29ubmVjdDogb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQ6IG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kOiBvblJlY29ubmVjdEVuZCwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgb25FZGdlQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXksIHJmSWQ6IHJmSWQgfSksIGpzeChDb25uZWN0aW9uTGluZVdyYXBwZXIsIHsgc3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIHR5cGU6IGNvbm5lY3Rpb25MaW5lVHlwZSwgY29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29udGFpbmVyU3R5bGU6IGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlbGFiZWwtcmVuZGVyZXJcIiB9KSwganN4KE5vZGVSZW5kZXJlciwgeyBub2RlVHlwZXM6IG5vZGVUeXBlcywgb25Ob2RlQ2xpY2s6IG9uTm9kZUNsaWNrLCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG9uTm9kZU1vdXNlRW50ZXI6IG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZTogb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlOiBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudTogb25Ob2RlQ29udGV4dE1lbnUsIG5vZGVDbGlja0Rpc3RhbmNlOiBub2RlQ2xpY2tEaXN0YW5jZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgcmZJZDogcmZJZCB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3ZpZXdwb3J0LXBvcnRhbFwiIH0pXSB9KSB9KSk7XG59XG5HcmFwaFZpZXdDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnR3JhcGhWaWV3JztcbmNvbnN0IEdyYXBoVmlldyA9IG1lbW8oR3JhcGhWaWV3Q29tcG9uZW50KTtcblxuY29uc3QgZ2V0SW5pdGlhbFN0YXRlID0gKHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldywgZml0Vmlld09wdGlvbnMsIG1pblpvb20gPSAwLjUsIG1heFpvb20gPSAyLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB9ID0ge30pID0+IHtcbiAgICBjb25zdCBub2RlTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHBhcmVudExvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBjb25uZWN0aW9uTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVkZ2VMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgc3RvcmVFZGdlcyA9IGRlZmF1bHRFZGdlcyA/PyBlZGdlcyA/PyBbXTtcbiAgICBjb25zdCBzdG9yZU5vZGVzID0gZGVmYXVsdE5vZGVzID8/IG5vZGVzID8/IFtdO1xuICAgIGNvbnN0IHN0b3JlTm9kZU9yaWdpbiA9IG5vZGVPcmlnaW4gPz8gWzAsIDBdO1xuICAgIGNvbnN0IHN0b3JlTm9kZUV4dGVudCA9IG5vZGVFeHRlbnQgPz8gaW5maW5pdGVFeHRlbnQ7XG4gICAgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBzdG9yZUVkZ2VzKTtcbiAgICBjb25zdCBub2Rlc0luaXRpYWxpemVkID0gYWRvcHRVc2VyTm9kZXMoc3RvcmVOb2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7XG4gICAgICAgIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbixcbiAgICAgICAgbm9kZUV4dGVudDogc3RvcmVOb2RlRXh0ZW50LFxuICAgICAgICBlbGV2YXRlTm9kZXNPblNlbGVjdDogZmFsc2UsXG4gICAgfSk7XG4gICAgbGV0IHRyYW5zZm9ybSA9IFswLCAwLCAxXTtcbiAgICBpZiAoZml0VmlldyAmJiB3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgY29uc3QgYm91bmRzID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2RlTG9va3VwLCB7XG4gICAgICAgICAgICBmaWx0ZXI6IChub2RlKSA9PiAhISgobm9kZS53aWR0aCB8fCBub2RlLmluaXRpYWxXaWR0aCkgJiYgKG5vZGUuaGVpZ2h0IHx8IG5vZGUuaW5pdGlhbEhlaWdodCkpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIGZpdFZpZXdPcHRpb25zPy5wYWRkaW5nID8/IDAuMSk7XG4gICAgICAgIHRyYW5zZm9ybSA9IFt4LCB5LCB6b29tXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmZJZDogJzEnLFxuICAgICAgICB3aWR0aDogd2lkdGggPz8gMCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPz8gMCxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBub2Rlczogc3RvcmVOb2RlcyxcbiAgICAgICAgbm9kZXNJbml0aWFsaXplZCxcbiAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgcGFyZW50TG9va3VwLFxuICAgICAgICBlZGdlczogc3RvcmVFZGdlcyxcbiAgICAgICAgZWRnZUxvb2t1cCxcbiAgICAgICAgY29ubmVjdGlvbkxvb2t1cCxcbiAgICAgICAgb25Ob2Rlc0NoYW5nZTogbnVsbCxcbiAgICAgICAgb25FZGdlc0NoYW5nZTogbnVsbCxcbiAgICAgICAgaGFzRGVmYXVsdE5vZGVzOiBkZWZhdWx0Tm9kZXMgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgaGFzRGVmYXVsdEVkZ2VzOiBkZWZhdWx0RWRnZXMgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgcGFuWm9vbTogbnVsbCxcbiAgICAgICAgbWluWm9vbSxcbiAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgdHJhbnNsYXRlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICAgICAgbm9kZUV4dGVudDogc3RvcmVOb2RlRXh0ZW50LFxuICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB1c2VyU2VsZWN0aW9uUmVjdDogbnVsbCxcbiAgICAgICAgY29ubmVjdGlvbk1vZGU6IENvbm5lY3Rpb25Nb2RlLlN0cmljdCxcbiAgICAgICAgZG9tTm9kZTogbnVsbCxcbiAgICAgICAgcGFuZURyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgbm9QYW5DbGFzc05hbWU6ICdub3BhbicsXG4gICAgICAgIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbixcbiAgICAgICAgbm9kZURyYWdUaHJlc2hvbGQ6IDEsXG4gICAgICAgIGNvbm5lY3Rpb25EcmFnVGhyZXNob2xkOiAxLFxuICAgICAgICBzbmFwR3JpZDogWzE1LCAxNV0sXG4gICAgICAgIHNuYXBUb0dyaWQ6IGZhbHNlLFxuICAgICAgICBub2Rlc0RyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgbm9kZXNDb25uZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgbm9kZXNGb2N1c2FibGU6IHRydWUsXG4gICAgICAgIGVkZ2VzRm9jdXNhYmxlOiB0cnVlLFxuICAgICAgICBlZGdlc1JlY29ubmVjdGFibGU6IHRydWUsXG4gICAgICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IHRydWUsXG4gICAgICAgIGVsZXZhdGVFZGdlc09uU2VsZWN0OiBmYWxzZSxcbiAgICAgICAgc2VsZWN0Tm9kZXNPbkRyYWc6IHRydWUsXG4gICAgICAgIG11bHRpU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgZml0Vmlld1F1ZXVlZDogZml0VmlldyA/PyBmYWxzZSxcbiAgICAgICAgZml0Vmlld09wdGlvbnMsXG4gICAgICAgIGZpdFZpZXdSZXNvbHZlcjogbnVsbCxcbiAgICAgICAgY29ubmVjdGlvbjogeyAuLi5pbml0aWFsQ29ubmVjdGlvbiB9LFxuICAgICAgICBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogbnVsbCxcbiAgICAgICAgY29ubmVjdE9uQ2xpY2s6IHRydWUsXG4gICAgICAgIGFyaWFMaXZlTWVzc2FnZTogJycsXG4gICAgICAgIGF1dG9QYW5PbkNvbm5lY3Q6IHRydWUsXG4gICAgICAgIGF1dG9QYW5Pbk5vZGVEcmFnOiB0cnVlLFxuICAgICAgICBhdXRvUGFuT25Ob2RlRm9jdXM6IHRydWUsXG4gICAgICAgIGF1dG9QYW5TcGVlZDogMTUsXG4gICAgICAgIGNvbm5lY3Rpb25SYWRpdXM6IDIwLFxuICAgICAgICBvbkVycm9yOiBkZXZXYXJuLFxuICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBbXSxcbiAgICAgICAgbGliOiAncmVhY3QnLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIGFyaWFMYWJlbENvbmZpZzogZGVmYXVsdEFyaWFMYWJlbENvbmZpZyxcbiAgICB9O1xufTtcblxuY29uc3QgY3JlYXRlU3RvcmUgPSAoeyBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgbWluWm9vbSwgbWF4Wm9vbSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgfSkgPT4gY3JlYXRlV2l0aEVxdWFsaXR5Rm4oKHNldCwgZ2V0KSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUZpdFZpZXcoKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgcGFuWm9vbSwgZml0Vmlld09wdGlvbnMsIGZpdFZpZXdSZXNvbHZlciwgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGZpdFZpZXdwb3J0KHtcbiAgICAgICAgICAgIG5vZGVzOiBub2RlTG9va3VwLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBwYW5ab29tLFxuICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb20sXG4gICAgICAgIH0sIGZpdFZpZXdPcHRpb25zKTtcbiAgICAgICAgZml0Vmlld1Jlc29sdmVyPy5yZXNvbHZlKHRydWUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogd2FpdCBmb3IgdGhlIGZpdFZpZXdwb3J0IHRvIHJlc29sdmUgYmVmb3JlIGRlbGV0aW5nIHRoZSByZXNvbHZlcixcbiAgICAgICAgICogd2Ugd2FudCB0byByZXVzZSB0aGUgb2xkIHJlc29sdmVyIGlmIHRoZSB1c2VyIGNhbGxzIGZpdFZpZXcgYWdhaW4gaW4gdGhlIG1lYW4gdGltZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0KHsgZml0Vmlld1Jlc29sdmVyOiBudWxsIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5nZXRJbml0aWFsU3RhdGUoe1xuICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgZml0VmlldyxcbiAgICAgICAgICAgIGZpdFZpZXdPcHRpb25zLFxuICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb20sXG4gICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgbm9kZUV4dGVudCxcbiAgICAgICAgICAgIGRlZmF1bHROb2RlcyxcbiAgICAgICAgICAgIGRlZmF1bHRFZGdlcyxcbiAgICAgICAgfSksXG4gICAgICAgIHNldE5vZGVzOiAobm9kZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luLCBlbGV2YXRlTm9kZXNPblNlbGVjdCwgZml0Vmlld1F1ZXVlZCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogc2V0Tm9kZXMoKSBpcyBjYWxsZWQgZXhjbHVzaXZlbHkgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zOlxuICAgICAgICAgICAgICogLSBlaXRoZXIgd2hlbiB0aGUgYDxSZWFjdEZsb3cgbm9kZXM+YCBwcm9wIGlzIHVwZGF0ZWQgaW4gdGhlIGNvbnRyb2xsZWQgUmVhY3RGbG93IHNldHVwLFxuICAgICAgICAgICAgICogLSBvciB3aGVuIHRoZSB1c2VyIGNhbGxzIHNvbWV0aGluZyBsaWtlIGByZWFjdEZsb3dJbnN0YW5jZS5zZXROb2RlcygpYCBpbiBhbiB1bmNvbnRyb2xsZWQgUmVhY3RGbG93IHNldHVwLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFdoZW4gdGhpcyBoYXBwZW5zLCB3ZSB0YWtlIHRoZSBub3RlIG9iamVjdHMgcGFzc2VkIGJ5IHRoZSB1c2VyIGFuZCBleHRlbmQgdGhlbSB3aXRoIGZpZWxkc1xuICAgICAgICAgICAgICogcmVsZXZhbnQgZm9yIGludGVybmFsIFJlYWN0IEZsb3cgb3BlcmF0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgbm9kZXNJbml0aWFsaXplZCA9IGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3QsXG4gICAgICAgICAgICAgICAgY2hlY2tFcXVhbGl0eTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGZpdFZpZXdRdWV1ZWQgJiYgbm9kZXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVGaXRWaWV3KCk7XG4gICAgICAgICAgICAgICAgc2V0KHsgbm9kZXMsIG5vZGVzSW5pdGlhbGl6ZWQsIGZpdFZpZXdRdWV1ZWQ6IGZhbHNlLCBmaXRWaWV3T3B0aW9uczogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0KHsgbm9kZXMsIG5vZGVzSW5pdGlhbGl6ZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldEVkZ2VzOiAoZWRnZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uTG9va3VwKGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAsIGVkZ2VzKTtcbiAgICAgICAgICAgIHNldCh7IGVkZ2VzIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlczogKG5vZGVzLCBlZGdlcykgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICAgICAgc2V0Tm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgICAgIHNldCh7IGhhc0RlZmF1bHROb2RlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlZGdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2V0RWRnZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgICAgIHNldEVkZ2VzKGVkZ2VzKTtcbiAgICAgICAgICAgICAgICBzZXQoeyBoYXNEZWZhdWx0RWRnZXM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qXG4gICAgICAgICAqIEV2ZXJ5IG5vZGUgZ2V0cyByZWdpc3RlcmQgYXQgYSBSZXNpemVPYnNlcnZlci4gV2hlbmV2ZXIgYSBub2RlXG4gICAgICAgICAqIGNoYW5nZXMgaXRzIGRpbWVuc2lvbnMsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIG1lYXN1cmUgdGhlXG4gICAgICAgICAqIG5ldyBkaW1lbnNpb25zIGFuZCB1cGRhdGUgdGhlIG5vZGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlTm9kZUludGVybmFsczogKHVwZGF0ZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJpZ2dlck5vZGVDaGFuZ2VzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIGRlYnVnLCBmaXRWaWV3UXVldWVkIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhbmdlcywgdXBkYXRlZEludGVybmFscyB9ID0gdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQpO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGVkSW50ZXJuYWxzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMobm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7IG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQgfSk7XG4gICAgICAgICAgICBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVGaXRWaWV3KCk7XG4gICAgICAgICAgICAgICAgc2V0KHsgZml0Vmlld1F1ZXVlZDogZmFsc2UsIGZpdFZpZXdPcHRpb25zOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhbHdheXMgd2FudCB0byB0cmlnZ2VyIHVzZVN0b3JlIGNhbGxzIHdoZW5ldmVyIHVwZGF0ZU5vZGVJbnRlcm5hbHMgaXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgc2V0KHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIG5vZGUgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXM/LihjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9uczogKG5vZGVEcmFnSXRlbXMsIGRyYWdnaW5nID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoaWxkcmVuID0gW107XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgZHJhZ0l0ZW1dIG9mIG5vZGVEcmFnSXRlbXMpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgdXNpbmcgdGhlIG5vZGVsb29rdXAgdG8gYmUgc3VyZSB0byB1c2UgdGhlIGN1cnJlbnQgZXhwYW5kUGFyZW50IGFuZCBwYXJlbnRJZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwYW5kUGFyZW50ID0gISEobm9kZT8uZXhwYW5kUGFyZW50ICYmIG5vZGU/LnBhcmVudElkICYmIGRyYWdJdGVtPy5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cGFuZFBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogTWF0aC5tYXgoMCwgZHJhZ0l0ZW0ucG9zaXRpb24ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5tYXgoMCwgZHJhZ0l0ZW0ucG9zaXRpb24ueSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRyYWdJdGVtLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmRQYXJlbnQgJiYgbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRFeHBhbmRDaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZHJhZ0l0ZW0uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGRyYWdJdGVtLm1lYXN1cmVkLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBkcmFnSXRlbS5tZWFzdXJlZC5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnRFeHBhbmRDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4gfSA9IGdldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQocGFyZW50RXhwYW5kQ2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKC4uLnBhcmVudEV4cGFuZENoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXM6IChjaGFuZ2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uTm9kZXNDaGFuZ2UsIHNldE5vZGVzLCBub2RlcywgaGFzRGVmYXVsdE5vZGVzLCBkZWJ1ZyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkTm9kZXMgPSBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Tm9kZXModXBkYXRlZE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIG5vZGUgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlczogKGNoYW5nZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25FZGdlc0NoYW5nZSwgc2V0RWRnZXMsIGVkZ2VzLCBoYXNEZWZhdWx0RWRnZXMsIGRlYnVnIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRFZGdlcyA9IGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpO1xuICAgICAgICAgICAgICAgICAgICBzZXRFZGdlcyh1cGRhdGVkRWRnZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlYWN0IEZsb3c6IHRyaWdnZXIgZWRnZSBjaGFuZ2VzJywgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2U/LihjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkU2VsZWN0ZWROb2RlczogKHNlbGVjdGVkTm9kZUlkcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgZWRnZUxvb2t1cCwgbm9kZUxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKG11bHRpU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBzZWxlY3RlZE5vZGVJZHMubWFwKChub2RlSWQpID0+IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShub2RlSWQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKG5vZGVMb29rdXAsIG5ldyBTZXQoWy4uLnNlbGVjdGVkTm9kZUlkc10pLCB0cnVlKSk7XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlTG9va3VwKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFNlbGVjdGVkRWRnZXM6IChzZWxlY3RlZEVkZ2VJZHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VMb29rdXAsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChtdWx0aVNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRFZGdlcyA9IHNlbGVjdGVkRWRnZUlkcy5tYXAoKGVkZ2VJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2VJZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhjaGFuZ2VkRWRnZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKGVkZ2VMb29rdXAsIG5ldyBTZXQoWy4uLnNlbGVjdGVkRWRnZUlkc10pKSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2RlTG9va3VwLCBuZXcgU2V0KCksIHRydWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzOiAoeyBub2RlcywgZWRnZXMgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzOiBzdG9yZUVkZ2VzLCBub2Rlczogc3RvcmVOb2Rlcywgbm9kZUxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXNUb1Vuc2VsZWN0ID0gbm9kZXMgPyBub2RlcyA6IHN0b3JlTm9kZXM7XG4gICAgICAgICAgICBjb25zdCBlZGdlc1RvVW5zZWxlY3QgPSBlZGdlcyA/IGVkZ2VzIDogc3RvcmVFZGdlcztcbiAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gbm9kZXNUb1Vuc2VsZWN0Lm1hcCgobikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsTm9kZSA9IG5vZGVMb29rdXAuZ2V0KG4uaWQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogd2UgbmVlZCB0byB1bnNlbGVjdCB0aGUgaW50ZXJuYWwgbm9kZSB0aGF0IHdhcyBzZWxlY3RlZCBwcmV2aW91c2x5IGJlZm9yZSB3ZVxuICAgICAgICAgICAgICAgICAgICAgKiBzZW5kIHRoZSBjaGFuZ2UgdG8gdGhlIHVzZXIgdG8gcHJldmVudCBpdCB0byBiZSBzZWxlY3RlZCB3aGlsZSBkcmFnZ2luZyB0aGUgbmV3IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsTm9kZS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKG4uaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBlZGdlc1RvVW5zZWxlY3QubWFwKChlZGdlKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoZWRnZS5pZCwgZmFsc2UpKTtcbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhub2RlQ2hhbmdlcyk7XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZWRnZUNoYW5nZXMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRNaW5ab29tOiAobWluWm9vbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tLCBtYXhab29tIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIHBhblpvb20/LnNldFNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSk7XG4gICAgICAgICAgICBzZXQoeyBtaW5ab29tIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRNYXhab29tOiAobWF4Wm9vbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tLCBtaW5ab29tIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIHBhblpvb20/LnNldFNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSk7XG4gICAgICAgICAgICBzZXQoeyBtYXhab29tIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRUcmFuc2xhdGVFeHRlbnQ6ICh0cmFuc2xhdGVFeHRlbnQpID0+IHtcbiAgICAgICAgICAgIGdldCgpLnBhblpvb20/LnNldFRyYW5zbGF0ZUV4dGVudCh0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICAgICAgc2V0KHsgdHJhbnNsYXRlRXh0ZW50IH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQYW5lQ2xpY2tEaXN0YW5jZTogKGNsaWNrRGlzdGFuY2UpID0+IHtcbiAgICAgICAgICAgIGdldCgpLnBhblpvb20/LnNldENsaWNrRGlzdGFuY2UoY2xpY2tEaXN0YW5jZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0U2VsZWN0ZWRFbGVtZW50czogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgbm9kZXMsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzLCBlbGVtZW50c1NlbGVjdGFibGUgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50c1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG5vZGVzLnJlZHVjZSgocmVzLCBub2RlKSA9PiAobm9kZS5zZWxlY3RlZCA/IFsuLi5yZXMsIGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShub2RlLmlkLCBmYWxzZSldIDogcmVzKSwgW10pO1xuICAgICAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBlZGdlcy5yZWR1Y2UoKHJlcywgZWRnZSkgPT4gKGVkZ2Uuc2VsZWN0ZWQgPyBbLi4ucmVzLCBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoZWRnZS5pZCwgZmFsc2UpXSA6IHJlcyksIFtdKTtcbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhub2RlQ2hhbmdlcyk7XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZWRnZUNoYW5nZXMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXROb2RlRXh0ZW50OiAobmV4dE5vZGVFeHRlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QsIG5vZGVFeHRlbnQgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKG5leHROb2RlRXh0ZW50WzBdWzBdID09PSBub2RlRXh0ZW50WzBdWzBdICYmXG4gICAgICAgICAgICAgICAgbmV4dE5vZGVFeHRlbnRbMF1bMV0gPT09IG5vZGVFeHRlbnRbMF1bMV0gJiZcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZUV4dGVudFsxXVswXSA9PT0gbm9kZUV4dGVudFsxXVswXSAmJlxuICAgICAgICAgICAgICAgIG5leHROb2RlRXh0ZW50WzFdWzFdID09PSBub2RlRXh0ZW50WzFdWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRvcHRVc2VyTm9kZXMobm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwge1xuICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgbm9kZUV4dGVudDogbmV4dE5vZGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3QsXG4gICAgICAgICAgICAgICAgY2hlY2tFcXVhbGl0eTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldCh7IG5vZGVFeHRlbnQ6IG5leHROb2RlRXh0ZW50IH0pO1xuICAgICAgICB9LFxuICAgICAgICBwYW5CeTogKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgd2lkdGgsIGhlaWdodCwgcGFuWm9vbSwgdHJhbnNsYXRlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBwYW5CeSh7IGRlbHRhLCBwYW5ab29tLCB0cmFuc2Zvcm0sIHRyYW5zbGF0ZUV4dGVudCwgd2lkdGgsIGhlaWdodCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q2VudGVyOiBhc3luYyAoeCwgeSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBtYXhab29tLCBwYW5ab29tIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dFpvb20gPSB0eXBlb2Ygb3B0aW9ucz8uem9vbSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnpvb20gOiBtYXhab29tO1xuICAgICAgICAgICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh7XG4gICAgICAgICAgICAgICAgeDogd2lkdGggLyAyIC0geCAqIG5leHRab29tLFxuICAgICAgICAgICAgICAgIHk6IGhlaWdodCAvIDIgLSB5ICogbmV4dFpvb20sXG4gICAgICAgICAgICAgICAgem9vbTogbmV4dFpvb20sXG4gICAgICAgICAgICB9LCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiwgZWFzZTogb3B0aW9ucz8uZWFzZSwgaW50ZXJwb2xhdGU6IG9wdGlvbnM/LmludGVycG9sYXRlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsQ29ubmVjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiB7IC4uLmluaXRpYWxDb25uZWN0aW9uIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlQ29ubmVjdGlvbjogKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHNldCh7IGNvbm5lY3Rpb24gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiAoKSA9PiBzZXQoeyAuLi5nZXRJbml0aWFsU3RhdGUoKSB9KSxcbiAgICB9O1xufSwgT2JqZWN0LmlzKTtcblxuLyoqXG4gKiBUaGUgYDxSZWFjdEZsb3dQcm92aWRlciAvPmAgY29tcG9uZW50IGlzIGEgW2NvbnRleHQgcHJvdmlkZXJdKGh0dHBzOi8vcmVhY3QuZGV2L2xlYXJuL3Bhc3NpbmctZGF0YS1kZWVwbHktd2l0aC1jb250ZXh0IylcbiAqIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gYWNjZXNzIGEgZmxvdydzIGludGVybmFsIHN0YXRlIG91dHNpZGUgb2YgdGhlXG4gKiBbYDxSZWFjdEZsb3cgLz5gXSgvYXBpLXJlZmVyZW5jZS9yZWFjdC1mbG93KSBjb21wb25lbnQuIE1hbnkgb2YgdGhlIGhvb2tzIHdlXG4gKiBwcm92aWRlIHJlbHkgb24gdGhpcyBjb21wb25lbnQgdG8gd29yay5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgUmVhY3RGbG93UHJvdmlkZXIsIHVzZU5vZGVzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCdcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3dQcm92aWRlcj5cbiAqICAgICAgPFJlYWN0RmxvdyBub2Rlcz17Li4ufSBlZGdlcz17Li4ufSAvPlxuICogICAgICA8U2lkZWJhciAvPlxuICogICAgPC9SZWFjdEZsb3dQcm92aWRlcj5cbiAqICApO1xuICp9XG4gKlxuICpmdW5jdGlvbiBTaWRlYmFyKCkge1xuICogIC8vIFRoaXMgaG9vayB3aWxsIG9ubHkgd29yayBpZiB0aGUgY29tcG9uZW50IGl0J3MgdXNlZCBpbiBpcyBhIGNoaWxkIG9mIGFcbiAqICAvLyA8UmVhY3RGbG93UHJvdmlkZXIgLz4uXG4gKiAgY29uc3Qgbm9kZXMgPSB1c2VOb2RlcygpXG4gKlxuICogIHJldHVybiA8YXNpZGU+ZG8gc29tZXRoaW5nIHdpdGggbm9kZXM8L2FzaWRlPjtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBJZiB5b3UncmUgdXNpbmcgYSByb3V0ZXIgYW5kIHdhbnQgeW91ciBmbG93J3Mgc3RhdGUgdG8gcGVyc2lzdCBhY3Jvc3Mgcm91dGVzLFxuICogaXQncyB2aXRhbCB0aGF0IHlvdSBwbGFjZSB0aGUgYDxSZWFjdEZsb3dQcm92aWRlciAvPmAgY29tcG9uZW50IF9vdXRzaWRlXyBvZlxuICogeW91ciByb3V0ZXIuIElmIHlvdSBoYXZlIG11bHRpcGxlIGZsb3dzIG9uIHRoZSBzYW1lIHBhZ2UgeW91IHdpbGwgbmVlZCB0byB1c2UgYSBzZXBhcmF0ZVxuICogYDxSZWFjdEZsb3dQcm92aWRlciAvPmAgZm9yIGVhY2ggZmxvdy5cbiAqL1xuZnVuY3Rpb24gUmVhY3RGbG93UHJvdmlkZXIoeyBpbml0aWFsTm9kZXM6IG5vZGVzLCBpbml0aWFsRWRnZXM6IGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgaW5pdGlhbFdpZHRoOiB3aWR0aCwgaW5pdGlhbEhlaWdodDogaGVpZ2h0LCBpbml0aWFsTWluWm9vbTogbWluWm9vbSwgaW5pdGlhbE1heFpvb206IG1heFpvb20sIGluaXRpYWxGaXRWaWV3T3B0aW9uczogZml0Vmlld09wdGlvbnMsIGZpdFZpZXcsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIGNoaWxkcmVuLCB9KSB7XG4gICAgY29uc3QgW3N0b3JlXSA9IHVzZVN0YXRlKCgpID0+IGNyZWF0ZVN0b3JlKHtcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIGVkZ2VzLFxuICAgICAgICBkZWZhdWx0Tm9kZXMsXG4gICAgICAgIGRlZmF1bHRFZGdlcyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZml0VmlldyxcbiAgICAgICAgbWluWm9vbSxcbiAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgZml0Vmlld09wdGlvbnMsXG4gICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVFeHRlbnQsXG4gICAgfSkpO1xuICAgIHJldHVybiAoanN4KFByb3ZpZGVyJDEsIHsgdmFsdWU6IHN0b3JlLCBjaGlsZHJlbjoganN4KEJhdGNoUHJvdmlkZXIsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gV3JhcHBlcih7IGNoaWxkcmVuLCBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgbWluWm9vbSwgbWF4Wm9vbSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgfSkge1xuICAgIGNvbnN0IGlzV3JhcHBlZCA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgICBpZiAoaXNXcmFwcGVkKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIHdlIG5lZWQgdG8gd3JhcCBpdCB3aXRoIGEgZnJhZ21lbnQgYmVjYXVzZSBpdCdzIG5vdCBhbGxvd2VkIGZvciBjaGlsZHJlbiB0byBiZSBhIFJlYWN0Tm9kZVxuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vRGVmaW5pdGVseVR5cGVkL0RlZmluaXRlbHlUeXBlZC9pc3N1ZXMvMTgwNTFcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChSZWFjdEZsb3dQcm92aWRlciwgeyBpbml0aWFsTm9kZXM6IG5vZGVzLCBpbml0aWFsRWRnZXM6IGVkZ2VzLCBkZWZhdWx0Tm9kZXM6IGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzOiBkZWZhdWx0RWRnZXMsIGluaXRpYWxXaWR0aDogd2lkdGgsIGluaXRpYWxIZWlnaHQ6IGhlaWdodCwgZml0VmlldzogZml0VmlldywgaW5pdGlhbEZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgaW5pdGlhbE1pblpvb206IG1pblpvb20sIGluaXRpYWxNYXhab29tOiBtYXhab29tLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuXG5jb25zdCB3cmFwcGVyU3R5bGUgPSB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgekluZGV4OiAwLFxufTtcbmZ1bmN0aW9uIFJlYWN0Rmxvdyh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIGNsYXNzTmFtZSwgbm9kZVR5cGVzLCBlZGdlVHlwZXMsIG9uTm9kZUNsaWNrLCBvbkVkZ2VDbGljaywgb25Jbml0LCBvbk1vdmUsIG9uTW92ZVN0YXJ0LCBvbk1vdmVFbmQsIG9uQ29ubmVjdCwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdEVuZCwgb25DbGlja0Nvbm5lY3RTdGFydCwgb25DbGlja0Nvbm5lY3RFbmQsIG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnUsIG9uTm9kZURvdWJsZUNsaWNrLCBvbk5vZGVEcmFnU3RhcnQsIG9uTm9kZURyYWcsIG9uTm9kZURyYWdTdG9wLCBvbk5vZGVzRGVsZXRlLCBvbkVkZ2VzRGVsZXRlLCBvbkRlbGV0ZSwgb25TZWxlY3Rpb25DaGFuZ2UsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0LCBvblNlbGVjdGlvbkRyYWcsIG9uU2VsZWN0aW9uRHJhZ1N0b3AsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBvbkJlZm9yZURlbGV0ZSwgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25MaW5lVHlwZSA9IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIsIGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlLCBkZWxldGVLZXlDb2RlID0gJ0JhY2tzcGFjZScsIHNlbGVjdGlvbktleUNvZGUgPSAnU2hpZnQnLCBzZWxlY3Rpb25PbkRyYWcgPSBmYWxzZSwgc2VsZWN0aW9uTW9kZSA9IFNlbGVjdGlvbk1vZGUuRnVsbCwgcGFuQWN0aXZhdGlvbktleUNvZGUgPSAnU3BhY2UnLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgPSBpc01hY09zKCkgPyAnTWV0YScgOiAnQ29udHJvbCcsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSA9IGlzTWFjT3MoKSA/ICdNZXRhJyA6ICdDb250cm9sJywgc25hcFRvR3JpZCwgc25hcEdyaWQsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMgPSBmYWxzZSwgc2VsZWN0Tm9kZXNPbkRyYWcsIG5vZGVzRHJhZ2dhYmxlLCBhdXRvUGFuT25Ob2RlRm9jdXMsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCBub2RlT3JpZ2luID0gZGVmYXVsdE5vZGVPcmlnaW4sIGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSA9IHRydWUsIGRlZmF1bHRWaWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0JDEgPSBkZWZhdWx0Vmlld3BvcnQsIG1pblpvb20gPSAwLjUsIG1heFpvb20gPSAyLCB0cmFuc2xhdGVFeHRlbnQgPSBpbmZpbml0ZUV4dGVudCwgcHJldmVudFNjcm9sbGluZyA9IHRydWUsIG5vZGVFeHRlbnQsIGRlZmF1bHRNYXJrZXJDb2xvciA9ICcjYjFiMWI3Jywgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBwYW5PbkRyYWcgPSB0cnVlLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51LCBwYW5lQ2xpY2tEaXN0YW5jZSA9IDAsIG5vZGVDbGlja0Rpc3RhbmNlID0gMCwgY2hpbGRyZW4sIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1cyA9IDEwLCBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlLCBub0RyYWdDbGFzc05hbWUgPSAnbm9kcmFnJywgbm9XaGVlbENsYXNzTmFtZSA9ICdub3doZWVsJywgbm9QYW5DbGFzc05hbWUgPSAnbm9wYW4nLCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgY29ubmVjdE9uQ2xpY2ssIGF0dHJpYnV0aW9uUG9zaXRpb24sIHByb09wdGlvbnMsIGRlZmF1bHRFZGdlT3B0aW9ucywgZWxldmF0ZU5vZGVzT25TZWxlY3QsIGVsZXZhdGVFZGdlc09uU2VsZWN0LCBkaXNhYmxlS2V5Ym9hcmRBMTF5ID0gZmFsc2UsIGF1dG9QYW5PbkNvbm5lY3QsIGF1dG9QYW5Pbk5vZGVEcmFnLCBhdXRvUGFuU3BlZWQsIGNvbm5lY3Rpb25SYWRpdXMsIGlzVmFsaWRDb25uZWN0aW9uLCBvbkVycm9yLCBzdHlsZSwgaWQsIG5vZGVEcmFnVGhyZXNob2xkLCBjb25uZWN0aW9uRHJhZ1RocmVzaG9sZCwgdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2UsIHdpZHRoLCBoZWlnaHQsIGNvbG9yTW9kZSA9ICdsaWdodCcsIGRlYnVnLCBvblNjcm9sbCwgYXJpYUxhYmVsQ29uZmlnLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIGNvbnN0IHJmSWQgPSBpZCB8fCAnMSc7XG4gICAgY29uc3QgY29sb3JNb2RlQ2xhc3NOYW1lID0gdXNlQ29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKTtcbiAgICAvLyBVbmRvIHNjcm9sbCBldmVudHMsIHByZXZlbnRpbmcgdmlld3BvcnQgZnJvbSBzaGlmdGluZyB3aGVuIG5vZGVzIG91dHNpZGUgb2YgaXQgYXJlIGZvY3VzZWRcbiAgICBjb25zdCB3cmFwcGVyT25TY3JvbGwgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQuc2Nyb2xsVG8oeyB0b3A6IDAsIGxlZnQ6IDAsIGJlaGF2aW9yOiAnaW5zdGFudCcgfSk7XG4gICAgICAgIG9uU2Nyb2xsPy4oZSk7XG4gICAgfSwgW29uU2Nyb2xsXSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBcImRhdGEtdGVzdGlkXCI6IFwicmZfX3dyYXBwZXJcIiwgLi4ucmVzdCwgb25TY3JvbGw6IHdyYXBwZXJPblNjcm9sbCwgc3R5bGU6IHsgLi4uc3R5bGUsIC4uLndyYXBwZXJTdHlsZSB9LCByZWY6IHJlZiwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3cnLCBjbGFzc05hbWUsIGNvbG9yTW9kZUNsYXNzTmFtZV0pLCBpZDogaWQsIHJvbGU6IFwiYXBwbGljYXRpb25cIiwgY2hpbGRyZW46IGpzeHMoV3JhcHBlciwgeyBub2Rlczogbm9kZXMsIGVkZ2VzOiBlZGdlcywgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgZml0VmlldzogZml0VmlldywgZml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBjaGlsZHJlbjogW2pzeChHcmFwaFZpZXcsIHsgb25Jbml0OiBvbkluaXQsIG9uTm9kZUNsaWNrOiBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyOiBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmU6IG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZTogb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnU6IG9uTm9kZUNvbnRleHRNZW51LCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG5vZGVUeXBlczogbm9kZVR5cGVzLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgY29ubmVjdGlvbkxpbmVUeXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZTogY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCQxLCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBub2RlQ2xpY2tEaXN0YW5jZTogbm9kZUNsaWNrRGlzdGFuY2UsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCB2aWV3cG9ydDogdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UgfSksIGpzeChTdG9yZVVwZGF0ZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgb25Db25uZWN0OiBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0OiBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kOiBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQ6IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kOiBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBhdXRvUGFuT25Ob2RlRm9jdXM6IGF1dG9QYW5Pbk5vZGVGb2N1cywgbm9kZXNDb25uZWN0YWJsZTogbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGU6IG5vZGVzRm9jdXNhYmxlLCBlZGdlc0ZvY3VzYWJsZTogZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZTogZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBlbGV2YXRlRWRnZXNPblNlbGVjdDogZWxldmF0ZUVkZ2VzT25TZWxlY3QsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIG5vZGVFeHRlbnQ6IG5vZGVFeHRlbnQsIG9uTm9kZXNDaGFuZ2U6IG9uTm9kZXNDaGFuZ2UsIG9uRWRnZXNDaGFuZ2U6IG9uRWRnZXNDaGFuZ2UsIHNuYXBUb0dyaWQ6IHNuYXBUb0dyaWQsIHNuYXBHcmlkOiBzbmFwR3JpZCwgY29ubmVjdGlvbk1vZGU6IGNvbm5lY3Rpb25Nb2RlLCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgY29ubmVjdE9uQ2xpY2s6IGNvbm5lY3RPbkNsaWNrLCBkZWZhdWx0RWRnZU9wdGlvbnM6IGRlZmF1bHRFZGdlT3B0aW9ucywgZml0VmlldzogZml0VmlldywgZml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBvbk5vZGVzRGVsZXRlOiBvbk5vZGVzRGVsZXRlLCBvbkVkZ2VzRGVsZXRlOiBvbkVkZ2VzRGVsZXRlLCBvbkRlbGV0ZTogb25EZWxldGUsIG9uTm9kZURyYWdTdGFydDogb25Ob2RlRHJhZ1N0YXJ0LCBvbk5vZGVEcmFnOiBvbk5vZGVEcmFnLCBvbk5vZGVEcmFnU3RvcDogb25Ob2RlRHJhZ1N0b3AsIG9uU2VsZWN0aW9uRHJhZzogb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdGFydDogb25TZWxlY3Rpb25EcmFnU3RhcnQsIG9uU2VsZWN0aW9uRHJhZ1N0b3A6IG9uU2VsZWN0aW9uRHJhZ1N0b3AsIG9uTW92ZTogb25Nb3ZlLCBvbk1vdmVTdGFydDogb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZDogb25Nb3ZlRW5kLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG5vZGVPcmlnaW46IG5vZGVPcmlnaW4sIHJmSWQ6IHJmSWQsIGF1dG9QYW5PbkNvbm5lY3Q6IGF1dG9QYW5PbkNvbm5lY3QsIGF1dG9QYW5Pbk5vZGVEcmFnOiBhdXRvUGFuT25Ob2RlRHJhZywgYXV0b1BhblNwZWVkOiBhdXRvUGFuU3BlZWQsIG9uRXJyb3I6IG9uRXJyb3IsIGNvbm5lY3Rpb25SYWRpdXM6IGNvbm5lY3Rpb25SYWRpdXMsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiwgc2VsZWN0Tm9kZXNPbkRyYWc6IHNlbGVjdE5vZGVzT25EcmFnLCBub2RlRHJhZ1RocmVzaG9sZDogbm9kZURyYWdUaHJlc2hvbGQsIGNvbm5lY3Rpb25EcmFnVGhyZXNob2xkOiBjb25uZWN0aW9uRHJhZ1RocmVzaG9sZCwgb25CZWZvcmVEZWxldGU6IG9uQmVmb3JlRGVsZXRlLCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIGRlYnVnOiBkZWJ1ZywgYXJpYUxhYmVsQ29uZmlnOiBhcmlhTGFiZWxDb25maWcgfSksIGpzeChTZWxlY3Rpb25MaXN0ZW5lciwgeyBvblNlbGVjdGlvbkNoYW5nZTogb25TZWxlY3Rpb25DaGFuZ2UgfSksIGNoaWxkcmVuLCBqc3goQXR0cmlidXRpb24sIHsgcHJvT3B0aW9uczogcHJvT3B0aW9ucywgcG9zaXRpb246IGF0dHJpYnV0aW9uUG9zaXRpb24gfSksIGpzeChBMTF5RGVzY3JpcHRpb25zLCB7IHJmSWQ6IHJmSWQsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXkgfSldIH0pIH0pKTtcbn1cbi8qKlxuICogVGhlIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQgaXMgdGhlIGhlYXJ0IG9mIHlvdXIgUmVhY3QgRmxvdyBhcHBsaWNhdGlvbi5cbiAqIEl0IHJlbmRlcnMgeW91ciBub2RlcyBhbmQgZWRnZXMgYW5kIGhhbmRsZXMgdXNlciBpbnRlcmFjdGlvblxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoPFJlYWN0Rmxvd1xuICogICAgbm9kZXM9ey4uLn1cbiAqICAgIGVkZ2VzPXsuLi59XG4gKiAgICBvbk5vZGVzQ2hhbmdlPXsuLi59XG4gKiAgICAuLi5cbiAqICAvPik7XG4gKn1cbiAqYGBgXG4gKi9cbnZhciBpbmRleCA9IGZpeGVkRm9yd2FyZFJlZihSZWFjdEZsb3cpO1xuXG5jb25zdCBzZWxlY3RvciQ2ID0gKHMpID0+IHMuZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX2VkZ2VsYWJlbC1yZW5kZXJlcicpO1xuLyoqXG4gKiBFZGdlcyBhcmUgU1ZHLWJhc2VkLiBJZiB5b3Ugd2FudCB0byByZW5kZXIgbW9yZSBjb21wbGV4IGxhYmVscyB5b3UgY2FuIHVzZSB0aGVcbiAqIGA8RWRnZUxhYmVsUmVuZGVyZXIgLz5gIGNvbXBvbmVudCB0byBhY2Nlc3MgYSBkaXYgYmFzZWQgcmVuZGVyZXIuIFRoaXMgY29tcG9uZW50XG4gKiBpcyBhIHBvcnRhbCB0aGF0IHJlbmRlcnMgdGhlIGxhYmVsIGluIGEgYDxkaXYgLz5gIHRoYXQgaXMgcG9zaXRpb25lZCBvbiB0b3Agb2ZcbiAqIHRoZSBlZGdlcy4gWW91IGNhbiBzZWUgYW4gZXhhbXBsZSB1c2FnZSBvZiB0aGUgY29tcG9uZW50IGluIHRoZVxuICogW2VkZ2UgbGFiZWwgcmVuZGVyZXIgZXhhbXBsZV0oL2V4YW1wbGVzL2VkZ2VzL2VkZ2UtbGFiZWwtcmVuZGVyZXIpLlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4gKiBpbXBvcnQgeyBnZXRCZXppZXJQYXRoLCBFZGdlTGFiZWxSZW5kZXJlciwgQmFzZUVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IGlkLCBkYXRhLCAuLi5wcm9wcyB9KSB7XG4gKiAgIGNvbnN0IFtlZGdlUGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0QmV6aWVyUGF0aChwcm9wcyk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDw+XG4gKiAgICAgICA8QmFzZUVkZ2UgaWQ9e2lkfSBwYXRoPXtlZGdlUGF0aH0gLz5cbiAqICAgICAgIDxFZGdlTGFiZWxSZW5kZXJlcj5cbiAqICAgICAgICAgPGRpdlxuICogICAgICAgICAgIHN0eWxlPXt7XG4gKiAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAqICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgtNTAlLCAtNTAlKSB0cmFuc2xhdGUoJHtsYWJlbFh9cHgsJHtsYWJlbFl9cHgpYCxcbiAqICAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjZmZjYzAwJyxcbiAqICAgICAgICAgICAgIHBhZGRpbmc6IDEwLFxuICogICAgICAgICB9fVxuICogICAgICAgICAgIGNsYXNzTmFtZT1cIm5vZHJhZyBub3BhblwiXG4gKiAgICAgICAgID5cbiAqICAgICAgICAgIHtkYXRhLmxhYmVsfVxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgIDwvRWRnZUxhYmVsUmVuZGVyZXI+XG4gKiAgICAgPC8+XG4gKiAgICk7XG4gKiB9O1xuICogYGBgXG4gKlxuICogQHJlbWFya3MgVGhlIGA8RWRnZUxhYmVsUmVuZGVyZXIgLz5gIGhhcyBubyBwb2ludGVyIGV2ZW50cyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0b1xuICogYWRkIG1vdXNlIGludGVyYWN0aW9ucyB5b3UgbmVlZCB0byBzZXQgdGhlIHN0eWxlIGBwb2ludGVyRXZlbnRzOiBhbGxgIGFuZCBhZGRcbiAqIHRoZSBgbm9wYW5gIGNsYXNzIG9uIHRoZSBsYWJlbCBvciB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byBpbnRlcmFjdCB3aXRoLlxuICovXG5mdW5jdGlvbiBFZGdlTGFiZWxSZW5kZXJlcih7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCBlZGdlTGFiZWxSZW5kZXJlciA9IHVzZVN0b3JlKHNlbGVjdG9yJDYpO1xuICAgIGlmICghZWRnZUxhYmVsUmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGVkZ2VMYWJlbFJlbmRlcmVyKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkNSA9IChzKSA9PiBzLmRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X192aWV3cG9ydC1wb3J0YWwnKTtcbi8qKlxuICogVGhlIGA8Vmlld3BvcnRQb3J0YWwgLz5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBhZGQgY29tcG9uZW50cyB0byB0aGUgc2FtZSB2aWV3cG9ydFxuICogb2YgdGhlIGZsb3cgd2hlcmUgbm9kZXMgYW5kIGVkZ2VzIGFyZSByZW5kZXJlZC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byByZW5kZXJcbiAqIHlvdXIgb3duIGNvbXBvbmVudHMgdGhhdCBhcmUgYWRoZXJlIHRvIHRoZSBzYW1lIGNvb3JkaW5hdGUgc3lzdGVtIGFzIHRoZSBub2RlcyAmIGVkZ2VzXG4gKiBhbmQgYXJlIGFsc28gYWZmZWN0ZWQgYnkgem9vbWluZyBhbmQgcGFubmluZ1xuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc3hcbiAqaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgVmlld3BvcnRQb3J0YWwgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFZpZXdwb3J0UG9ydGFsPlxuICogICAgICA8ZGl2XG4gKiAgICAgICAgc3R5bGU9e3sgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDEwMHB4LCAxMDBweCknLCBwb3NpdGlvbjogJ2Fic29sdXRlJyB9fVxuICogICAgICA+XG4gKiAgICAgICAgVGhpcyBkaXYgaXMgcG9zaXRpb25lZCBhdCBbMTAwLCAxMDBdIG9uIHRoZSBmbG93LlxuICogICAgICA8L2Rpdj5cbiAqICAgIDwvVmlld3BvcnRQb3J0YWw+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gVmlld3BvcnRQb3J0YWwoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3Qgdmlld1BvcnRhbERpdiA9IHVzZVN0b3JlKHNlbGVjdG9yJDUpO1xuICAgIGlmICghdmlld1BvcnRhbERpdikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgdmlld1BvcnRhbERpdik7XG59XG5cbi8qKlxuICogV2hlbiB5b3UgcHJvZ3JhbW1hdGljYWxseSBhZGQgb3IgcmVtb3ZlIGhhbmRsZXMgdG8gYSBub2RlIG9yIHVwZGF0ZSBhIG5vZGUnc1xuICogaGFuZGxlIHBvc2l0aW9uLCB5b3UgbmVlZCB0byBsZXQgUmVhY3QgRmxvdyBrbm93IGFib3V0IGl0IHVzaW5nIHRoaXMgaG9vay4gVGhpc1xuICogd2lsbCB1cGRhdGUgdGhlIGludGVybmFsIGRpbWVuc2lvbnMgb2YgdGhlIG5vZGUgYW5kIHByb3Blcmx5IHJlcG9zaXRpb24gaGFuZGxlc1xuICogb24gdGhlIGNhbnZhcyBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgVXNlIHRoaXMgZnVuY3Rpb24gdG8gdGVsbCBSZWFjdCBGbG93IHRvIHVwZGF0ZSB0aGUgaW50ZXJuYWwgc3RhdGUgb2Ygb25lIG9yIG1vcmUgbm9kZXNcbiAqIHRoYXQgeW91IGhhdmUgY2hhbmdlZCBwcm9ncmFtbWF0aWNhbGx5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBIYW5kbGUsIHVzZVVwZGF0ZU5vZGVJbnRlcm5hbHMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJhbmRvbUhhbmRsZU5vZGUoeyBpZCB9KSB7XG4gKiAgY29uc3QgdXBkYXRlTm9kZUludGVybmFscyA9IHVzZVVwZGF0ZU5vZGVJbnRlcm5hbHMoKTtcbiAqICBjb25zdCBbaGFuZGxlQ291bnQsIHNldEhhbmRsZUNvdW50XSA9IHVzZVN0YXRlKDApO1xuICogIGNvbnN0IHJhbmRvbWl6ZUhhbmRsZUNvdW50ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICogICBzZXRIYW5kbGVDb3VudChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCkpO1xuICogICAgdXBkYXRlTm9kZUludGVybmFscyhpZCk7XG4gKiAgfSwgW2lkLCB1cGRhdGVOb2RlSW50ZXJuYWxzXSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8PlxuICogICAgICB7QXJyYXkuZnJvbSh7IGxlbmd0aDogaGFuZGxlQ291bnQgfSkubWFwKChfLCBpbmRleCkgPT4gKFxuICogICAgICAgIDxIYW5kbGVcbiAqICAgICAgICAgIGtleT17aW5kZXh9XG4gKiAgICAgICAgICB0eXBlPVwidGFyZ2V0XCJcbiAqICAgICAgICAgIHBvc2l0aW9uPVwibGVmdFwiXG4gKiAgICAgICAgICBpZD17YGhhbmRsZS0ke2luZGV4fWB9XG4gKiAgICAgICAgLz5cbiAqICAgICAgKSl9XG4gKlxuICogICAgICA8ZGl2PlxuICogICAgICAgIDxidXR0b24gb25DbGljaz17cmFuZG9taXplSGFuZGxlQ291bnR9PlJhbmRvbWl6ZSBoYW5kbGUgY291bnQ8L2J1dHRvbj5cbiAqICAgICAgICA8cD5UaGVyZSBhcmUge2hhbmRsZUNvdW50fSBoYW5kbGVzIG9uIHRoaXMgbm9kZS48L3A+XG4gKiAgICAgIDwvZGl2PlxuICogICAgPC8+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqIEByZW1hcmtzIFRoaXMgaG9vayBjYW4gb25seSBiZSB1c2VkIGluIGEgY29tcG9uZW50IHRoYXQgaXMgYSBjaGlsZCBvZiBhXG4gKntAbGluayBSZWFjdEZsb3dQcm92aWRlcn0gb3IgYSB7QGxpbmsgUmVhY3RGbG93fSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIHVzZVVwZGF0ZU5vZGVJbnRlcm5hbHMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoaWQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkb21Ob2RlLCB1cGRhdGVOb2RlSW50ZXJuYWxzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCB1cGRhdGVJZHMgPSBBcnJheS5pc0FycmF5KGlkKSA/IGlkIDogW2lkXTtcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdXBkYXRlSWRzLmZvckVhY2goKHVwZGF0ZUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlRWxlbWVudCA9IGRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoYC5yZWFjdC1mbG93X19ub2RlW2RhdGEtaWQ9XCIke3VwZGF0ZUlkfVwiXWApO1xuICAgICAgICAgICAgaWYgKG5vZGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlcy5zZXQodXBkYXRlSWQsIHsgaWQ6IHVwZGF0ZUlkLCBub2RlRWxlbWVudCwgZm9yY2U6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzLCB7IHRyaWdnZXJGaXRWaWV3OiBmYWxzZSB9KSk7XG4gICAgfSwgW10pO1xufVxuXG5jb25zdCBub2Rlc1NlbGVjdG9yID0gKHN0YXRlKSA9PiBzdGF0ZS5ub2Rlcztcbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGN1cnJlbnQgbm9kZXMuIENvbXBvbmVudHMgdGhhdCB1c2UgdGhpcyBob29rXG4gKiB3aWxsIHJlLXJlbmRlciAqKndoZW5ldmVyIGFueSBub2RlIGNoYW5nZXMqKiwgaW5jbHVkaW5nIHdoZW4gYSBub2RlIGlzIHNlbGVjdGVkXG4gKiBvciBtb3ZlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgbm9kZXMgY3VycmVudGx5IGluIHRoZSBmbG93LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlTm9kZXMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICogIGNvbnN0IG5vZGVzID0gdXNlTm9kZXMoKTtcbiAqXG4gKiAgcmV0dXJuIDxkaXY+VGhlcmUgYXJlIGN1cnJlbnRseSB7bm9kZXMubGVuZ3RofSBub2RlcyE8L2Rpdj47XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVzKCkge1xuICAgIGNvbnN0IG5vZGVzID0gdXNlU3RvcmUobm9kZXNTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuXG5jb25zdCBlZGdlc1NlbGVjdG9yID0gKHN0YXRlKSA9PiBzdGF0ZS5lZGdlcztcbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGN1cnJlbnQgZWRnZXMuIENvbXBvbmVudHMgdGhhdCB1c2UgdGhpcyBob29rXG4gKiB3aWxsIHJlLXJlbmRlciAqKndoZW5ldmVyIGFueSBlZGdlIGNoYW5nZXMqKi5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgZWRnZXMgY3VycmVudGx5IGluIHRoZSBmbG93LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlRWRnZXMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBlZGdlcyA9IHVzZUVkZ2VzKCk7XG4gKlxuICogIHJldHVybiA8ZGl2PlRoZXJlIGFyZSBjdXJyZW50bHkge2VkZ2VzLmxlbmd0aH0gZWRnZXMhPC9kaXY+O1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VFZGdlcygpIHtcbiAgICBjb25zdCBlZGdlcyA9IHVzZVN0b3JlKGVkZ2VzU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiBlZGdlcztcbn1cblxuY29uc3Qgdmlld3BvcnRTZWxlY3RvciA9IChzdGF0ZSkgPT4gKHtcbiAgICB4OiBzdGF0ZS50cmFuc2Zvcm1bMF0sXG4gICAgeTogc3RhdGUudHJhbnNmb3JtWzFdLFxuICAgIHpvb206IHN0YXRlLnRyYW5zZm9ybVsyXSxcbn0pO1xuLyoqXG4gKiBUaGUgYHVzZVZpZXdwb3J0YCBob29rIGlzIGEgY29udmVuaWVudCB3YXkgdG8gcmVhZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGVcbiAqIHtAbGluayBWaWV3cG9ydH0gaW4gYSBjb21wb25lbnQuIENvbXBvbmVudHMgdGhhdCB1c2UgdGhpcyBob29rXG4gKiB3aWxsIHJlLXJlbmRlciAqKndoZW5ldmVyIHRoZSB2aWV3cG9ydCBjaGFuZ2VzKiouXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgVGhlIGN1cnJlbnQgdmlld3BvcnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKmBgYGpzeFxuICppbXBvcnQgeyB1c2VWaWV3cG9ydCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVmlld3BvcnREaXNwbGF5KCkge1xuICogIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gdXNlVmlld3BvcnQoKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIDxwPlxuICogICAgICAgIFRoZSB2aWV3cG9ydCBpcyBjdXJyZW50bHkgYXQgKHt4fSwge3l9KSBhbmQgem9vbWVkIHRvIHt6b29tfS5cbiAqICAgICAgPC9wPlxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgY2FuIG9ubHkgYmUgdXNlZCBpbiBhIGNvbXBvbmVudCB0aGF0IGlzIGEgY2hpbGQgb2YgYVxuICp7QGxpbmsgUmVhY3RGbG93UHJvdmlkZXJ9IG9yIGEge0BsaW5rIFJlYWN0Rmxvd30gY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiB1c2VWaWV3cG9ydCgpIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHVzZVN0b3JlKHZpZXdwb3J0U2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiB2aWV3cG9ydDtcbn1cblxuLyoqXG4gKiBUaGlzIGhvb2sgbWFrZXMgaXQgZWFzeSB0byBwcm90b3R5cGUgYSBjb250cm9sbGVkIGZsb3cgd2hlcmUgeW91IG1hbmFnZSB0aGVcbiAqIHN0YXRlIG9mIG5vZGVzIGFuZCBlZGdlcyBvdXRzaWRlIHRoZSBgUmVhY3RGbG93SW5zdGFuY2VgLiBZb3UgY2FuIHRoaW5rIG9mIGl0XG4gKiBsaWtlIFJlYWN0J3MgYHVzZVN0YXRlYCBob29rIHdpdGggYW4gYWRkaXRpb25hbCBoZWxwZXIgY2FsbGJhY2suXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnNcbiAqIC0gYG5vZGVzYDogVGhlIGN1cnJlbnQgYXJyYXkgb2Ygbm9kZXMuIFlvdSBtaWdodCBwYXNzIHRoaXMgZGlyZWN0bHkgdG8gdGhlIGBub2Rlc2AgcHJvcCBvZiB5b3VyXG4gKiBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50LCBvciB5b3UgbWF5IHdhbnQgdG8gbWFuaXB1bGF0ZSBpdCBmaXJzdCB0byBwZXJmb3JtIHNvbWUgbGF5b3V0aW5nLFxuICogZm9yIGV4YW1wbGUuXG4gKiAtIGBzZXROb2Rlc2A6IEEgZnVuY3Rpb24gdGhhdCB5b3UgY2FuIHVzZSB0byB1cGRhdGUgdGhlIG5vZGVzLiBZb3UgY2FuIHBhc3MgaXQgYSBuZXcgYXJyYXkgb2ZcbiAqIG5vZGVzIG9yIGEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgY3VycmVudCBhcnJheSBvZiBub2RlcyBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBub2Rlcy5cbiAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSB0dXBsZSByZXR1cm5lZCBieSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vay5cbiAqIC0gYG9uTm9kZXNDaGFuZ2VgOiBBIGhhbmR5IGNhbGxiYWNrIHRoYXQgY2FuIHRha2UgYW4gYXJyYXkgb2YgYE5vZGVDaGFuZ2VzYCBhbmQgdXBkYXRlIHRoZSBub2Rlc1xuICogc3RhdGUgYWNjb3JkaW5nbHkuIFlvdSdsbCB0eXBpY2FsbHkgcGFzcyB0aGlzIGRpcmVjdGx5IHRvIHRoZSBgb25Ob2Rlc0NoYW5nZWAgcHJvcCBvZiB5b3VyXG4gKiBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50LlxuICogQGV4YW1wbGVcbiAqXG4gKmBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIHVzZU5vZGVzU3RhdGUsIHVzZUVkZ2VzU3RhdGUgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IGluaXRpYWxOb2RlcyA9IFtdO1xuICpjb25zdCBpbml0aWFsRWRnZXMgPSBbXTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBbbm9kZXMsIHNldE5vZGVzLCBvbk5vZGVzQ2hhbmdlXSA9IHVzZU5vZGVzU3RhdGUoaW5pdGlhbE5vZGVzKTtcbiAqICBjb25zdCBbZWRnZXMsIHNldEVkZ2VzLCBvbkVkZ2VzQ2hhbmdlXSA9IHVzZUVkZ2VzU3RhdGUoaW5pdGlhbEVkZ2VzKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3dcbiAqICAgICAgbm9kZXM9e25vZGVzfVxuICogICAgICBlZGdlcz17ZWRnZXN9XG4gKiAgICAgIG9uTm9kZXNDaGFuZ2U9e29uTm9kZXNDaGFuZ2V9XG4gKiAgICAgIG9uRWRnZXNDaGFuZ2U9e29uRWRnZXNDaGFuZ2V9XG4gKiAgICAvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHdhcyBjcmVhdGVkIHRvIG1ha2UgcHJvdG90eXBpbmcgZWFzaWVyIGFuZCBvdXIgZG9jdW1lbnRhdGlvblxuICogZXhhbXBsZXMgY2xlYXJlci4gQWx0aG91Z2ggaXQgaXMgT0sgdG8gdXNlIHRoaXMgaG9vayBpbiBwcm9kdWN0aW9uLCBpblxuICogcHJhY3RpY2UgeW91IG1heSB3YW50IHRvIHVzZSBhIG1vcmUgc29waGlzdGljYXRlZCBzdGF0ZSBtYW5hZ2VtZW50IHNvbHV0aW9uXG4gKiBsaWtlIFp1c3RhbmQge0BsaW5rIGh0dHBzOi8vcmVhY3RmbG93LmRldi9kb2NzL2d1aWRlcy9zdGF0ZS1tYW5hZ2VtZW50L30gaW5zdGVhZC5cbiAqXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVzU3RhdGUoaW5pdGlhbE5vZGVzKSB7XG4gICAgY29uc3QgW25vZGVzLCBzZXROb2Rlc10gPSB1c2VTdGF0ZShpbml0aWFsTm9kZXMpO1xuICAgIGNvbnN0IG9uTm9kZXNDaGFuZ2UgPSB1c2VDYWxsYmFjaygoY2hhbmdlcykgPT4gc2V0Tm9kZXMoKG5kcykgPT4gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBuZHMpKSwgW10pO1xuICAgIHJldHVybiBbbm9kZXMsIHNldE5vZGVzLCBvbk5vZGVzQ2hhbmdlXTtcbn1cbi8qKlxuICogVGhpcyBob29rIG1ha2VzIGl0IGVhc3kgdG8gcHJvdG90eXBlIGEgY29udHJvbGxlZCBmbG93IHdoZXJlIHlvdSBtYW5hZ2UgdGhlXG4gKiBzdGF0ZSBvZiBub2RlcyBhbmQgZWRnZXMgb3V0c2lkZSB0aGUgYFJlYWN0Rmxvd0luc3RhbmNlYC4gWW91IGNhbiB0aGluayBvZiBpdFxuICogbGlrZSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vayB3aXRoIGFuIGFkZGl0aW9uYWwgaGVscGVyIGNhbGxiYWNrLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zXG4gKiAtIGBlZGdlc2A6IFRoZSBjdXJyZW50IGFycmF5IG9mIGVkZ2VzLiBZb3UgbWlnaHQgcGFzcyB0aGlzIGRpcmVjdGx5IHRvIHRoZSBgZWRnZXNgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCwgb3IgeW91IG1heSB3YW50IHRvIG1hbmlwdWxhdGUgaXQgZmlyc3QgdG8gcGVyZm9ybSBzb21lIGxheW91dGluZyxcbiAqIGZvciBleGFtcGxlLlxuICpcbiAqIC0gYHNldEVkZ2VzYDogQSBmdW5jdGlvbiB0aGF0IHlvdSBjYW4gdXNlIHRvIHVwZGF0ZSB0aGUgZWRnZXMuIFlvdSBjYW4gcGFzcyBpdCBhIG5ldyBhcnJheSBvZlxuICogZWRnZXMgb3IgYSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBjdXJyZW50IGFycmF5IG9mIGVkZ2VzIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVkZ2VzLlxuICogVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIHR1cGxlIHJldHVybmVkIGJ5IFJlYWN0J3MgYHVzZVN0YXRlYCBob29rLlxuICpcbiAqIC0gYG9uRWRnZXNDaGFuZ2VgOiBBIGhhbmR5IGNhbGxiYWNrIHRoYXQgY2FuIHRha2UgYW4gYXJyYXkgb2YgYEVkZ2VDaGFuZ2VzYCBhbmQgdXBkYXRlIHRoZSBlZGdlc1xuICogc3RhdGUgYWNjb3JkaW5nbHkuIFlvdSdsbCB0eXBpY2FsbHkgcGFzcyB0aGlzIGRpcmVjdGx5IHRvIHRoZSBgb25FZGdlc0NoYW5nZWAgcHJvcCBvZiB5b3VyXG4gKiBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50LlxuICogQGV4YW1wbGVcbiAqXG4gKmBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIHVzZU5vZGVzU3RhdGUsIHVzZUVkZ2VzU3RhdGUgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IGluaXRpYWxOb2RlcyA9IFtdO1xuICpjb25zdCBpbml0aWFsRWRnZXMgPSBbXTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBbbm9kZXMsIHNldE5vZGVzLCBvbk5vZGVzQ2hhbmdlXSA9IHVzZU5vZGVzU3RhdGUoaW5pdGlhbE5vZGVzKTtcbiAqICBjb25zdCBbZWRnZXMsIHNldEVkZ2VzLCBvbkVkZ2VzQ2hhbmdlXSA9IHVzZUVkZ2VzU3RhdGUoaW5pdGlhbEVkZ2VzKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3dcbiAqICAgICAgbm9kZXM9e25vZGVzfVxuICogICAgICBlZGdlcz17ZWRnZXN9XG4gKiAgICAgIG9uTm9kZXNDaGFuZ2U9e29uTm9kZXNDaGFuZ2V9XG4gKiAgICAgIG9uRWRnZXNDaGFuZ2U9e29uRWRnZXNDaGFuZ2V9XG4gKiAgICAvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHdhcyBjcmVhdGVkIHRvIG1ha2UgcHJvdG90eXBpbmcgZWFzaWVyIGFuZCBvdXIgZG9jdW1lbnRhdGlvblxuICogZXhhbXBsZXMgY2xlYXJlci4gQWx0aG91Z2ggaXQgaXMgT0sgdG8gdXNlIHRoaXMgaG9vayBpbiBwcm9kdWN0aW9uLCBpblxuICogcHJhY3RpY2UgeW91IG1heSB3YW50IHRvIHVzZSBhIG1vcmUgc29waGlzdGljYXRlZCBzdGF0ZSBtYW5hZ2VtZW50IHNvbHV0aW9uXG4gKiBsaWtlIFp1c3RhbmQge0BsaW5rIGh0dHBzOi8vcmVhY3RmbG93LmRldi9kb2NzL2d1aWRlcy9zdGF0ZS1tYW5hZ2VtZW50L30gaW5zdGVhZC5cbiAqXG4gKi9cbmZ1bmN0aW9uIHVzZUVkZ2VzU3RhdGUoaW5pdGlhbEVkZ2VzKSB7XG4gICAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlc10gPSB1c2VTdGF0ZShpbml0aWFsRWRnZXMpO1xuICAgIGNvbnN0IG9uRWRnZXNDaGFuZ2UgPSB1c2VDYWxsYmFjaygoY2hhbmdlcykgPT4gc2V0RWRnZXMoKGVkcykgPT4gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBlZHMpKSwgW10pO1xuICAgIHJldHVybiBbZWRnZXMsIHNldEVkZ2VzLCBvbkVkZ2VzQ2hhbmdlXTtcbn1cblxuLyoqXG4gKiBUaGUgYHVzZU9uVmlld3BvcnRDaGFuZ2VgIGhvb2sgbGV0cyB5b3UgbGlzdGVuIGZvciBjaGFuZ2VzIHRvIHRoZSB2aWV3cG9ydCBzdWNoXG4gKiBhcyBwYW5uaW5nIGFuZCB6b29taW5nLiBZb3UgY2FuIHByb3ZpZGUgYSBjYWxsYmFjayBmb3IgZWFjaCBwaGFzZSBvZiBhIHZpZXdwb3J0XG4gKiBjaGFuZ2U6IGBvblN0YXJ0YCwgYG9uQ2hhbmdlYCwgYW5kIGBvbkVuZGAuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgdXNlT25WaWV3cG9ydENoYW5nZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gVmlld3BvcnRDaGFuZ2VMb2dnZXIoKSB7XG4gKiAgdXNlT25WaWV3cG9ydENoYW5nZSh7XG4gKiAgICBvblN0YXJ0OiAodmlld3BvcnQ6IFZpZXdwb3J0KSA9PiBjb25zb2xlLmxvZygnc3RhcnQnLCB2aWV3cG9ydCksXG4gKiAgICBvbkNoYW5nZTogKHZpZXdwb3J0OiBWaWV3cG9ydCkgPT4gY29uc29sZS5sb2coJ2NoYW5nZScsIHZpZXdwb3J0KSxcbiAqICAgIG9uRW5kOiAodmlld3BvcnQ6IFZpZXdwb3J0KSA9PiBjb25zb2xlLmxvZygnZW5kJywgdmlld3BvcnQpLFxuICogIH0pO1xuICpcbiAqICByZXR1cm4gbnVsbDtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlT25WaWV3cG9ydENoYW5nZSh7IG9uU3RhcnQsIG9uQ2hhbmdlLCBvbkVuZCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZVN0YXJ0OiBvblN0YXJ0IH0pO1xuICAgIH0sIFtvblN0YXJ0XSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlOiBvbkNoYW5nZSB9KTtcbiAgICB9LCBbb25DaGFuZ2VdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2VFbmQ6IG9uRW5kIH0pO1xuICAgIH0sIFtvbkVuZF0pO1xufVxuXG4vKipcbiAqIFRoaXMgaG9vayBsZXRzIHlvdSBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gYm90aCBub2RlIGFuZCBlZGdlIHNlbGVjdGlvbi4gQXMgdGhlXG4gKm5hbWUgaW1wbGllcywgdGhlIGNhbGxiYWNrIHlvdSBwcm92aWRlIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gb2ZcbiAqX2VpdGhlcl8gbm9kZXMgb3IgZWRnZXMgY2hhbmdlcy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBSZWFjdEZsb3csIHVzZU9uU2VsZWN0aW9uQ2hhbmdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBTZWxlY3Rpb25EaXNwbGF5KCkge1xuICogIGNvbnN0IFtzZWxlY3RlZE5vZGVzLCBzZXRTZWxlY3RlZE5vZGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAqICBjb25zdCBbc2VsZWN0ZWRFZGdlcywgc2V0U2VsZWN0ZWRFZGdlc10gPSB1c2VTdGF0ZShbXSk7XG4gKlxuICogIC8vIHRoZSBwYXNzZWQgaGFuZGxlciBoYXMgdG8gYmUgbWVtb2l6ZWQsIG90aGVyd2lzZSB0aGUgaG9vayB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseVxuICogIGNvbnN0IG9uQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHsgbm9kZXMsIGVkZ2VzIH0pID0+IHtcbiAqICAgIHNldFNlbGVjdGVkTm9kZXMobm9kZXMubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gKiAgICBzZXRTZWxlY3RlZEVkZ2VzKGVkZ2VzLm1hcCgoZWRnZSkgPT4gZWRnZS5pZCkpO1xuICogIH0sIFtdKTtcbiAqXG4gKiAgdXNlT25TZWxlY3Rpb25DaGFuZ2Uoe1xuICogICAgb25DaGFuZ2UsXG4gKiAgfSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8cD5TZWxlY3RlZCBub2Rlczoge3NlbGVjdGVkTm9kZXMuam9pbignLCAnKX08L3A+XG4gKiAgICAgIDxwPlNlbGVjdGVkIGVkZ2VzOiB7c2VsZWN0ZWRFZGdlcy5qb2luKCcsICcpfTwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgWW91IG5lZWQgdG8gbWVtb2l6ZSB0aGUgcGFzc2VkIGBvbkNoYW5nZWAgaGFuZGxlciwgb3RoZXJ3aXNlIHRoZSBob29rIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5LlxuICovXG5mdW5jdGlvbiB1c2VPblNlbGVjdGlvbkNoYW5nZSh7IG9uQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRPblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzID0gWy4uLnN0b3JlLmdldFN0YXRlKCkub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycywgb25DaGFuZ2VdO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM6IG5leHRPblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dEhhbmRsZXJzID0gc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzLmZpbHRlcigoZm4pID0+IGZuICE9PSBvbkNoYW5nZSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM6IG5leHRIYW5kbGVycyB9KTtcbiAgICAgICAgfTtcbiAgICB9LCBbb25DaGFuZ2VdKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkNCA9IChvcHRpb25zKSA9PiAocykgPT4ge1xuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlSGlkZGVuTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIHMubm9kZXNJbml0aWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHMubm9kZUxvb2t1cC5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbLCB7IGludGVybmFscyB9XSBvZiBzLm5vZGVMb29rdXApIHtcbiAgICAgICAgaWYgKGludGVybmFscy5oYW5kbGVCb3VuZHMgPT09IHVuZGVmaW5lZCB8fCAhbm9kZUhhc0RpbWVuc2lvbnMoaW50ZXJuYWxzLnVzZXJOb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogVGhpcyBob29rIHRlbGxzIHlvdSB3aGV0aGVyIGFsbCB0aGUgbm9kZXMgaW4gYSBmbG93IGhhdmUgYmVlbiBtZWFzdXJlZCBhbmQgZ2l2ZW5cbiAqYSB3aWR0aCBhbmQgaGVpZ2h0LiBXaGVuIHlvdSBhZGQgYSBub2RlIHRvIHRoZSBmbG93LCB0aGlzIGhvb2sgd2lsbCByZXR1cm5cbiAqYGZhbHNlYCBhbmQgdGhlbiBgdHJ1ZWAgYWdhaW4gb25jZSB0aGUgbm9kZSBoYXMgYmVlbiBtZWFzdXJlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCB0aGUgbm9kZXMgaGF2ZSBiZWVuIGluaXRpYWxpemVkIGJ5IHRoZSBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50IGFuZFxuICogZ2l2ZW4gYSB3aWR0aCBhbmQgaGVpZ2h0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlUmVhY3RGbG93LCB1c2VOb2Rlc0luaXRpYWxpemVkIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG4gKlxuICpjb25zdCBvcHRpb25zID0ge1xuICogIGluY2x1ZGVIaWRkZW5Ob2RlczogZmFsc2UsXG4gKn07XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VMYXlvdXQoKSB7XG4gKiAgY29uc3QgeyBnZXROb2RlcyB9ID0gdXNlUmVhY3RGbG93KCk7XG4gKiAgY29uc3Qgbm9kZXNJbml0aWFsaXplZCA9IHVzZU5vZGVzSW5pdGlhbGl6ZWQob3B0aW9ucyk7XG4gKiAgY29uc3QgW2xheW91dGVkTm9kZXMsIHNldExheW91dGVkTm9kZXNdID0gdXNlU3RhdGUoZ2V0Tm9kZXMoKSk7XG4gKlxuICogIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgICBpZiAobm9kZXNJbml0aWFsaXplZCkge1xuICogICAgICBzZXRMYXlvdXRlZE5vZGVzKHlvdXJMYXlvdXRpbmdGdW5jdGlvbihnZXROb2RlcygpKSk7XG4gKiAgICB9XG4gKiAgfSwgW25vZGVzSW5pdGlhbGl6ZWRdKTtcbiAqXG4gKiAgcmV0dXJuIGxheW91dGVkTm9kZXM7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVzSW5pdGlhbGl6ZWQob3B0aW9ucyA9IHtcbiAgICBpbmNsdWRlSGlkZGVuTm9kZXM6IGZhbHNlLFxufSkge1xuICAgIGNvbnN0IGluaXRpYWxpemVkID0gdXNlU3RvcmUoc2VsZWN0b3IkNChvcHRpb25zKSk7XG4gICAgcmV0dXJuIGluaXRpYWxpemVkO1xufVxuXG4vKipcbiAqIEhvb2sgdG8gY2hlY2sgaWYgYSA8SGFuZGxlIC8+IGlzIGNvbm5lY3RlZCB0byBhbm90aGVyIDxIYW5kbGUgLz4gYW5kIGdldCB0aGUgY29ubmVjdGlvbnMuXG4gKlxuICogQHB1YmxpY1xuICogQGRlcHJlY2F0ZWQgVXNlIGB1c2VOb2RlQ29ubmVjdGlvbnNgIGluc3RlYWQuXG4gKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIGhhbmRsZSBjb25uZWN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdXNlSGFuZGxlQ29ubmVjdGlvbnMoeyB0eXBlLCBpZCwgbm9kZUlkLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdCwgfSkge1xuICAgIGNvbnNvbGUud2FybignW0RFUFJFQ0FURURdIGB1c2VIYW5kbGVDb25uZWN0aW9uc2AgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCB1c2UgYHVzZU5vZGVDb25uZWN0aW9uc2AgaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2FwaS1yZWZlcmVuY2UvaG9va3MvdXNlTm9kZUNvbm5lY3Rpb25zJyk7XG4gICAgY29uc3QgX25vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IGN1cnJlbnROb2RlSWQgPSBub2RlSWQgPz8gX25vZGVJZDtcbiAgICBjb25zdCBwcmV2Q29ubmVjdGlvbnMgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSB1c2VTdG9yZSgoc3RhdGUpID0+IHN0YXRlLmNvbm5lY3Rpb25Mb29rdXAuZ2V0KGAke2N1cnJlbnROb2RlSWR9LSR7dHlwZX0ke2lkID8gYC0ke2lkfWAgOiAnJ31gKSwgYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gQHRvZG8gZGljdXNzIGlmIG9uQ29ubmVjdC9vbkRpc2Nvbm5lY3Qgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgbW91bnRzL3VubW91bnRzXG4gICAgICAgIGlmIChwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAmJiBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAhPT0gY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9jb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIF9jb25uZWN0aW9ucywgb25EaXNjb25uZWN0KTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UoX2Nvbm5lY3Rpb25zLCBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCwgb25Db25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICB9LCBbY29ubmVjdGlvbnMsIG9uQ29ubmVjdCwgb25EaXNjb25uZWN0XSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gQXJyYXkuZnJvbShjb25uZWN0aW9ucz8udmFsdWVzKCkgPz8gW10pLCBbY29ubmVjdGlvbnNdKTtcbn1cblxuY29uc3QgZXJyb3IwMTQgPSBlcnJvck1lc3NhZ2VzWydlcnJvcjAxNCddKCk7XG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGFuIGFycmF5IG9mIGNvbm5lY3Rpb25zIG9uIGEgc3BlY2lmaWMgbm9kZSwgaGFuZGxlIHR5cGUgKCdzb3VyY2UnLCAndGFyZ2V0Jykgb3IgaGFuZGxlIElELlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggY29ubmVjdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VOb2RlQ29ubmVjdGlvbnMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBjb25uZWN0aW9ucyA9IHVzZU5vZGVDb25uZWN0aW9ucyh7XG4gKiAgICBoYW5kbGVUeXBlOiAndGFyZ2V0JyxcbiAqICAgIGhhbmRsZUlkOiAnbXktaGFuZGxlJyxcbiAqICB9KTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+VGhlcmUgYXJlIGN1cnJlbnRseSB7Y29ubmVjdGlvbnMubGVuZ3RofSBpbmNvbWluZyBjb25uZWN0aW9ucyE8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VOb2RlQ29ubmVjdGlvbnMoeyBpZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG9uQ29ubmVjdCwgb25EaXNjb25uZWN0LCB9ID0ge30pIHtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlkID0gaWQgPz8gbm9kZUlkO1xuICAgIGlmICghY3VycmVudE5vZGVJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IwMTQpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2Q29ubmVjdGlvbnMgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSB1c2VTdG9yZSgoc3RhdGUpID0+IHN0YXRlLmNvbm5lY3Rpb25Mb29rdXAuZ2V0KGAke2N1cnJlbnROb2RlSWR9JHtoYW5kbGVUeXBlID8gKGhhbmRsZUlkID8gYC0ke2hhbmRsZVR5cGV9LSR7aGFuZGxlSWR9YCA6IGAtJHtoYW5kbGVUeXBlfWApIDogJyd9YCksIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEB0b2RvIGRpc2N1c3MgaWYgb25Db25uZWN0L29uRGlzY29ubmVjdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBtb3VudHMvdW5tb3VudHNcbiAgICAgICAgaWYgKHByZXZDb25uZWN0aW9ucy5jdXJyZW50ICYmIHByZXZDb25uZWN0aW9ucy5jdXJyZW50ICE9PSBjb25uZWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgX2Nvbm5lY3Rpb25zID0gY29ubmVjdGlvbnMgPz8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShwcmV2Q29ubmVjdGlvbnMuY3VycmVudCwgX2Nvbm5lY3Rpb25zLCBvbkRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShfY29ubmVjdGlvbnMsIHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBvbkNvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZDb25uZWN0aW9ucy5jdXJyZW50ID0gY29ubmVjdGlvbnMgPz8gbmV3IE1hcCgpO1xuICAgIH0sIFtjb25uZWN0aW9ucywgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3RdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiBBcnJheS5mcm9tKGNvbm5lY3Rpb25zPy52YWx1ZXMoKSA/PyBbXSksIFtjb25uZWN0aW9uc10pO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdXNlTm9kZXNEYXRhKG5vZGVJZHMpIHtcbiAgICBjb25zdCBub2Rlc0RhdGEgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGNvbnN0IGlzQXJyYXlPZklkcyA9IEFycmF5LmlzQXJyYXkobm9kZUlkcyk7XG4gICAgICAgIGNvbnN0IF9ub2RlSWRzID0gaXNBcnJheU9mSWRzID8gbm9kZUlkcyA6IFtub2RlSWRzXTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlSWQgb2YgX25vZGVJZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG5vZGUuZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheU9mSWRzID8gZGF0YSA6IGRhdGFbMF0gPz8gbnVsbDtcbiAgICB9LCBbbm9kZUlkc10pLCBzaGFsbG93Tm9kZURhdGEpO1xuICAgIHJldHVybiBub2Rlc0RhdGE7XG59XG5cbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgc3BlY2lmaWMgbm9kZS5cbiAqIENvbXBvbmVudHMgdGhhdCB1c2UgdGhpcyBob29rIHdpbGwgcmUtcmVuZGVyICoqd2hlbmV2ZXIgdGhlIG5vZGUgY2hhbmdlcyoqLFxuICogaW5jbHVkaW5nIHdoZW4gYSBub2RlIGlzIHNlbGVjdGVkIG9yIG1vdmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiBhIG5vZGUgeW91IHdhbnQgdG8gb2JzZXJ2ZS5cbiAqIEByZXR1cm5zIFRoZSBgSW50ZXJuYWxOb2RlYCBvYmplY3QgZm9yIHRoZSBub2RlIHdpdGggdGhlIGdpdmVuIElELlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlSW50ZXJuYWxOb2RlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgaW50ZXJuYWxOb2RlID0gdXNlSW50ZXJuYWxOb2RlKCdub2RlLTEnKTtcbiAqICBjb25zdCBhYnNvbHV0ZVBvc2l0aW9uID0gaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICAgVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGlzIGF0OlxuICogICAgICA8cD54OiB7YWJzb2x1dGVQb3NpdGlvbi54fTwvcD5cbiAqICAgICAgPHA+eToge2Fic29sdXRlUG9zaXRpb24ueX08L3A+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VJbnRlcm5hbE5vZGUoaWQpIHtcbiAgICBjb25zdCBub2RlID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHMpID0+IHMubm9kZUxvb2t1cC5nZXQoaWQpLCBbaWRdKSwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIExpbmVQYXR0ZXJuKHsgZGltZW5zaW9ucywgbGluZVdpZHRoLCB2YXJpYW50LCBjbGFzc05hbWUgfSkge1xuICAgIHJldHVybiAoanN4KFwicGF0aFwiLCB7IHN0cm9rZVdpZHRoOiBsaW5lV2lkdGgsIGQ6IGBNJHtkaW1lbnNpb25zWzBdIC8gMn0gMCBWJHtkaW1lbnNpb25zWzFdfSBNMCAke2RpbWVuc2lvbnNbMV0gLyAyfSBIJHtkaW1lbnNpb25zWzBdfWAsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19iYWNrZ3JvdW5kLXBhdHRlcm4nLCB2YXJpYW50LCBjbGFzc05hbWVdKSB9KSk7XG59XG5mdW5jdGlvbiBEb3RQYXR0ZXJuKHsgcmFkaXVzLCBjbGFzc05hbWUgfSkge1xuICAgIHJldHVybiAoanN4KFwiY2lyY2xlXCIsIHsgY3g6IHJhZGl1cywgY3k6IHJhZGl1cywgcjogcmFkaXVzLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZC1wYXR0ZXJuJywgJ2RvdHMnLCBjbGFzc05hbWVdKSB9KSk7XG59XG5cbi8qKlxuICogVGhlIHRocmVlIHZhcmlhbnRzIGFyZSBleHBvcnRlZCBhcyBhbiBlbnVtIGZvciBjb252ZW5pZW5jZS4gWW91IGNhbiBlaXRoZXIgaW1wb3J0XG4gKiB0aGUgZW51bSBhbmQgdXNlIGl0IGxpa2UgYEJhY2tncm91bmRWYXJpYW50LkxpbmVzYCBvciB5b3UgY2FuIHVzZSB0aGUgcmF3IHN0cmluZ1xuICogdmFsdWUgZGlyZWN0bHkuXG4gKiBAcHVibGljXG4gKi9cbnZhciBCYWNrZ3JvdW5kVmFyaWFudDtcbihmdW5jdGlvbiAoQmFja2dyb3VuZFZhcmlhbnQpIHtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkxpbmVzXCJdID0gXCJsaW5lc1wiO1xuICAgIEJhY2tncm91bmRWYXJpYW50W1wiRG90c1wiXSA9IFwiZG90c1wiO1xuICAgIEJhY2tncm91bmRWYXJpYW50W1wiQ3Jvc3NcIl0gPSBcImNyb3NzXCI7XG59KShCYWNrZ3JvdW5kVmFyaWFudCB8fCAoQmFja2dyb3VuZFZhcmlhbnQgPSB7fSkpO1xuXG5jb25zdCBkZWZhdWx0U2l6ZSA9IHtcbiAgICBbQmFja2dyb3VuZFZhcmlhbnQuRG90c106IDEsXG4gICAgW0JhY2tncm91bmRWYXJpYW50LkxpbmVzXTogMSxcbiAgICBbQmFja2dyb3VuZFZhcmlhbnQuQ3Jvc3NdOiA2LFxufTtcbmNvbnN0IHNlbGVjdG9yJDMgPSAocykgPT4gKHsgdHJhbnNmb3JtOiBzLnRyYW5zZm9ybSwgcGF0dGVybklkOiBgcGF0dGVybi0ke3MucmZJZH1gIH0pO1xuZnVuY3Rpb24gQmFja2dyb3VuZENvbXBvbmVudCh7IGlkLCB2YXJpYW50ID0gQmFja2dyb3VuZFZhcmlhbnQuRG90cywgXG4vLyBvbmx5IHVzZWQgZm9yIGRvdHMgYW5kIGNyb3NzXG5nYXAgPSAyMCwgXG4vLyBvbmx5IHVzZWQgZm9yIGxpbmVzIGFuZCBjcm9zc1xuc2l6ZSwgbGluZVdpZHRoID0gMSwgb2Zmc2V0ID0gMCwgY29sb3IsIGJnQ29sb3IsIHN0eWxlLCBjbGFzc05hbWUsIHBhdHRlcm5DbGFzc05hbWUsIH0pIHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgeyB0cmFuc2Zvcm0sIHBhdHRlcm5JZCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkMywgc2hhbGxvdyk7XG4gICAgY29uc3QgcGF0dGVyblNpemUgPSBzaXplIHx8IGRlZmF1bHRTaXplW3ZhcmlhbnRdO1xuICAgIGNvbnN0IGlzRG90cyA9IHZhcmlhbnQgPT09IEJhY2tncm91bmRWYXJpYW50LkRvdHM7XG4gICAgY29uc3QgaXNDcm9zcyA9IHZhcmlhbnQgPT09IEJhY2tncm91bmRWYXJpYW50LkNyb3NzO1xuICAgIGNvbnN0IGdhcFhZID0gQXJyYXkuaXNBcnJheShnYXApID8gZ2FwIDogW2dhcCwgZ2FwXTtcbiAgICBjb25zdCBzY2FsZWRHYXAgPSBbZ2FwWFlbMF0gKiB0cmFuc2Zvcm1bMl0gfHwgMSwgZ2FwWFlbMV0gKiB0cmFuc2Zvcm1bMl0gfHwgMV07XG4gICAgY29uc3Qgc2NhbGVkU2l6ZSA9IHBhdHRlcm5TaXplICogdHJhbnNmb3JtWzJdO1xuICAgIGNvbnN0IG9mZnNldFhZID0gQXJyYXkuaXNBcnJheShvZmZzZXQpID8gb2Zmc2V0IDogW29mZnNldCwgb2Zmc2V0XTtcbiAgICBjb25zdCBwYXR0ZXJuRGltZW5zaW9ucyA9IGlzQ3Jvc3MgPyBbc2NhbGVkU2l6ZSwgc2NhbGVkU2l6ZV0gOiBzY2FsZWRHYXA7XG4gICAgY29uc3Qgc2NhbGVkT2Zmc2V0ID0gW1xuICAgICAgICBvZmZzZXRYWVswXSAqIHRyYW5zZm9ybVsyXSB8fCAxICsgcGF0dGVybkRpbWVuc2lvbnNbMF0gLyAyLFxuICAgICAgICBvZmZzZXRYWVsxXSAqIHRyYW5zZm9ybVsyXSB8fCAxICsgcGF0dGVybkRpbWVuc2lvbnNbMV0gLyAyLFxuICAgIF07XG4gICAgY29uc3QgX3BhdHRlcm5JZCA9IGAke3BhdHRlcm5JZH0ke2lkID8gaWQgOiAnJ31gO1xuICAgIHJldHVybiAoanN4cyhcInN2Z1wiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19iYWNrZ3JvdW5kJywgY2xhc3NOYW1lXSksIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIC4uLmNvbnRhaW5lclN0eWxlLFxuICAgICAgICAgICAgJy0teHktYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IGJnQ29sb3IsXG4gICAgICAgICAgICAnLS14eS1iYWNrZ3JvdW5kLXBhdHRlcm4tY29sb3ItcHJvcHMnOiBjb2xvcixcbiAgICAgICAgfSwgcmVmOiByZWYsIFwiZGF0YS10ZXN0aWRcIjogXCJyZl9fYmFja2dyb3VuZFwiLCBjaGlsZHJlbjogW2pzeChcInBhdHRlcm5cIiwgeyBpZDogX3BhdHRlcm5JZCwgeDogdHJhbnNmb3JtWzBdICUgc2NhbGVkR2FwWzBdLCB5OiB0cmFuc2Zvcm1bMV0gJSBzY2FsZWRHYXBbMV0sIHdpZHRoOiBzY2FsZWRHYXBbMF0sIGhlaWdodDogc2NhbGVkR2FwWzFdLCBwYXR0ZXJuVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIiwgcGF0dGVyblRyYW5zZm9ybTogYHRyYW5zbGF0ZSgtJHtzY2FsZWRPZmZzZXRbMF19LC0ke3NjYWxlZE9mZnNldFsxXX0pYCwgY2hpbGRyZW46IGlzRG90cyA/IChqc3goRG90UGF0dGVybiwgeyByYWRpdXM6IHNjYWxlZFNpemUgLyAyLCBjbGFzc05hbWU6IHBhdHRlcm5DbGFzc05hbWUgfSkpIDogKGpzeChMaW5lUGF0dGVybiwgeyBkaW1lbnNpb25zOiBwYXR0ZXJuRGltZW5zaW9ucywgbGluZVdpZHRoOiBsaW5lV2lkdGgsIHZhcmlhbnQ6IHZhcmlhbnQsIGNsYXNzTmFtZTogcGF0dGVybkNsYXNzTmFtZSB9KSkgfSksIGpzeChcInJlY3RcIiwgeyB4OiBcIjBcIiwgeTogXCIwXCIsIHdpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjEwMCVcIiwgZmlsbDogYHVybCgjJHtfcGF0dGVybklkfSlgIH0pXSB9KSk7XG59XG5CYWNrZ3JvdW5kQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0JhY2tncm91bmQnO1xuLyoqXG4gKiBUaGUgYDxCYWNrZ3JvdW5kIC8+YCBjb21wb25lbnQgbWFrZXMgaXQgY29udmVuaWVudCB0byByZW5kZXIgZGlmZmVyZW50IHR5cGVzIG9mIGJhY2tncm91bmRzIGNvbW1vbiBpbiBub2RlLWJhc2VkIFVJcy4gSXQgY29tZXMgd2l0aCB0aHJlZSB2YXJpYW50czogbGluZXMsIGRvdHMgYW5kIGNyb3NzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogQSBzaW1wbGUgZXhhbXBsZSBvZiBob3cgdG8gdXNlIHRoZSBCYWNrZ3JvdW5kIGNvbXBvbmVudC5cbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICogaW1wb3J0IHsgUmVhY3RGbG93LCBCYWNrZ3JvdW5kLCBCYWNrZ3JvdW5kVmFyaWFudCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPFJlYWN0RmxvdyBkZWZhdWx0Tm9kZXM9e1suLi5dfSBkZWZhdWx0RWRnZXM9e1suLi5dfT5cbiAqICAgICAgIDxCYWNrZ3JvdW5kIGNvbG9yPVwiI2NjY1wiIHZhcmlhbnQ9e0JhY2tncm91bmRWYXJpYW50LkRvdHN9IC8+XG4gKiAgICAgPC9SZWFjdEZsb3c+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIEluIHRoaXMgZXhhbXBsZSB5b3UgY2FuIHNlZSBob3cgdG8gY29tYmluZSBtdWx0aXBsZSBiYWNrZ3JvdW5kc1xuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgUmVhY3RGbG93LCBCYWNrZ3JvdW5kLCBCYWNrZ3JvdW5kVmFyaWFudCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICogaW1wb3J0ICdAeHlmbG93L3JlYWN0L2Rpc3Qvc3R5bGUuY3NzJztcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxSZWFjdEZsb3cgZGVmYXVsdE5vZGVzPXtbLi4uXX0gZGVmYXVsdEVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgICA8QmFja2dyb3VuZFxuICogICAgICAgICBpZD1cIjFcIlxuICogICAgICAgICBnYXA9ezEwfVxuICogICAgICAgICBjb2xvcj1cIiNmMWYxZjFcIlxuICogICAgICAgICB2YXJpYW50PXtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc31cbiAqICAgICAgIC8+XG4gKiAgICAgICA8QmFja2dyb3VuZFxuICogICAgICAgICBpZD1cIjJcIlxuICogICAgICAgICBnYXA9ezEwMH1cbiAqICAgICAgICAgY29sb3I9XCIjY2NjXCJcbiAqICAgICAgICAgdmFyaWFudD17QmFja2dyb3VuZFZhcmlhbnQuTGluZXN9XG4gKiAgICAgICAvPlxuICogICAgIDwvUmVhY3RGbG93PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBXaGVuIGNvbWJpbmluZyBtdWx0aXBsZSA8QmFja2dyb3VuZCAvPiBjb21wb25lbnRzIGl04oCZcyBpbXBvcnRhbnQgdG8gZ2l2ZSBlYWNoIG9mIHRoZW0gYSB1bmlxdWUgaWQgcHJvcCFcbiAqXG4gKi9cbmNvbnN0IEJhY2tncm91bmQgPSBtZW1vKEJhY2tncm91bmRDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBQbHVzSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDMyXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMzIgMTguMTMzSDE4LjEzM1YzMmgtNC4yNjZWMTguMTMzSDB2LTQuMjY2aDEzLjg2N1YwaDQuMjY2djEzLjg2N0gzMnpcIiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIE1pbnVzSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDVcIiwgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBkOiBcIk0wIDBoMzJ2NC4ySDB6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBGaXRWaWV3SWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDMwXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMy42OTIgNC42M2MwLS41My40LS45MzguOTM5LS45MzhoNS4yMTVWMEg0LjcwOEMyLjEzIDAgMCAyLjA1NCAwIDQuNjN2NS4yMTZoMy42OTJWNC42MzF6TTI3LjM1NCAwaC01LjJ2My42OTJoNS4xN2MuNTMgMCAuOTg0LjQuOTg0LjkzOXY1LjIxNUgzMlY0LjYzMUE0LjYyNCA0LjYyNCAwIDAwMjcuMzU0IDB6bS45NTQgMjQuODNjMCAuNTMyLS40Ljk0LS45MzkuOTRoLTUuMjE1djMuNzY4aDUuMjE1YzIuNTc3IDAgNC42MzEtMi4xMyA0LjYzMS00LjcwN3YtNS4xMzloLTMuNjkydjUuMTM5em0tMjMuNjc3Ljk0Yy0uNTMxIDAtLjkzOS0uNC0uOTM5LS45NHYtNS4xMzhIMHY1LjEzOWMwIDIuNTc3IDIuMTMgNC43MDcgNC43MDggNC43MDdoNS4xMzhWMjUuNzdINC42MzF6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBMb2NrSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDI1IDMyXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMjEuMzMzIDEwLjY2N0gxOS44MVY3LjYxOUMxOS44MSAzLjQyOSAxNi4zOCAwIDEyLjE5IDAgOCAwIDQuNTcxIDMuNDI5IDQuNTcxIDcuNjE5djMuMDQ4SDMuMDQ4QTMuMDU2IDMuMDU2IDAgMDAwIDEzLjcxNHYxNS4yMzhBMy4wNTYgMy4wNTYgMCAwMDMuMDQ4IDMyaDE4LjI4NWEzLjA1NiAzLjA1NiAwIDAwMy4wNDgtMy4wNDhWMTMuNzE0YTMuMDU2IDMuMDU2IDAgMDAtMy4wNDgtMy4wNDd6TTEyLjE5IDI0LjUzM2EzLjA1NiAzLjA1NiAwIDAxLTMuMDQ3LTMuMDQ3IDMuMDU2IDMuMDU2IDAgMDEzLjA0Ny0zLjA0OCAzLjA1NiAzLjA1NiAwIDAxMy4wNDggMy4wNDggMy4wNTYgMy4wNTYgMCAwMS0zLjA0OCAzLjA0N3ptNC43MjQtMTMuODY2SDcuNDY3VjcuNjE5YzAtMi41OSAyLjEzMy00LjcyNCA0LjcyMy00LjcyNCAyLjU5MSAwIDQuNzI0IDIuMTMzIDQuNzI0IDQuNzI0djMuMDQ4elwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gVW5sb2NrSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDI1IDMyXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMjEuMzMzIDEwLjY2N0gxOS44MVY3LjYxOUMxOS44MSAzLjQyOSAxNi4zOCAwIDEyLjE5IDBjLTQuMTE0IDEuODI4LTEuMzcgMi4xMzMuMzA1IDIuNDM4IDEuNjc2LjMwNSA0LjQyIDIuNTkgNC40MiA1LjE4MXYzLjA0OEgzLjA0N0EzLjA1NiAzLjA1NiAwIDAwMCAxMy43MTR2MTUuMjM4QTMuMDU2IDMuMDU2IDAgMDAzLjA0OCAzMmgxOC4yODVhMy4wNTYgMy4wNTYgMCAwMDMuMDQ4LTMuMDQ4VjEzLjcxNGEzLjA1NiAzLjA1NiAwIDAwLTMuMDQ4LTMuMDQ3ek0xMi4xOSAyNC41MzNhMy4wNTYgMy4wNTYgMCAwMS0zLjA0Ny0zLjA0NyAzLjA1NiAzLjA1NiAwIDAxMy4wNDctMy4wNDggMy4wNTYgMy4wNTYgMCAwMTMuMDQ4IDMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEtMy4wNDggMy4wNDd6XCIgfSkgfSkpO1xufVxuXG4vKipcbiAqIFlvdSBjYW4gYWRkIGJ1dHRvbnMgdG8gdGhlIGNvbnRyb2wgcGFuZWwgYnkgdXNpbmcgdGhlIGA8Q29udHJvbEJ1dHRvbiAvPmAgY29tcG9uZW50XG4gKiBhbmQgcGFzcyBpdCBhcyBhIGNoaWxkIHRvIHRoZSBbYDxDb250cm9scyAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvY29udHJvbHMpIGNvbXBvbmVudC5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgTWFnaWNXYW5kIH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LWljb25zJ1xuICppbXBvcnQgeyBSZWFjdEZsb3csIENvbnRyb2xzLCBDb250cm9sQnV0dG9uIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCdcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e1suLi5dfSBlZGdlcz17Wy4uLl19PlxuICogICAgICA8Q29udHJvbHM+XG4gKiAgICAgICAgPENvbnRyb2xCdXR0b24gb25DbGljaz17KCkgPT4gYWxlcnQoJ1NvbWV0aGluZyBtYWdpY2FsIGp1c3QgaGFwcGVuZWQuIOKcqCcpfT5cbiAqICAgICAgICAgIDxNYWdpY1dhbmQgLz5cbiAqICAgICAgICA8L0NvbnRyb2xCdXR0b24+XG4gKiAgICAgIDwvQ29udHJvbHM+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApXG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIENvbnRyb2xCdXR0b24oeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5yZXN0IH0pIHtcbiAgICByZXR1cm4gKGpzeChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb250cm9scy1idXR0b24nLCBjbGFzc05hbWVdKSwgLi4ucmVzdCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkMiA9IChzKSA9PiAoe1xuICAgIGlzSW50ZXJhY3RpdmU6IHMubm9kZXNEcmFnZ2FibGUgfHwgcy5ub2Rlc0Nvbm5lY3RhYmxlIHx8IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIG1pblpvb21SZWFjaGVkOiBzLnRyYW5zZm9ybVsyXSA8PSBzLm1pblpvb20sXG4gICAgbWF4Wm9vbVJlYWNoZWQ6IHMudHJhbnNmb3JtWzJdID49IHMubWF4Wm9vbSxcbiAgICBhcmlhTGFiZWxDb25maWc6IHMuYXJpYUxhYmVsQ29uZmlnLFxufSk7XG5mdW5jdGlvbiBDb250cm9sc0NvbXBvbmVudCh7IHN0eWxlLCBzaG93Wm9vbSA9IHRydWUsIHNob3dGaXRWaWV3ID0gdHJ1ZSwgc2hvd0ludGVyYWN0aXZlID0gdHJ1ZSwgZml0Vmlld09wdGlvbnMsIG9uWm9vbUluLCBvblpvb21PdXQsIG9uRml0Vmlldywgb25JbnRlcmFjdGl2ZUNoYW5nZSwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgcG9zaXRpb24gPSAnYm90dG9tLWxlZnQnLCBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgaXNJbnRlcmFjdGl2ZSwgbWluWm9vbVJlYWNoZWQsIG1heFpvb21SZWFjaGVkLCBhcmlhTGFiZWxDb25maWcgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDIsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHsgem9vbUluLCB6b29tT3V0LCBmaXRWaWV3IH0gPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBvblpvb21JbkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHpvb21JbigpO1xuICAgICAgICBvblpvb21Jbj8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvblpvb21PdXRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB6b29tT3V0KCk7XG4gICAgICAgIG9uWm9vbU91dD8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvbkZpdFZpZXdIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBmaXRWaWV3KGZpdFZpZXdPcHRpb25zKTtcbiAgICAgICAgb25GaXRWaWV3Py4oKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uVG9nZ2xlSW50ZXJhY3Rpdml0eSA9ICgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbm9kZXNEcmFnZ2FibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICAgICAgbm9kZXNDb25uZWN0YWJsZTogIWlzSW50ZXJhY3RpdmUsXG4gICAgICAgICAgICBlbGVtZW50c1NlbGVjdGFibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICB9KTtcbiAgICAgICAgb25JbnRlcmFjdGl2ZUNoYW5nZT8uKCFpc0ludGVyYWN0aXZlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9yaWVudGF0aW9uQ2xhc3MgPSBvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICByZXR1cm4gKGpzeHMoUGFuZWwsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2NvbnRyb2xzJywgb3JpZW50YXRpb25DbGFzcywgY2xhc3NOYW1lXSksIHBvc2l0aW9uOiBwb3NpdGlvbiwgc3R5bGU6IHN0eWxlLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX2NvbnRyb2xzXCIsIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwgPz8gYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy5hcmlhTGFiZWwnXSwgY2hpbGRyZW46IFtzaG93Wm9vbSAmJiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChDb250cm9sQnV0dG9uLCB7IG9uQ2xpY2s6IG9uWm9vbUluSGFuZGxlciwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLXpvb21pblwiLCB0aXRsZTogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tSW4uYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLnpvb21Jbi5hcmlhTGFiZWwnXSwgZGlzYWJsZWQ6IG1heFpvb21SZWFjaGVkLCBjaGlsZHJlbjoganN4KFBsdXNJY29uLCB7fSkgfSksIGpzeChDb250cm9sQnV0dG9uLCB7IG9uQ2xpY2s6IG9uWm9vbU91dEhhbmRsZXIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy16b29tb3V0XCIsIHRpdGxlOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLnpvb21PdXQuYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLnpvb21PdXQuYXJpYUxhYmVsJ10sIGRpc2FibGVkOiBtaW5ab29tUmVhY2hlZCwgY2hpbGRyZW46IGpzeChNaW51c0ljb24sIHt9KSB9KV0gfSkpLCBzaG93Rml0VmlldyAmJiAoanN4KENvbnRyb2xCdXR0b24sIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLWZpdHZpZXdcIiwgb25DbGljazogb25GaXRWaWV3SGFuZGxlciwgdGl0bGU6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuZml0Vmlldy5hcmlhTGFiZWwnXSwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuZml0Vmlldy5hcmlhTGFiZWwnXSwgY2hpbGRyZW46IGpzeChGaXRWaWV3SWNvbiwge30pIH0pKSwgc2hvd0ludGVyYWN0aXZlICYmIChqc3goQ29udHJvbEJ1dHRvbiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtaW50ZXJhY3RpdmVcIiwgb25DbGljazogb25Ub2dnbGVJbnRlcmFjdGl2aXR5LCB0aXRsZTogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy5pbnRlcmFjdGl2ZS5hcmlhTGFiZWwnXSwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuaW50ZXJhY3RpdmUuYXJpYUxhYmVsJ10sIGNoaWxkcmVuOiBpc0ludGVyYWN0aXZlID8ganN4KFVubG9ja0ljb24sIHt9KSA6IGpzeChMb2NrSWNvbiwge30pIH0pKSwgY2hpbGRyZW5dIH0pKTtcbn1cbkNvbnRyb2xzQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0NvbnRyb2xzJztcbi8qKlxuICogVGhlIGA8Q29udHJvbHMgLz5gIGNvbXBvbmVudCByZW5kZXJzIGEgc21hbGwgcGFuZWwgdGhhdCBjb250YWlucyBjb252ZW5pZW50XG4gKiBidXR0b25zIHRvIHpvb20gaW4sIHpvb20gb3V0LCBmaXQgdGhlIHZpZXcsIGFuZCBsb2NrIHRoZSB2aWV3cG9ydC5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBDb250cm9scyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXX0gZWRnZXM9e1suLi5dfT5cbiAqICAgICAgPENvbnRyb2xzIC8+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApXG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVG8gZXh0ZW5kIG9yIGN1c3RvbWlzZSB0aGUgY29udHJvbHMsIHlvdSBjYW4gdXNlIHRoZSBbYDxDb250cm9sQnV0dG9uIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9jb250cm9sLWJ1dHRvbikgY29tcG9uZW50XG4gKlxuICovXG5jb25zdCBDb250cm9scyA9IG1lbW8oQ29udHJvbHNDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBNaW5pTWFwTm9kZUNvbXBvbmVudCh7IGlkLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdHlsZSwgY29sb3IsIHN0cm9rZUNvbG9yLCBzdHJva2VXaWR0aCwgY2xhc3NOYW1lLCBib3JkZXJSYWRpdXMsIHNoYXBlUmVuZGVyaW5nLCBzZWxlY3RlZCwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IHsgYmFja2dyb3VuZCwgYmFja2dyb3VuZENvbG9yIH0gPSBzdHlsZSB8fCB7fTtcbiAgICBjb25zdCBmaWxsID0gKGNvbG9yIHx8IGJhY2tncm91bmQgfHwgYmFja2dyb3VuZENvbG9yKTtcbiAgICByZXR1cm4gKGpzeChcInJlY3RcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbWluaW1hcC1ub2RlJywgeyBzZWxlY3RlZCB9LCBjbGFzc05hbWVdKSwgeDogeCwgeTogeSwgcng6IGJvcmRlclJhZGl1cywgcnk6IGJvcmRlclJhZGl1cywgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgc3R5bGU6IHtcbiAgICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgICBzdHJva2U6IHN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIH0sIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZywgb25DbGljazogb25DbGljayA/IChldmVudCkgPT4gb25DbGljayhldmVudCwgaWQpIDogdW5kZWZpbmVkIH0pKTtcbn1cbmNvbnN0IE1pbmlNYXBOb2RlID0gbWVtbyhNaW5pTWFwTm9kZUNvbXBvbmVudCk7XG5cbmNvbnN0IHNlbGVjdG9yTm9kZUlkcyA9IChzKSA9PiBzLm5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCk7XG5jb25zdCBnZXRBdHRyRnVuY3Rpb24gPSAoZnVuYykgPT4gZnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZnVuYyA6ICgpID0+IGZ1bmM7XG5mdW5jdGlvbiBNaW5pTWFwTm9kZXMoeyBub2RlU3Ryb2tlQ29sb3IsIG5vZGVDb2xvciwgbm9kZUNsYXNzTmFtZSA9ICcnLCBub2RlQm9yZGVyUmFkaXVzID0gNSwgbm9kZVN0cm9rZVdpZHRoLCBcbi8qXG4gKiBXZSBuZWVkIHRvIHJlbmFtZSB0aGUgcHJvcCB0byBiZSBgQ2FwaXRhbENhc2VgIHNvIHRoYXQgSlNYIHdpbGwgcmVuZGVyIGl0IGFzXG4gKiBhIGNvbXBvbmVudCBwcm9wZXJseS5cbiAqL1xubm9kZUNvbXBvbmVudDogTm9kZUNvbXBvbmVudCA9IE1pbmlNYXBOb2RlLCBvbkNsaWNrLCB9KSB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHVzZVN0b3JlKHNlbGVjdG9yTm9kZUlkcywgc2hhbGxvdyk7XG4gICAgY29uc3Qgbm9kZUNvbG9yRnVuYyA9IGdldEF0dHJGdW5jdGlvbihub2RlQ29sb3IpO1xuICAgIGNvbnN0IG5vZGVTdHJva2VDb2xvckZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZVN0cm9rZUNvbG9yKTtcbiAgICBjb25zdCBub2RlQ2xhc3NOYW1lRnVuYyA9IGdldEF0dHJGdW5jdGlvbihub2RlQ2xhc3NOYW1lKTtcbiAgICBjb25zdCBzaGFwZVJlbmRlcmluZyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICEhd2luZG93LmNocm9tZSA/ICdjcmlzcEVkZ2VzJyA6ICdnZW9tZXRyaWNQcmVjaXNpb24nO1xuICAgIHJldHVybiAoanN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBub2RlSWRzLm1hcCgobm9kZUlkKSA9PiAoXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBzcGxpdCBvZiByZXNwb25zaWJpbGl0aWVzIGJldHdlZW4gTWluaU1hcE5vZGVzIGFuZFxuICAgICAgICAgKiBOb2RlQ29tcG9uZW50V3JhcHBlciBtYXkgYXBwZWFyIHdlaXJkLiBIb3dldmVyLCBpdOKAmXMgZGVzaWduZWQgdG9cbiAgICAgICAgICogbWluaW1pemUgdGhlIGNvc3Qgb2YgdXBkYXRlcyB3aGVuIGluZGl2aWR1YWwgbm9kZXMgY2hhbmdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgYSBzaW1pbGFyIGNvbW1pdCBpbiBgTm9kZVJlbmRlcmVyL2luZGV4LnRzeGAuXG4gICAgICAgICAqL1xuICAgICAgICBqc3goTm9kZUNvbXBvbmVudFdyYXBwZXIsIHsgaWQ6IG5vZGVJZCwgbm9kZUNvbG9yRnVuYzogbm9kZUNvbG9yRnVuYywgbm9kZVN0cm9rZUNvbG9yRnVuYzogbm9kZVN0cm9rZUNvbG9yRnVuYywgbm9kZUNsYXNzTmFtZUZ1bmM6IG5vZGVDbGFzc05hbWVGdW5jLCBub2RlQm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBub2RlU3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgTm9kZUNvbXBvbmVudDogTm9kZUNvbXBvbmVudCwgb25DbGljazogb25DbGljaywgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nIH0sIG5vZGVJZCkpKSB9KSk7XG59XG5mdW5jdGlvbiBOb2RlQ29tcG9uZW50V3JhcHBlcklubmVyKHsgaWQsIG5vZGVDb2xvckZ1bmMsIG5vZGVTdHJva2VDb2xvckZ1bmMsIG5vZGVDbGFzc05hbWVGdW5jLCBub2RlQm9yZGVyUmFkaXVzLCBub2RlU3Ryb2tlV2lkdGgsIHNoYXBlUmVuZGVyaW5nLCBOb2RlQ29tcG9uZW50LCBvbkNsaWNrLCB9KSB7XG4gICAgY29uc3QgeyBub2RlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VTdG9yZSgocykgPT4ge1xuICAgICAgICBjb25zdCB7IGludGVybmFscyB9ID0gcy5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBpbnRlcm5hbHMudXNlck5vZGU7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9LCBzaGFsbG93KTtcbiAgICBpZiAoIW5vZGUgfHwgbm9kZS5oaWRkZW4gfHwgIW5vZGVIYXNEaW1lbnNpb25zKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChOb2RlQ29tcG9uZW50LCB7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHN0eWxlOiBub2RlLnN0eWxlLCBzZWxlY3RlZDogISFub2RlLnNlbGVjdGVkLCBjbGFzc05hbWU6IG5vZGVDbGFzc05hbWVGdW5jKG5vZGUpLCBjb2xvcjogbm9kZUNvbG9yRnVuYyhub2RlKSwgYm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBzdHJva2VDb2xvcjogbm9kZVN0cm9rZUNvbG9yRnVuYyhub2RlKSwgc3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nLCBvbkNsaWNrOiBvbkNsaWNrLCBpZDogbm9kZS5pZCB9KSk7XG59XG5jb25zdCBOb2RlQ29tcG9uZW50V3JhcHBlciA9IG1lbW8oTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lcik7XG52YXIgTWluaU1hcE5vZGVzJDEgPSBtZW1vKE1pbmlNYXBOb2Rlcyk7XG5cbmNvbnN0IGRlZmF1bHRXaWR0aCA9IDIwMDtcbmNvbnN0IGRlZmF1bHRIZWlnaHQgPSAxNTA7XG5jb25zdCBmaWx0ZXJIaWRkZW4gPSAobm9kZSkgPT4gIW5vZGUuaGlkZGVuO1xuY29uc3Qgc2VsZWN0b3IkMSA9IChzKSA9PiB7XG4gICAgY29uc3Qgdmlld0JCID0ge1xuICAgICAgICB4OiAtcy50cmFuc2Zvcm1bMF0gLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgeTogLXMudHJhbnNmb3JtWzFdIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIHdpZHRoOiBzLndpZHRoIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIGhlaWdodDogcy5oZWlnaHQgLyBzLnRyYW5zZm9ybVsyXSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHZpZXdCQixcbiAgICAgICAgYm91bmRpbmdSZWN0OiBzLm5vZGVMb29rdXAuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gZ2V0Qm91bmRzT2ZSZWN0cyhnZXRJbnRlcm5hbE5vZGVzQm91bmRzKHMubm9kZUxvb2t1cCwgeyBmaWx0ZXI6IGZpbHRlckhpZGRlbiB9KSwgdmlld0JCKVxuICAgICAgICAgICAgOiB2aWV3QkIsXG4gICAgICAgIHJmSWQ6IHMucmZJZCxcbiAgICAgICAgcGFuWm9vbTogcy5wYW5ab29tLFxuICAgICAgICB0cmFuc2xhdGVFeHRlbnQ6IHMudHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICBmbG93V2lkdGg6IHMud2lkdGgsXG4gICAgICAgIGZsb3dIZWlnaHQ6IHMuaGVpZ2h0LFxuICAgICAgICBhcmlhTGFiZWxDb25maWc6IHMuYXJpYUxhYmVsQ29uZmlnLFxuICAgIH07XG59O1xuY29uc3QgQVJJQV9MQUJFTF9LRVkgPSAncmVhY3QtZmxvd19fbWluaW1hcC1kZXNjJztcbmZ1bmN0aW9uIE1pbmlNYXBDb21wb25lbnQoeyBzdHlsZSwgY2xhc3NOYW1lLCBub2RlU3Ryb2tlQ29sb3IsIG5vZGVDb2xvciwgbm9kZUNsYXNzTmFtZSA9ICcnLCBub2RlQm9yZGVyUmFkaXVzID0gNSwgbm9kZVN0cm9rZVdpZHRoLCBcbi8qXG4gKiBXZSBuZWVkIHRvIHJlbmFtZSB0aGUgcHJvcCB0byBiZSBgQ2FwaXRhbENhc2VgIHNvIHRoYXQgSlNYIHdpbGwgcmVuZGVyIGl0IGFzXG4gKiBhIGNvbXBvbmVudCBwcm9wZXJseS5cbiAqL1xubm9kZUNvbXBvbmVudCwgYmdDb2xvciwgbWFza0NvbG9yLCBtYXNrU3Ryb2tlQ29sb3IsIG1hc2tTdHJva2VXaWR0aCwgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0Jywgb25DbGljaywgb25Ob2RlQ2xpY2ssIHBhbm5hYmxlID0gZmFsc2UsIHpvb21hYmxlID0gZmFsc2UsIGFyaWFMYWJlbCwgaW52ZXJzZVBhbiwgem9vbVN0ZXAgPSAxLCBvZmZzZXRTY2FsZSA9IDUsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgc3ZnID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgYm91bmRpbmdSZWN0LCB2aWV3QkIsIHJmSWQsIHBhblpvb20sIHRyYW5zbGF0ZUV4dGVudCwgZmxvd1dpZHRoLCBmbG93SGVpZ2h0LCBhcmlhTGFiZWxDb25maWcgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDEsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGVsZW1lbnRXaWR0aCA9IHN0eWxlPy53aWR0aCA/PyBkZWZhdWx0V2lkdGg7XG4gICAgY29uc3QgZWxlbWVudEhlaWdodCA9IHN0eWxlPy5oZWlnaHQgPz8gZGVmYXVsdEhlaWdodDtcbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGVsZW1lbnRXaWR0aDtcbiAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBib3VuZGluZ1JlY3QuaGVpZ2h0IC8gZWxlbWVudEhlaWdodDtcbiAgICBjb25zdCB2aWV3U2NhbGUgPSBNYXRoLm1heChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICBjb25zdCB2aWV3V2lkdGggPSB2aWV3U2NhbGUgKiBlbGVtZW50V2lkdGg7XG4gICAgY29uc3Qgdmlld0hlaWdodCA9IHZpZXdTY2FsZSAqIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0U2NhbGUgKiB2aWV3U2NhbGU7XG4gICAgY29uc3QgeCA9IGJvdW5kaW5nUmVjdC54IC0gKHZpZXdXaWR0aCAtIGJvdW5kaW5nUmVjdC53aWR0aCkgLyAyIC0gb2Zmc2V0O1xuICAgIGNvbnN0IHkgPSBib3VuZGluZ1JlY3QueSAtICh2aWV3SGVpZ2h0IC0gYm91bmRpbmdSZWN0LmhlaWdodCkgLyAyIC0gb2Zmc2V0O1xuICAgIGNvbnN0IHdpZHRoID0gdmlld1dpZHRoICsgb2Zmc2V0ICogMjtcbiAgICBjb25zdCBoZWlnaHQgPSB2aWV3SGVpZ2h0ICsgb2Zmc2V0ICogMjtcbiAgICBjb25zdCBsYWJlbGxlZEJ5ID0gYCR7QVJJQV9MQUJFTF9LRVl9LSR7cmZJZH1gO1xuICAgIGNvbnN0IHZpZXdTY2FsZVJlZiA9IHVzZVJlZigwKTtcbiAgICBjb25zdCBtaW5pbWFwSW5zdGFuY2UgPSB1c2VSZWYoKTtcbiAgICB2aWV3U2NhbGVSZWYuY3VycmVudCA9IHZpZXdTY2FsZTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc3ZnLmN1cnJlbnQgJiYgcGFuWm9vbSkge1xuICAgICAgICAgICAgbWluaW1hcEluc3RhbmNlLmN1cnJlbnQgPSBYWU1pbmltYXAoe1xuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHN2Zy5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHBhblpvb20sXG4gICAgICAgICAgICAgICAgZ2V0VHJhbnNmb3JtOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBnZXRWaWV3U2NhbGU6ICgpID0+IHZpZXdTY2FsZVJlZi5jdXJyZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1pbmltYXBJbnN0YW5jZS5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW3Bhblpvb21dKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBtaW5pbWFwSW5zdGFuY2UuY3VycmVudD8udXBkYXRlKHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgICAgIHdpZHRoOiBmbG93V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGZsb3dIZWlnaHQsXG4gICAgICAgICAgICBpbnZlcnNlUGFuLFxuICAgICAgICAgICAgcGFubmFibGUsXG4gICAgICAgICAgICB6b29tU3RlcCxcbiAgICAgICAgICAgIHpvb21hYmxlLFxuICAgICAgICB9KTtcbiAgICB9LCBbcGFubmFibGUsIHpvb21hYmxlLCBpbnZlcnNlUGFuLCB6b29tU3RlcCwgdHJhbnNsYXRlRXh0ZW50LCBmbG93V2lkdGgsIGZsb3dIZWlnaHRdKTtcbiAgICBjb25zdCBvblN2Z0NsaWNrID0gb25DbGlja1xuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3gsIHldID0gbWluaW1hcEluc3RhbmNlLmN1cnJlbnQ/LnBvaW50ZXIoZXZlbnQpIHx8IFswLCAwXTtcbiAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIHsgeCwgeSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvblN2Z05vZGVDbGljayA9IG9uTm9kZUNsaWNrXG4gICAgICAgID8gdXNlQ2FsbGJhY2soKGV2ZW50LCBub2RlSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVMb29rdXAuZ2V0KG5vZGVJZCkuaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgICAgICAgICAgb25Ob2RlQ2xpY2soZXZlbnQsIG5vZGUpO1xuICAgICAgICB9LCBbXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgX2FyaWFMYWJlbCA9IGFyaWFMYWJlbCA/PyBhcmlhTGFiZWxDb25maWdbJ21pbmltYXAuYXJpYUxhYmVsJ107XG4gICAgcmV0dXJuIChqc3goUGFuZWwsIHsgcG9zaXRpb246IHBvc2l0aW9uLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiB0eXBlb2YgYmdDb2xvciA9PT0gJ3N0cmluZycgPyBiZ0NvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1tYXNrLWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiB0eXBlb2YgbWFza0NvbG9yID09PSAnc3RyaW5nJyA/IG1hc2tDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbWFzay1zdHJva2UtY29sb3ItcHJvcHMnOiB0eXBlb2YgbWFza1N0cm9rZUNvbG9yID09PSAnc3RyaW5nJyA/IG1hc2tTdHJva2VDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbWFzay1zdHJva2Utd2lkdGgtcHJvcHMnOiB0eXBlb2YgbWFza1N0cm9rZVdpZHRoID09PSAnbnVtYmVyJyA/IG1hc2tTdHJva2VXaWR0aCAqIHZpZXdTY2FsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbm9kZS1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogdHlwZW9mIG5vZGVDb2xvciA9PT0gJ3N0cmluZycgPyBub2RlQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW5vZGUtc3Ryb2tlLWNvbG9yLXByb3BzJzogdHlwZW9mIG5vZGVTdHJva2VDb2xvciA9PT0gJ3N0cmluZycgPyBub2RlU3Ryb2tlQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW5vZGUtc3Ryb2tlLXdpZHRoLXByb3BzJzogdHlwZW9mIG5vZGVTdHJva2VXaWR0aCA9PT0gJ251bWJlcicgPyBub2RlU3Ryb2tlV2lkdGggOiB1bmRlZmluZWQsXG4gICAgICAgIH0sIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19taW5pbWFwJywgY2xhc3NOYW1lXSksIFwiZGF0YS10ZXN0aWRcIjogXCJyZl9fbWluaW1hcFwiLCBjaGlsZHJlbjoganN4cyhcInN2Z1wiLCB7IHdpZHRoOiBlbGVtZW50V2lkdGgsIGhlaWdodDogZWxlbWVudEhlaWdodCwgdmlld0JveDogYCR7eH0gJHt5fSAke3dpZHRofSAke2hlaWdodH1gLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbWluaW1hcC1zdmdcIiwgcm9sZTogXCJpbWdcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxsZWRCeSwgcmVmOiBzdmcsIG9uQ2xpY2s6IG9uU3ZnQ2xpY2ssIGNoaWxkcmVuOiBbX2FyaWFMYWJlbCAmJiBqc3goXCJ0aXRsZVwiLCB7IGlkOiBsYWJlbGxlZEJ5LCBjaGlsZHJlbjogX2FyaWFMYWJlbCB9KSwganN4KE1pbmlNYXBOb2RlcyQxLCB7IG9uQ2xpY2s6IG9uU3ZnTm9kZUNsaWNrLCBub2RlQ29sb3I6IG5vZGVDb2xvciwgbm9kZVN0cm9rZUNvbG9yOiBub2RlU3Ryb2tlQ29sb3IsIG5vZGVCb3JkZXJSYWRpdXM6IG5vZGVCb3JkZXJSYWRpdXMsIG5vZGVDbGFzc05hbWU6IG5vZGVDbGFzc05hbWUsIG5vZGVTdHJva2VXaWR0aDogbm9kZVN0cm9rZVdpZHRoLCBub2RlQ29tcG9uZW50OiBub2RlQ29tcG9uZW50IH0pLCBqc3goXCJwYXRoXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX21pbmltYXAtbWFza1wiLCBkOiBgTSR7eCAtIG9mZnNldH0sJHt5IC0gb2Zmc2V0fWgke3dpZHRoICsgb2Zmc2V0ICogMn12JHtoZWlnaHQgKyBvZmZzZXQgKiAyfWgkey13aWR0aCAtIG9mZnNldCAqIDJ9elxuICAgICAgICBNJHt2aWV3QkIueH0sJHt2aWV3QkIueX1oJHt2aWV3QkIud2lkdGh9diR7dmlld0JCLmhlaWdodH1oJHstdmlld0JCLndpZHRofXpgLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiIH0pXSB9KSB9KSk7XG59XG5NaW5pTWFwQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ01pbmlNYXAnO1xuLyoqXG4gKiBUaGUgYDxNaW5pTWFwIC8+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gcmVuZGVyIGFuIG92ZXJ2aWV3IG9mIHlvdXIgZmxvdy4gSXRcbiAqIHJlbmRlcnMgZWFjaCBub2RlIGFzIGFuIFNWRyBlbGVtZW50IGFuZCB2aXN1YWxpemVzIHdoZXJlIHRoZSBjdXJyZW50IHZpZXdwb3J0IGlzXG4gKiBpbiByZWxhdGlvbiB0byB0aGUgcmVzdCBvZiB0aGUgZmxvdy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIE1pbmlNYXAgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e1suLi5dXX0gZWRnZXM9e1suLi5dXX0+XG4gKiAgICAgIDxNaW5pTWFwIG5vZGVTdHJva2VXaWR0aD17M30gLz5cbiAqICAgIDwvUmVhY3RGbG93PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IE1pbmlNYXAgPSBtZW1vKE1pbmlNYXBDb21wb25lbnQpO1xuXG5jb25zdCBzY2FsZVNlbGVjdG9yID0gKGNhbGN1bGF0ZVNjYWxlKSA9PiAoc3RvcmUpID0+IGNhbGN1bGF0ZVNjYWxlID8gYCR7TWF0aC5tYXgoMSAvIHN0b3JlLnRyYW5zZm9ybVsyXSwgMSl9YCA6IHVuZGVmaW5lZDtcbmNvbnN0IGRlZmF1bHRQb3NpdGlvbnMgPSB7XG4gICAgW1Jlc2l6ZUNvbnRyb2xWYXJpYW50LkxpbmVdOiAncmlnaHQnLFxuICAgIFtSZXNpemVDb250cm9sVmFyaWFudC5IYW5kbGVdOiAnYm90dG9tLXJpZ2h0Jyxcbn07XG5mdW5jdGlvbiBSZXNpemVDb250cm9sKHsgbm9kZUlkLCBwb3NpdGlvbiwgdmFyaWFudCA9IFJlc2l6ZUNvbnRyb2xWYXJpYW50LkhhbmRsZSwgY2xhc3NOYW1lLCBzdHlsZSA9IHVuZGVmaW5lZCwgY2hpbGRyZW4sIGNvbG9yLCBtaW5XaWR0aCA9IDEwLCBtaW5IZWlnaHQgPSAxMCwgbWF4V2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFLCBtYXhIZWlnaHQgPSBOdW1iZXIuTUFYX1ZBTFVFLCBrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZSwgcmVzaXplRGlyZWN0aW9uLCBhdXRvU2NhbGUgPSB0cnVlLCBzaG91bGRSZXNpemUsIG9uUmVzaXplU3RhcnQsIG9uUmVzaXplLCBvblJlc2l6ZUVuZCwgfSkge1xuICAgIGNvbnN0IGNvbnRleHROb2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBpZCA9IHR5cGVvZiBub2RlSWQgPT09ICdzdHJpbmcnID8gbm9kZUlkIDogY29udGV4dE5vZGVJZDtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgcmVzaXplQ29udHJvbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpc0hhbmRsZUNvbnRyb2wgPSB2YXJpYW50ID09PSBSZXNpemVDb250cm9sVmFyaWFudC5IYW5kbGU7XG4gICAgY29uc3Qgc2NhbGUgPSB1c2VTdG9yZSh1c2VDYWxsYmFjayhzY2FsZVNlbGVjdG9yKGlzSGFuZGxlQ29udHJvbCAmJiBhdXRvU2NhbGUpLCBbaXNIYW5kbGVDb250cm9sLCBhdXRvU2NhbGVdKSwgc2hhbGxvdyk7XG4gICAgY29uc3QgcmVzaXplciA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb250cm9sUG9zaXRpb24gPSBwb3NpdGlvbiA/PyBkZWZhdWx0UG9zaXRpb25zW3ZhcmlhbnRdO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghcmVzaXplQ29udHJvbFJlZi5jdXJyZW50IHx8ICFpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzaXplci5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXNpemVyLmN1cnJlbnQgPSBYWVJlc2l6ZXIoe1xuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHJlc2l6ZUNvbnRyb2xSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBub2RlSWQ6IGlkLFxuICAgICAgICAgICAgICAgIGdldFN0b3JlSXRlbXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcFRvR3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lRG9tTm9kZTogZG9tTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoY2hhbmdlLCBjaGlsZENoYW5nZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0cmlnZ2VyTm9kZUNoYW5nZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB7IHg6IGNoYW5nZS54LCB5OiBjaGFuZ2UueSB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLmV4cGFuZFBhcmVudCAmJiBub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBjaGFuZ2Uud2lkdGggPz8gbm9kZS5tZWFzdXJlZC53aWR0aCA/PyAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gY2hhbmdlLmhlaWdodCA/PyBub2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ldmFsdWF0ZUFic29sdXRlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2hhbmdlLnggPz8gbm9kZS5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hhbmdlLnkgPz8gbm9kZS5wb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7IHdpZHRoLCBoZWlnaHQgfSwgbm9kZS5wYXJlbnRJZCwgbm9kZUxvb2t1cCwgb3JpZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQoW2NoaWxkXSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB3aGVuIHRoZSBwYXJlbnQgd2FzIGV4cGFuZGVkIGJ5IHRoZSBjaGlsZCBub2RlLCBpdHMgcG9zaXRpb24gd2lsbCBiZSBjbGFtcGVkIGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAwLDAgd2hlbiBub2RlIG9yaWdpbiBpcyAwLDAgYW5kIHRvIHdpZHRoLCBoZWlnaHQgaWYgaXQncyAxLDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLnggPSBjaGFuZ2UueCA/IE1hdGgubWF4KG9yaWdpblswXSAqIHdpZHRoLCBjaGFuZ2UueCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24ueSA9IGNoYW5nZS55ID8gTWF0aC5tYXgob3JpZ2luWzFdICogaGVpZ2h0LCBjaGFuZ2UueSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRQb3NpdGlvbi54ICE9PSB1bmRlZmluZWQgJiYgbmV4dFBvc2l0aW9uLnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyAuLi5uZXh0UG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2gocG9zaXRpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uud2lkdGggIT09IHVuZGVmaW5lZCAmJiBjaGFuZ2UuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldEF0dHJpYnV0ZXMgPSAhcmVzaXplRGlyZWN0aW9uID8gdHJ1ZSA6IHJlc2l6ZURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNoYW5nZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjaGFuZ2UuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGRpbWVuc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZENoYW5nZSBvZiBjaGlsZENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHBvc2l0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkVuZDogKHsgd2lkdGgsIGhlaWdodCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLnRyaWdnZXJOb2RlQ2hhbmdlcyhbZGltZW5zaW9uQ2hhbmdlXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc2l6ZXIuY3VycmVudC51cGRhdGUoe1xuICAgICAgICAgICAgY29udHJvbFBvc2l0aW9uLFxuICAgICAgICAgICAgYm91bmRhcmllczoge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgICAgIG1pbkhlaWdodCxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2VlcEFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgcmVzaXplRGlyZWN0aW9uLFxuICAgICAgICAgICAgb25SZXNpemVTdGFydCxcbiAgICAgICAgICAgIG9uUmVzaXplLFxuICAgICAgICAgICAgb25SZXNpemVFbmQsXG4gICAgICAgICAgICBzaG91bGRSZXNpemUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplci5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjb250cm9sUG9zaXRpb24sXG4gICAgICAgIG1pbldpZHRoLFxuICAgICAgICBtaW5IZWlnaHQsXG4gICAgICAgIG1heFdpZHRoLFxuICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgIGtlZXBBc3BlY3RSYXRpbyxcbiAgICAgICAgb25SZXNpemVTdGFydCxcbiAgICAgICAgb25SZXNpemUsXG4gICAgICAgIG9uUmVzaXplRW5kLFxuICAgICAgICBzaG91bGRSZXNpemUsXG4gICAgXSk7XG4gICAgY29uc3QgcG9zaXRpb25DbGFzc05hbWVzID0gY29udHJvbFBvc2l0aW9uLnNwbGl0KCctJyk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcmVzaXplLWNvbnRyb2wnLCAnbm9kcmFnJywgLi4ucG9zaXRpb25DbGFzc05hbWVzLCB2YXJpYW50LCBjbGFzc05hbWVdKSwgcmVmOiByZXNpemVDb250cm9sUmVmLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgIC4uLihjb2xvciAmJiB7IFtpc0hhbmRsZUNvbnRyb2wgPyAnYmFja2dyb3VuZENvbG9yJyA6ICdib3JkZXJDb2xvciddOiBjb2xvciB9KSxcbiAgICAgICAgfSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cbi8qKlxuICogVG8gY3JlYXRlIHlvdXIgb3duIHJlc2l6aW5nIFVJLCB5b3UgY2FuIHVzZSB0aGUgYE5vZGVSZXNpemVDb250cm9sYCBjb21wb25lbnQgd2hlcmUgeW91IGNhbiBwYXNzIGNoaWxkcmVuIChzdWNoIGFzIGljb25zKS5cbiAqIEBwdWJsaWNcbiAqXG4gKi9cbmNvbnN0IE5vZGVSZXNpemVDb250cm9sID0gbWVtbyhSZXNpemVDb250cm9sKTtcblxuLyoqXG4gKiBUaGUgYDxOb2RlUmVzaXplciAvPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGFkZCBhIHJlc2l6ZSBmdW5jdGlvbmFsaXR5IHRvIHlvdXJcbiAqIG5vZGVzLiBJdCByZW5kZXJzIGRyYWdnYWJsZSBjb250cm9scyBhcm91bmQgdGhlIG5vZGUgdG8gcmVzaXplIGluIGFsbCBkaXJlY3Rpb25zLlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKmBgYGpzeFxuICppbXBvcnQgeyBtZW1vIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBIYW5kbGUsIFBvc2l0aW9uLCBOb2RlUmVzaXplciB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gUmVzaXphYmxlTm9kZSh7IGRhdGEgfSkge1xuICogIHJldHVybiAoXG4gKiAgICA8PlxuICogICAgICA8Tm9kZVJlc2l6ZXIgbWluV2lkdGg9ezEwMH0gbWluSGVpZ2h0PXszMH0gLz5cbiAqICAgICAgPEhhbmRsZSB0eXBlPVwidGFyZ2V0XCIgcG9zaXRpb249e1Bvc2l0aW9uLkxlZnR9IC8+XG4gKiAgICAgIDxkaXYgc3R5bGU9e3sgcGFkZGluZzogMTAgfX0+e2RhdGEubGFiZWx9PC9kaXY+XG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInNvdXJjZVwiIHBvc2l0aW9uPXtQb3NpdGlvbi5SaWdodH0gLz5cbiAqICAgIDwvPlxuICogICk7XG4gKn07XG4gKlxuICpleHBvcnQgZGVmYXVsdCBtZW1vKFJlc2l6YWJsZU5vZGUpO1xuICpgYGBcbiAqL1xuZnVuY3Rpb24gTm9kZVJlc2l6ZXIoeyBub2RlSWQsIGlzVmlzaWJsZSA9IHRydWUsIGhhbmRsZUNsYXNzTmFtZSwgaGFuZGxlU3R5bGUsIGxpbmVDbGFzc05hbWUsIGxpbmVTdHlsZSwgY29sb3IsIG1pbldpZHRoID0gMTAsIG1pbkhlaWdodCA9IDEwLCBtYXhXaWR0aCA9IE51bWJlci5NQVhfVkFMVUUsIG1heEhlaWdodCA9IE51bWJlci5NQVhfVkFMVUUsIGtlZXBBc3BlY3RSYXRpbyA9IGZhbHNlLCBhdXRvU2NhbGUgPSB0cnVlLCBzaG91bGRSZXNpemUsIG9uUmVzaXplU3RhcnQsIG9uUmVzaXplLCBvblJlc2l6ZUVuZCwgfSkge1xuICAgIGlmICghaXNWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TLm1hcCgocG9zaXRpb24pID0+IChqc3goTm9kZVJlc2l6ZUNvbnRyb2wsIHsgY2xhc3NOYW1lOiBsaW5lQ2xhc3NOYW1lLCBzdHlsZTogbGluZVN0eWxlLCBub2RlSWQ6IG5vZGVJZCwgcG9zaXRpb246IHBvc2l0aW9uLCB2YXJpYW50OiBSZXNpemVDb250cm9sVmFyaWFudC5MaW5lLCBjb2xvcjogY29sb3IsIG1pbldpZHRoOiBtaW5XaWR0aCwgbWluSGVpZ2h0OiBtaW5IZWlnaHQsIG1heFdpZHRoOiBtYXhXaWR0aCwgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsIG9uUmVzaXplU3RhcnQ6IG9uUmVzaXplU3RhcnQsIGtlZXBBc3BlY3RSYXRpbzoga2VlcEFzcGVjdFJhdGlvLCBhdXRvU2NhbGU6IGF1dG9TY2FsZSwgc2hvdWxkUmVzaXplOiBzaG91bGRSZXNpemUsIG9uUmVzaXplOiBvblJlc2l6ZSwgb25SZXNpemVFbmQ6IG9uUmVzaXplRW5kIH0sIHBvc2l0aW9uKSkpLCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMubWFwKChwb3NpdGlvbikgPT4gKGpzeChOb2RlUmVzaXplQ29udHJvbCwgeyBjbGFzc05hbWU6IGhhbmRsZUNsYXNzTmFtZSwgc3R5bGU6IGhhbmRsZVN0eWxlLCBub2RlSWQ6IG5vZGVJZCwgcG9zaXRpb246IHBvc2l0aW9uLCBjb2xvcjogY29sb3IsIG1pbldpZHRoOiBtaW5XaWR0aCwgbWluSGVpZ2h0OiBtaW5IZWlnaHQsIG1heFdpZHRoOiBtYXhXaWR0aCwgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsIG9uUmVzaXplU3RhcnQ6IG9uUmVzaXplU3RhcnQsIGtlZXBBc3BlY3RSYXRpbzoga2VlcEFzcGVjdFJhdGlvLCBhdXRvU2NhbGU6IGF1dG9TY2FsZSwgc2hvdWxkUmVzaXplOiBzaG91bGRSZXNpemUsIG9uUmVzaXplOiBvblJlc2l6ZSwgb25SZXNpemVFbmQ6IG9uUmVzaXplRW5kIH0sIHBvc2l0aW9uKSkpXSB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yID0gKHN0YXRlKSA9PiBzdGF0ZS5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fcmVuZGVyZXInKTtcbmZ1bmN0aW9uIE5vZGVUb29sYmFyUG9ydGFsKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHdyYXBwZXJSZWYgPSB1c2VTdG9yZShzZWxlY3Rvcik7XG4gICAgaWYgKCF3cmFwcGVyUmVmKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCB3cmFwcGVyUmVmKTtcbn1cblxuY29uc3Qgbm9kZUVxdWFsaXR5Rm4gPSAoYSwgYikgPT4gYT8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCAhPT0gYj8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCB8fFxuICAgIGE/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgIT09IGI/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgfHxcbiAgICBhPy5tZWFzdXJlZC53aWR0aCAhPT0gYj8ubWVhc3VyZWQud2lkdGggfHxcbiAgICBhPy5tZWFzdXJlZC5oZWlnaHQgIT09IGI/Lm1lYXN1cmVkLmhlaWdodCB8fFxuICAgIGE/LnNlbGVjdGVkICE9PSBiPy5zZWxlY3RlZCB8fFxuICAgIGE/LmludGVybmFscy56ICE9PSBiPy5pbnRlcm5hbHMuejtcbmNvbnN0IG5vZGVzRXF1YWxpdHlGbiA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBhKSB7XG4gICAgICAgIGlmIChub2RlRXF1YWxpdHlGbihub2RlLCBiLmdldChrZXkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IHN0b3JlU2VsZWN0b3IgPSAoc3RhdGUpID0+ICh7XG4gICAgeDogc3RhdGUudHJhbnNmb3JtWzBdLFxuICAgIHk6IHN0YXRlLnRyYW5zZm9ybVsxXSxcbiAgICB6b29tOiBzdGF0ZS50cmFuc2Zvcm1bMl0sXG4gICAgc2VsZWN0ZWROb2Rlc0NvdW50OiBzdGF0ZS5ub2Rlcy5maWx0ZXIoKG5vZGUpID0+IG5vZGUuc2VsZWN0ZWQpLmxlbmd0aCxcbn0pO1xuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBjYW4gcmVuZGVyIGEgdG9vbGJhciBvciB0b29sdGlwIHRvIG9uZSBzaWRlIG9mIGEgY3VzdG9tIG5vZGUuIFRoaXNcbiAqIHRvb2xiYXIgZG9lc24ndCBzY2FsZSB3aXRoIHRoZSB2aWV3cG9ydCBzbyB0aGF0IHRoZSBjb250ZW50IGlzIGFsd2F5cyB2aXNpYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgSGFuZGxlLCBQb3NpdGlvbiwgTm9kZVRvb2xiYXIgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIEN1c3RvbU5vZGUoeyBkYXRhIH0pIHtcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAgPE5vZGVUb29sYmFyIGlzVmlzaWJsZT17ZGF0YS50b29sYmFyVmlzaWJsZX0gcG9zaXRpb249e2RhdGEudG9vbGJhclBvc2l0aW9ufT5cbiAqICAgICAgICA8YnV0dG9uPmRlbGV0ZTwvYnV0dG9uPlxuICogICAgICAgIDxidXR0b24+Y29weTwvYnV0dG9uPlxuICogICAgICAgIDxidXR0b24+ZXhwYW5kPC9idXR0b24+XG4gKiAgICAgIDwvTm9kZVRvb2xiYXI+XG4gKlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4IDIwcHgnIH19PlxuICogICAgICAgIHtkYXRhLmxhYmVsfVxuICogICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgbWVtbyhDdXN0b21Ob2RlKTtcbiAqYGBgXG4gKiBAcmVtYXJrcyBCeSBkZWZhdWx0LCB0aGUgdG9vbGJhciBpcyBvbmx5IHZpc2libGUgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWQuIElmIG11bHRpcGxlXG4gKiBub2RlcyBhcmUgc2VsZWN0ZWQgaXQgd2lsbCBub3QgYmUgdmlzaWJsZSB0byBwcmV2ZW50IG92ZXJsYXBwaW5nIHRvb2xiYXJzIG9yXG4gKiBjbHV0dGVyLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgYnkgc2V0dGluZyB0aGUgYGlzVmlzaWJsZWAgcHJvcCB0byBgdHJ1ZWAuXG4gKi9cbmZ1bmN0aW9uIE5vZGVUb29sYmFyKHsgbm9kZUlkLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgaXNWaXNpYmxlLCBwb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgb2Zmc2V0ID0gMTAsIGFsaWduID0gJ2NlbnRlcicsIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IGNvbnRleHROb2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBub2Rlc1NlbGVjdG9yID0gdXNlQ2FsbGJhY2soKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGVJZHMgPSBBcnJheS5pc0FycmF5KG5vZGVJZCkgPyBub2RlSWQgOiBbbm9kZUlkIHx8IGNvbnRleHROb2RlSWQgfHwgJyddO1xuICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGVzID0gbm9kZUlkcy5yZWR1Y2UoKHJlcywgaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdGF0ZS5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBuZXcgTWFwKCkpO1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxOb2RlcztcbiAgICB9LCBbbm9kZUlkLCBjb250ZXh0Tm9kZUlkXSk7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VTdG9yZShub2Rlc1NlbGVjdG9yLCBub2Rlc0VxdWFsaXR5Rm4pO1xuICAgIGNvbnN0IHsgeCwgeSwgem9vbSwgc2VsZWN0ZWROb2Rlc0NvdW50IH0gPSB1c2VTdG9yZShzdG9yZVNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICAvLyBpZiBpc1Zpc2libGUgaXMgbm90IHNldCwgd2Ugc2hvdyB0aGUgdG9vbGJhciBvbmx5IGlmIGl0cyBub2RlIGlzIHNlbGVjdGVkIGFuZCBubyBvdGhlciBub2RlIGlzIHNlbGVjdGVkXG4gICAgY29uc3QgaXNBY3RpdmUgPSB0eXBlb2YgaXNWaXNpYmxlID09PSAnYm9vbGVhbidcbiAgICAgICAgPyBpc1Zpc2libGVcbiAgICAgICAgOiBub2Rlcy5zaXplID09PSAxICYmIG5vZGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZT8uc2VsZWN0ZWQgJiYgc2VsZWN0ZWROb2Rlc0NvdW50ID09PSAxO1xuICAgIGlmICghaXNBY3RpdmUgfHwgIW5vZGVzLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVSZWN0ID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2Rlcyk7XG4gICAgY29uc3Qgbm9kZXNBcnJheSA9IEFycmF5LmZyb20obm9kZXMudmFsdWVzKCkpO1xuICAgIGNvbnN0IHpJbmRleCA9IE1hdGgubWF4KC4uLm5vZGVzQXJyYXkubWFwKChub2RlKSA9PiBub2RlLmludGVybmFscy56ICsgMSkpO1xuICAgIGNvbnN0IHdyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRyYW5zZm9ybTogZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0obm9kZVJlY3QsIHsgeCwgeSwgem9vbSB9LCBwb3NpdGlvbiwgb2Zmc2V0LCBhbGlnbiksXG4gICAgICAgIHpJbmRleCxcbiAgICAgICAgLi4uc3R5bGUsXG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChOb2RlVG9vbGJhclBvcnRhbCwgeyBjaGlsZHJlbjoganN4KFwiZGl2XCIsIHsgc3R5bGU6IHdyYXBwZXJTdHlsZSwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX25vZGUtdG9vbGJhcicsIGNsYXNzTmFtZV0pLCAuLi5yZXN0LCBcImRhdGEtaWRcIjogbm9kZXNBcnJheS5yZWR1Y2UoKGFjYywgbm9kZSkgPT4gYCR7YWNjfSR7bm9kZS5pZH0gYCwgJycpLnRyaW0oKSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pKTtcbn1cblxuZXhwb3J0IHsgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQsIEJhc2VFZGdlLCBCZXppZXJFZGdlLCBDb250cm9sQnV0dG9uLCBDb250cm9scywgRWRnZUxhYmVsUmVuZGVyZXIsIEVkZ2VUZXh0LCBIYW5kbGUsIE1pbmlNYXAsIE1pbmlNYXBOb2RlLCBOb2RlUmVzaXplQ29udHJvbCwgTm9kZVJlc2l6ZXIsIE5vZGVUb29sYmFyLCBQYW5lbCwgaW5kZXggYXMgUmVhY3RGbG93LCBSZWFjdEZsb3dQcm92aWRlciwgU2ltcGxlQmV6aWVyRWRnZSwgU21vb3RoU3RlcEVkZ2UsIFN0ZXBFZGdlLCBTdHJhaWdodEVkZ2UsIFZpZXdwb3J0UG9ydGFsLCBhcHBseUVkZ2VDaGFuZ2VzLCBhcHBseU5vZGVDaGFuZ2VzLCBnZXRTaW1wbGVCZXppZXJQYXRoLCBpc0VkZ2UsIGlzTm9kZSwgdXNlQ29ubmVjdGlvbiwgdXNlRWRnZXMsIHVzZUVkZ2VzU3RhdGUsIHVzZUhhbmRsZUNvbm5lY3Rpb25zLCB1c2VJbnRlcm5hbE5vZGUsIHVzZUtleVByZXNzLCB1c2VOb2RlQ29ubmVjdGlvbnMsIHVzZU5vZGVJZCwgdXNlTm9kZXMsIHVzZU5vZGVzRGF0YSwgdXNlTm9kZXNJbml0aWFsaXplZCwgdXNlTm9kZXNTdGF0ZSwgdXNlT25TZWxlY3Rpb25DaGFuZ2UsIHVzZU9uVmlld3BvcnRDaGFuZ2UsIHVzZVJlYWN0RmxvdywgdXNlU3RvcmUsIHVzZVN0b3JlQXBpLCB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzLCB1c2VWaWV3cG9ydCB9O1xuIl0sIm5hbWVzIjpbImpzeHMiLCJGcmFnbWVudCIsImpzeCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlTWVtbyIsImZvcndhcmRSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUxheW91dEVmZmVjdCIsInVzZUNhbGxiYWNrIiwibWVtbyIsImNjIiwiZXJyb3JNZXNzYWdlcyIsIm1lcmdlQXJpYUxhYmVsQ29uZmlnIiwiaW5maW5pdGVFeHRlbnQiLCJpc0lucHV0RE9NTm9kZSIsImdldFZpZXdwb3J0Rm9yQm91bmRzIiwicG9pbnRUb1JlbmRlcmVyUG9pbnQiLCJyZW5kZXJlclBvaW50VG9Qb2ludCIsImlzTm9kZUJhc2UiLCJpc0VkZ2VCYXNlIiwiZ2V0RWxlbWVudHNUb1JlbW92ZSIsImlzUmVjdE9iamVjdCIsIm5vZGVUb1JlY3QiLCJnZXRPdmVybGFwcGluZ0FyZWEiLCJnZXROb2Rlc0JvdW5kcyIsIndpdGhSZXNvbHZlcnMiLCJldmFsdWF0ZUFic29sdXRlUG9zaXRpb24iLCJnZXREaW1lbnNpb25zIiwiWFlQYW5ab29tIiwiUGFuT25TY3JvbGxNb2RlIiwiU2VsZWN0aW9uTW9kZSIsImdldEV2ZW50UG9zaXRpb24iLCJnZXROb2Rlc0luc2lkZSIsImFyZVNldHNFcXVhbCIsIlhZRHJhZyIsInNuYXBQb3NpdGlvbiIsImNhbGN1bGF0ZU5vZGVQb3NpdGlvbiIsIlBvc2l0aW9uIiwiQ29ubmVjdGlvbk1vZGUiLCJpc01vdXNlRXZlbnQiLCJYWUhhbmRsZSIsImdldEhvc3RGb3JFbGVtZW50IiwiYWRkRWRnZSIsImdldEludGVybmFsTm9kZXNCb3VuZHMiLCJpc051bWVyaWMiLCJub2RlSGFzRGltZW5zaW9ucyIsImdldE5vZGVEaW1lbnNpb25zIiwiZWxlbWVudFNlbGVjdGlvbktleXMiLCJpc0VkZ2VWaXNpYmxlIiwiTWFya2VyVHlwZSIsImNyZWF0ZU1hcmtlcklkcyIsImdldEJlemllckVkZ2VDZW50ZXIiLCJnZXRTbW9vdGhTdGVwUGF0aCIsImdldFN0cmFpZ2h0UGF0aCIsImdldEJlemllclBhdGgiLCJnZXRFZGdlUG9zaXRpb24iLCJnZXRFbGV2YXRlZEVkZ2VaSW5kZXgiLCJnZXRNYXJrZXJJZCIsImdldENvbm5lY3Rpb25TdGF0dXMiLCJDb25uZWN0aW9uTGluZVR5cGUiLCJ1cGRhdGVDb25uZWN0aW9uTG9va3VwIiwiYWRvcHRVc2VyTm9kZXMiLCJpbml0aWFsQ29ubmVjdGlvbiIsImRldldhcm4iLCJkZWZhdWx0QXJpYUxhYmVsQ29uZmlnIiwidXBkYXRlTm9kZUludGVybmFscyIsInVwZGF0ZUFic29sdXRlUG9zaXRpb25zIiwiaGFuZGxlRXhwYW5kUGFyZW50IiwicGFuQnkiLCJmaXRWaWV3cG9ydCIsImlzTWFjT3MiLCJhcmVDb25uZWN0aW9uTWFwc0VxdWFsIiwiaGFuZGxlQ29ubmVjdGlvbkNoYW5nZSIsInNoYWxsb3dOb2RlRGF0YSIsIlhZTWluaW1hcCIsImdldEJvdW5kc09mUmVjdHMiLCJSZXNpemVDb250cm9sVmFyaWFudCIsIlhZUmVzaXplciIsIlhZX1JFU0laRVJfTElORV9QT1NJVElPTlMiLCJYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMiLCJnZXROb2RlVG9vbGJhclRyYW5zZm9ybSIsImdldENvbm5lY3RlZEVkZ2VzIiwiZ2V0RWRnZUNlbnRlciIsImdldEluY29tZXJzIiwiZ2V0T3V0Z29lcnMiLCJyZWNvbm5lY3RFZGdlIiwidXNlU3RvcmVXaXRoRXF1YWxpdHlGbiIsImNyZWF0ZVdpdGhFcXVhbGl0eUZuIiwic2hhbGxvdyIsImNyZWF0ZVBvcnRhbCIsIlN0b3JlQ29udGV4dCIsIlByb3ZpZGVyJDEiLCJQcm92aWRlciIsInp1c3RhbmRFcnJvck1lc3NhZ2UiLCJ1c2VTdG9yZSIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbiIsInN0b3JlIiwiRXJyb3IiLCJ1c2VTdG9yZUFwaSIsImdldFN0YXRlIiwic2V0U3RhdGUiLCJzdWJzY3JpYmUiLCJzdHlsZSIsImRpc3BsYXkiLCJhcmlhTGl2ZVN0eWxlIiwicG9zaXRpb24iLCJ3aWR0aCIsImhlaWdodCIsIm1hcmdpbiIsImJvcmRlciIsInBhZGRpbmciLCJvdmVyZmxvdyIsImNsaXAiLCJjbGlwUGF0aCIsIkFSSUFfTk9ERV9ERVNDX0tFWSIsIkFSSUFfRURHRV9ERVNDX0tFWSIsIkFSSUFfTElWRV9NRVNTQUdFIiwiYXJpYUxpdmVTZWxlY3RvciIsInMiLCJhcmlhTGl2ZU1lc3NhZ2UiLCJhcmlhTGFiZWxDb25maWdTZWxlY3RvciIsImFyaWFMYWJlbENvbmZpZyIsIkFyaWFMaXZlTWVzc2FnZSIsInJmSWQiLCJpZCIsImNoaWxkcmVuIiwiQTExeURlc2NyaXB0aW9ucyIsImRpc2FibGVLZXlib2FyZEExMXkiLCJQYW5lbCIsImNsYXNzTmFtZSIsInJlc3QiLCJyZWYiLCJwb3NpdGlvbkNsYXNzZXMiLCJzcGxpdCIsImRpc3BsYXlOYW1lIiwiQXR0cmlidXRpb24iLCJwcm9PcHRpb25zIiwiaGlkZUF0dHJpYnV0aW9uIiwiaHJlZiIsInRhcmdldCIsInJlbCIsInNlbGVjdG9yJG0iLCJzZWxlY3RlZE5vZGVzIiwic2VsZWN0ZWRFZGdlcyIsIm5vZGUiLCJub2RlTG9va3VwIiwic2VsZWN0ZWQiLCJwdXNoIiwiaW50ZXJuYWxzIiwidXNlck5vZGUiLCJlZGdlIiwiZWRnZUxvb2t1cCIsInNlbGVjdElkIiwib2JqIiwiYXJlRXF1YWwiLCJhIiwiYiIsIm1hcCIsIlNlbGVjdGlvbkxpc3RlbmVySW5uZXIiLCJvblNlbGVjdGlvbkNoYW5nZSIsInBhcmFtcyIsIm5vZGVzIiwiZWRnZXMiLCJvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIiwiZm9yRWFjaCIsImZuIiwiY2hhbmdlU2VsZWN0b3IiLCJTZWxlY3Rpb25MaXN0ZW5lciIsInN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMiLCJkZWZhdWx0Tm9kZU9yaWdpbiIsImRlZmF1bHRWaWV3cG9ydCIsIngiLCJ5Iiwiem9vbSIsInJlYWN0Rmxvd0ZpZWxkc1RvVHJhY2siLCJmaWVsZHNUb1RyYWNrIiwic2VsZWN0b3IkbCIsInNldE5vZGVzIiwic2V0RWRnZXMiLCJzZXRNaW5ab29tIiwic2V0TWF4Wm9vbSIsInNldFRyYW5zbGF0ZUV4dGVudCIsInNldE5vZGVFeHRlbnQiLCJyZXNldCIsInNldERlZmF1bHROb2Rlc0FuZEVkZ2VzIiwic2V0UGFuZUNsaWNrRGlzdGFuY2UiLCJpbml0UHJldlZhbHVlcyIsInRyYW5zbGF0ZUV4dGVudCIsIm5vZGVPcmlnaW4iLCJtaW5ab29tIiwibWF4Wm9vbSIsImVsZW1lbnRzU2VsZWN0YWJsZSIsIm5vUGFuQ2xhc3NOYW1lIiwicGFuZUNsaWNrRGlzdGFuY2UiLCJTdG9yZVVwZGF0ZXIiLCJwcm9wcyIsImRlZmF1bHROb2RlcyIsImRlZmF1bHRFZGdlcyIsInByZXZpb3VzRmllbGRzIiwiY3VycmVudCIsImZpZWxkTmFtZSIsImZpZWxkVmFsdWUiLCJwcmV2aW91c0ZpZWxkVmFsdWUiLCJmaXRWaWV3UXVldWVkIiwiZml0Vmlld09wdGlvbnMiLCJnZXRNZWRpYVF1ZXJ5Iiwid2luZG93IiwibWF0Y2hNZWRpYSIsInVzZUNvbG9yTW9kZUNsYXNzIiwiY29sb3JNb2RlIiwiY29sb3JNb2RlQ2xhc3MiLCJzZXRDb2xvck1vZGVDbGFzcyIsIm1lZGlhUXVlcnkiLCJ1cGRhdGVDb2xvck1vZGVDbGFzcyIsIm1hdGNoZXMiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRlZmF1bHREb2MiLCJkb2N1bWVudCIsInVzZUtleVByZXNzIiwia2V5Q29kZSIsIm9wdGlvbnMiLCJhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciIsImtleVByZXNzZWQiLCJzZXRLZXlQcmVzc2VkIiwibW9kaWZpZXJQcmVzc2VkIiwicHJlc3NlZEtleXMiLCJTZXQiLCJrZXlDb2RlcyIsImtleXNUb1dhdGNoIiwia2V5Q29kZUFyciIsIkFycmF5IiwiaXNBcnJheSIsImtleXMiLCJmaWx0ZXIiLCJrYyIsInJlcGxhY2UiLCJrZXlzRmxhdCIsInJlZHVjZSIsInJlcyIsIml0ZW0iLCJjb25jYXQiLCJkb3duSGFuZGxlciIsImV2ZW50IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsInByZXZlbnRBY3Rpb24iLCJrZXlPckNvZGUiLCJ1c2VLZXlPckNvZGUiLCJjb2RlIiwiYWRkIiwiaXNNYXRjaGluZ0tleSIsImNvbXBvc2VkUGF0aCIsImlzSW50ZXJhY3RpdmVFbGVtZW50Iiwibm9kZU5hbWUiLCJwcmV2ZW50RGVmYXVsdCIsInVwSGFuZGxlciIsImNsZWFyIiwiZGVsZXRlIiwia2V5IiwicmVzZXRIYW5kbGVyIiwiaXNVcCIsImxlbmd0aCIsInNpemUiLCJzb21lIiwiZXZlcnkiLCJrIiwiaGFzIiwiZXZlbnRDb2RlIiwiaW5jbHVkZXMiLCJ1c2VWaWV3cG9ydEhlbHBlciIsInpvb21JbiIsInBhblpvb20iLCJzY2FsZUJ5IiwiZHVyYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInpvb21PdXQiLCJ6b29tVG8iLCJ6b29tTGV2ZWwiLCJzY2FsZVRvIiwiZ2V0Wm9vbSIsInRyYW5zZm9ybSIsInNldFZpZXdwb3J0Iiwidmlld3BvcnQiLCJ0WCIsInRZIiwidFpvb20iLCJnZXRWaWV3cG9ydCIsInNldENlbnRlciIsImZpdEJvdW5kcyIsImJvdW5kcyIsImVhc2UiLCJpbnRlcnBvbGF0ZSIsInNjcmVlblRvRmxvd1Bvc2l0aW9uIiwiY2xpZW50UG9zaXRpb24iLCJzbmFwR3JpZCIsInNuYXBUb0dyaWQiLCJkb21Ob2RlIiwiZG9tWCIsImRvbVkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjb3JyZWN0ZWRQb3NpdGlvbiIsIl9zbmFwR3JpZCIsIl9zbmFwVG9HcmlkIiwiZmxvd1RvU2NyZWVuUG9zaXRpb24iLCJmbG93UG9zaXRpb24iLCJyZW5kZXJlclBvc2l0aW9uIiwiYXBwbHlDaGFuZ2VzIiwiY2hhbmdlcyIsImVsZW1lbnRzIiwidXBkYXRlZEVsZW1lbnRzIiwiY2hhbmdlc01hcCIsIk1hcCIsImFkZEl0ZW1DaGFuZ2VzIiwiY2hhbmdlIiwidHlwZSIsInNldCIsImVsZW1lbnRDaGFuZ2VzIiwiZ2V0IiwiZWxlbWVudCIsInVwZGF0ZWRFbGVtZW50IiwiYXBwbHlDaGFuZ2UiLCJpbmRleCIsInVuZGVmaW5lZCIsInNwbGljZSIsImRyYWdnaW5nIiwiZGltZW5zaW9ucyIsIm1lYXN1cmVkIiwic2V0QXR0cmlidXRlcyIsInJlc2l6aW5nIiwiYXBwbHlOb2RlQ2hhbmdlcyIsImFwcGx5RWRnZUNoYW5nZXMiLCJjcmVhdGVTZWxlY3Rpb25DaGFuZ2UiLCJnZXRTZWxlY3Rpb25DaGFuZ2VzIiwiaXRlbXMiLCJzZWxlY3RlZElkcyIsIm11dGF0ZUl0ZW0iLCJ3aWxsQmVTZWxlY3RlZCIsImdldEVsZW1lbnRzRGlmZkNoYW5nZXMiLCJsb29rdXAiLCJpdGVtc0xvb2t1cCIsImVudHJpZXMiLCJsb29rdXBJdGVtIiwic3RvcmVJdGVtIiwibmV4dE5vZGUiLCJlbGVtZW50VG9SZW1vdmVDaGFuZ2UiLCJpc05vZGUiLCJpc0VkZ2UiLCJmaXhlZEZvcndhcmRSZWYiLCJyZW5kZXIiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlUXVldWUiLCJydW5RdWV1ZSIsInNlcmlhbCIsInNldFNlcmlhbCIsIkJpZ0ludCIsInF1ZXVlIiwiY3JlYXRlUXVldWUiLCJuIiwicXVldWVJdGVtcyIsImNiIiwiQmF0Y2hDb250ZXh0IiwiQmF0Y2hQcm92aWRlciIsIm5vZGVRdWV1ZUhhbmRsZXIiLCJoYXNEZWZhdWx0Tm9kZXMiLCJvbk5vZGVzQ2hhbmdlIiwibmV4dCIsInBheWxvYWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJub2RlUXVldWUiLCJlZGdlUXVldWVIYW5kbGVyIiwiaGFzRGVmYXVsdEVkZ2VzIiwib25FZGdlc0NoYW5nZSIsImVkZ2VRdWV1ZSIsInZhbHVlIiwidXNlQmF0Y2hDb250ZXh0IiwiYmF0Y2hDb250ZXh0Iiwic2VsZWN0b3IkayIsInVzZVJlYWN0RmxvdyIsInZpZXdwb3J0SGVscGVyIiwidmlld3BvcnRJbml0aWFsaXplZCIsImdlbmVyYWxIZWxwZXIiLCJnZXRJbnRlcm5hbE5vZGUiLCJnZXROb2RlUmVjdCIsIm5vZGVUb1VzZSIsInBhcmVudElkIiwibm9kZVdpdGhQb3NpdGlvbiIsInVwZGF0ZU5vZGUiLCJub2RlVXBkYXRlIiwicHJldk5vZGVzIiwidXBkYXRlRWRnZSIsImVkZ2VVcGRhdGUiLCJwcmV2RWRnZXMiLCJuZXh0RWRnZSIsImdldE5vZGVzIiwiZ2V0Tm9kZSIsImdldEVkZ2VzIiwiZSIsImdldEVkZ2UiLCJhZGROb2RlcyIsIm5ld05vZGVzIiwiYWRkRWRnZXMiLCJuZXdFZGdlcyIsInRvT2JqZWN0IiwiZGVsZXRlRWxlbWVudHMiLCJub2Rlc1RvUmVtb3ZlIiwiZWRnZXNUb1JlbW92ZSIsIm9uTm9kZXNEZWxldGUiLCJvbkVkZ2VzRGVsZXRlIiwidHJpZ2dlck5vZGVDaGFuZ2VzIiwidHJpZ2dlckVkZ2VDaGFuZ2VzIiwib25EZWxldGUiLCJvbkJlZm9yZURlbGV0ZSIsIm1hdGNoaW5nTm9kZXMiLCJtYXRjaGluZ0VkZ2VzIiwiaGFzTWF0Y2hpbmdFZGdlcyIsImhhc01hdGNoaW5nTm9kZXMiLCJlZGdlQ2hhbmdlcyIsIm5vZGVDaGFuZ2VzIiwiZGVsZXRlZE5vZGVzIiwiZGVsZXRlZEVkZ2VzIiwiZ2V0SW50ZXJzZWN0aW5nTm9kZXMiLCJub2RlT3JSZWN0IiwicGFydGlhbGx5IiwiaXNSZWN0Iiwibm9kZVJlY3QiLCJoYXNOb2Rlc09wdGlvbiIsImludGVybmFsTm9kZSIsInBvc2l0aW9uQWJzb2x1dGUiLCJjdXJyTm9kZVJlY3QiLCJvdmVybGFwcGluZ0FyZWEiLCJwYXJ0aWFsbHlWaXNpYmxlIiwiaXNOb2RlSW50ZXJzZWN0aW5nIiwiYXJlYSIsInVwZGF0ZU5vZGVEYXRhIiwiZGF0YVVwZGF0ZSIsIm5leHREYXRhIiwiZGF0YSIsInVwZGF0ZUVkZ2VEYXRhIiwiZ2V0SGFuZGxlQ29ubmVjdGlvbnMiLCJub2RlSWQiLCJmcm9tIiwiY29ubmVjdGlvbkxvb2t1cCIsInZhbHVlcyIsImdldE5vZGVDb25uZWN0aW9ucyIsImhhbmRsZUlkIiwiZml0VmlldyIsImZpdFZpZXdSZXNvbHZlciIsInByb21pc2UiLCJ3aW4kMSIsInVzZUdsb2JhbEtleUhhbmRsZXIiLCJkZWxldGVLZXlDb2RlIiwibXVsdGlTZWxlY3Rpb25LZXlDb2RlIiwiZGVsZXRlS2V5UHJlc3NlZCIsIm11bHRpU2VsZWN0aW9uS2V5UHJlc3NlZCIsIm5vZGVzU2VsZWN0aW9uQWN0aXZlIiwibXVsdGlTZWxlY3Rpb25BY3RpdmUiLCJ1c2VSZXNpemVIYW5kbGVyIiwidXBkYXRlRGltZW5zaW9ucyIsImNoZWNrVmlzaWJpbGl0eSIsIm9uRXJyb3IiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsImNvbnRhaW5lclN0eWxlIiwidG9wIiwibGVmdCIsInNlbGVjdG9yJGoiLCJ1c2VyU2VsZWN0aW9uQWN0aXZlIiwibGliIiwiY29ubmVjdGlvbkluUHJvZ3Jlc3MiLCJjb25uZWN0aW9uIiwiaW5Qcm9ncmVzcyIsIlpvb21QYW5lIiwib25QYW5lQ29udGV4dE1lbnUiLCJ6b29tT25TY3JvbGwiLCJ6b29tT25QaW5jaCIsInBhbk9uU2Nyb2xsIiwicGFuT25TY3JvbGxTcGVlZCIsInBhbk9uU2Nyb2xsTW9kZSIsIkZyZWUiLCJ6b29tT25Eb3VibGVDbGljayIsInBhbk9uRHJhZyIsInpvb21BY3RpdmF0aW9uS2V5Q29kZSIsInByZXZlbnRTY3JvbGxpbmciLCJub1doZWVsQ2xhc3NOYW1lIiwib25WaWV3cG9ydENoYW5nZSIsImlzQ29udHJvbGxlZFZpZXdwb3J0Iiwiem9vbVBhbmUiLCJ6b29tQWN0aXZhdGlvbktleVByZXNzZWQiLCJvblRyYW5zZm9ybUNoYW5nZSIsIm9uRHJhZ2dpbmdDaGFuZ2UiLCJwYW5lRHJhZ2dpbmciLCJvblBhblpvb21TdGFydCIsInZwIiwib25WaWV3cG9ydENoYW5nZVN0YXJ0Iiwib25Nb3ZlU3RhcnQiLCJvblBhblpvb20iLCJvbk1vdmUiLCJvblBhblpvb21FbmQiLCJvblZpZXdwb3J0Q2hhbmdlRW5kIiwib25Nb3ZlRW5kIiwiY2xvc2VzdCIsImRlc3Ryb3kiLCJ1cGRhdGUiLCJzZWxlY3RvciRpIiwidXNlclNlbGVjdGlvblJlY3QiLCJVc2VyU2VsZWN0aW9uIiwiaXNBY3RpdmUiLCJ3cmFwSGFuZGxlciIsImhhbmRsZXIiLCJjb250YWluZXJSZWYiLCJzZWxlY3RvciRoIiwiUGFuZSIsImlzU2VsZWN0aW5nIiwic2VsZWN0aW9uS2V5UHJlc3NlZCIsInNlbGVjdGlvbk1vZGUiLCJGdWxsIiwic2VsZWN0aW9uT25EcmFnIiwib25TZWxlY3Rpb25TdGFydCIsIm9uU2VsZWN0aW9uRW5kIiwib25QYW5lQ2xpY2siLCJvblBhbmVTY3JvbGwiLCJvblBhbmVNb3VzZUVudGVyIiwib25QYW5lTW91c2VNb3ZlIiwib25QYW5lTW91c2VMZWF2ZSIsImhhc0FjdGl2ZVNlbGVjdGlvbiIsImNvbnRhaW5lciIsImNvbnRhaW5lckJvdW5kcyIsInNlbGVjdGVkTm9kZUlkcyIsInNlbGVjdGVkRWRnZUlkcyIsInNlbGVjdGlvbkluUHJvZ3Jlc3MiLCJzZWxlY3Rpb25TdGFydGVkIiwib25DbGljayIsInJlc2V0U2VsZWN0ZWRFbGVtZW50cyIsIm9uQ29udGV4dE1lbnUiLCJvbldoZWVsIiwib25Qb2ludGVyRG93biIsImJ1dHRvbiIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwibmF0aXZlRXZlbnQiLCJzdGFydFgiLCJzdGFydFkiLCJvblBvaW50ZXJNb3ZlIiwiZGVmYXVsdEVkZ2VPcHRpb25zIiwibW91c2VYIiwibW91c2VZIiwibmV4dFVzZXJTZWxlY3RSZWN0IiwiTWF0aCIsImFicyIsInByZXZTZWxlY3RlZE5vZGVJZHMiLCJwcmV2U2VsZWN0ZWRFZGdlSWRzIiwiUGFydGlhbCIsImVkZ2VzU2VsZWN0YWJsZSIsInNlbGVjdGFibGUiLCJjb25uZWN0aW9ucyIsImVkZ2VJZCIsIm9uUG9pbnRlclVwIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwiZHJhZ2dhYmxlIiwic2VsZWN0aW9uIiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsImhhbmRsZU5vZGVDbGljayIsInVuc2VsZWN0Iiwibm9kZVJlZiIsImFkZFNlbGVjdGVkTm9kZXMiLCJ1bnNlbGVjdE5vZGVzQW5kRWRnZXMiLCJibHVyIiwidXNlRHJhZyIsImRpc2FibGVkIiwibm9EcmFnQ2xhc3NOYW1lIiwiaGFuZGxlU2VsZWN0b3IiLCJpc1NlbGVjdGFibGUiLCJub2RlQ2xpY2tEaXN0YW5jZSIsInNldERyYWdnaW5nIiwieHlEcmFnIiwiZ2V0U3RvcmVJdGVtcyIsIm9uTm9kZU1vdXNlRG93biIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnU3RvcCIsInNlbGVjdGVkQW5kRHJhZ2dhYmxlIiwibm9kZXNEcmFnZ2FibGUiLCJ1c2VNb3ZlU2VsZWN0ZWROb2RlcyIsIm1vdmVTZWxlY3RlZE5vZGVzIiwibm9kZUV4dGVudCIsInVwZGF0ZU5vZGVQb3NpdGlvbnMiLCJub2RlVXBkYXRlcyIsImlzU2VsZWN0ZWQiLCJ4VmVsbyIsInlWZWxvIiwieERpZmYiLCJkaXJlY3Rpb24iLCJmYWN0b3IiLCJ5RGlmZiIsIm5leHRQb3NpdGlvbiIsIk5vZGVJZENvbnRleHQiLCJDb25zdW1lciIsInVzZU5vZGVJZCIsInNlbGVjdG9yJGciLCJjb25uZWN0T25DbGljayIsImNvbm5lY3RpbmdTZWxlY3RvciIsInN0YXRlIiwiY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUiLCJjbGlja0hhbmRsZSIsImNvbm5lY3Rpb25Nb2RlIiwiZnJvbUhhbmRsZSIsInRvSGFuZGxlIiwiaXNWYWxpZCIsImNvbm5lY3RpbmdUbyIsImNvbm5lY3RpbmdGcm9tIiwiY2xpY2tDb25uZWN0aW5nIiwiaXNQb3NzaWJsZUVuZEhhbmRsZSIsIlN0cmljdCIsImNvbm5lY3Rpb25JblByb2Nlc3MiLCJjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MiLCJ2YWxpZCIsIkhhbmRsZUNvbXBvbmVudCIsIlRvcCIsImlzVmFsaWRDb25uZWN0aW9uIiwiaXNDb25uZWN0YWJsZSIsImlzQ29ubmVjdGFibGVTdGFydCIsImlzQ29ubmVjdGFibGVFbmQiLCJvbkNvbm5lY3QiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hTdGFydCIsImlzVGFyZ2V0Iiwib25Db25uZWN0RXh0ZW5kZWQiLCJvbkNvbm5lY3RBY3Rpb24iLCJlZGdlUGFyYW1zIiwiaXNNb3VzZVRyaWdnZXJlZCIsImN1cnJlbnRTdG9yZSIsImhhbmRsZURvbU5vZGUiLCJjdXJyZW50VGFyZ2V0IiwiYXV0b1Bhbk9uQ29ubmVjdCIsImNvbm5lY3Rpb25SYWRpdXMiLCJmbG93SWQiLCJjYW5jZWxDb25uZWN0aW9uIiwib25Db25uZWN0U3RhcnQiLCJvbkNvbm5lY3RFbmQiLCJ1cGRhdGVDb25uZWN0aW9uIiwiZ2V0VHJhbnNmb3JtIiwiZ2V0RnJvbUhhbmRsZSIsImF1dG9QYW5TcGVlZCIsImRyYWdUaHJlc2hvbGQiLCJjb25uZWN0aW9uRHJhZ1RocmVzaG9sZCIsIm9uQ2xpY2tDb25uZWN0U3RhcnQiLCJvbkNsaWNrQ29ubmVjdEVuZCIsImlzVmFsaWRDb25uZWN0aW9uU3RvcmUiLCJjb25uZWN0aW9uU3RhdGUiLCJoYW5kbGVUeXBlIiwiZG9jIiwiaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyIiwiaGFuZGxlIiwiZnJvbU5vZGVJZCIsImZyb21IYW5kbGVJZCIsImZyb21UeXBlIiwiY29ubmVjdGlvbkNsb25lIiwic3RydWN0dXJlZENsb25lIiwidG9Qb3NpdGlvbiIsInNvdXJjZSIsImNvbm5lY3RhYmxlIiwiY29ubmVjdGFibGVzdGFydCIsImNvbm5lY3RhYmxlZW5kIiwiY2xpY2tjb25uZWN0aW5nIiwiY29ubmVjdGluZ2Zyb20iLCJjb25uZWN0aW5ndG8iLCJjb25uZWN0aW9uaW5kaWNhdG9yIiwiSGFuZGxlIiwiSW5wdXROb2RlIiwic291cmNlUG9zaXRpb24iLCJCb3R0b20iLCJsYWJlbCIsIkRlZmF1bHROb2RlIiwidGFyZ2V0UG9zaXRpb24iLCJHcm91cE5vZGUiLCJPdXRwdXROb2RlIiwiYXJyb3dLZXlEaWZmcyIsIkFycm93VXAiLCJBcnJvd0Rvd24iLCJBcnJvd0xlZnQiLCJBcnJvd1JpZ2h0IiwiYnVpbHRpbk5vZGVUeXBlcyIsImlucHV0IiwiZGVmYXVsdCIsIm91dHB1dCIsImdyb3VwIiwiZ2V0Tm9kZUlubGluZVN0eWxlRGltZW5zaW9ucyIsImhhbmRsZUJvdW5kcyIsImluaXRpYWxXaWR0aCIsImluaXRpYWxIZWlnaHQiLCJzZWxlY3RvciRmIiwidHJhbnNmb3JtU3RyaW5nIiwiTm9kZXNTZWxlY3Rpb24iLCJvblNlbGVjdGlvbkNvbnRleHRNZW51IiwiZm9jdXMiLCJwcmV2ZW50U2Nyb2xsIiwib25LZXlEb3duIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidGFiSW5kZXgiLCJ3aW4iLCJzZWxlY3RvciRlIiwiRmxvd1JlbmRlcmVyQ29tcG9uZW50Iiwic2VsZWN0aW9uS2V5Q29kZSIsInBhbkFjdGl2YXRpb25LZXlDb2RlIiwiX3Bhbk9uU2Nyb2xsIiwiX3Bhbk9uRHJhZyIsInBhbkFjdGl2YXRpb25LZXlQcmVzc2VkIiwiX3NlbGVjdGlvbk9uRHJhZyIsIkZsb3dSZW5kZXJlciIsInNlbGVjdG9yJGQiLCJvbmx5UmVuZGVyVmlzaWJsZSIsInVzZVZpc2libGVOb2RlSWRzIiwibm9kZUlkcyIsInNlbGVjdG9yJGMiLCJ1c2VSZXNpemVPYnNlcnZlciIsInVwZGF0ZXMiLCJlbnRyeSIsImdldEF0dHJpYnV0ZSIsIm5vZGVFbGVtZW50IiwiZm9yY2UiLCJkaXNjb25uZWN0IiwidXNlTm9kZU9ic2VydmVyIiwibm9kZVR5cGUiLCJoYXNEaW1lbnNpb25zIiwib2JzZXJ2ZWROb2RlIiwicHJldlNvdXJjZVBvc2l0aW9uIiwicHJldlRhcmdldFBvc2l0aW9uIiwicHJldlR5cGUiLCJpc0luaXRpYWxpemVkIiwiaGlkZGVuIiwidHlwZUNoYW5nZWQiLCJzb3VyY2VQb3NDaGFuZ2VkIiwidGFyZ2V0UG9zQ2hhbmdlZCIsIk5vZGVXcmFwcGVyIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlTGVhdmUiLCJvbkRvdWJsZUNsaWNrIiwibm9kZXNDb25uZWN0YWJsZSIsIm5vZGVzRm9jdXNhYmxlIiwibm9kZVR5cGVzIiwiaXNQYXJlbnQiLCJwYXJlbnRMb29rdXAiLCJOb2RlQ29tcG9uZW50IiwiaXNEcmFnZ2FibGUiLCJpc0ZvY3VzYWJsZSIsImZvY3VzYWJsZSIsImRyYWdIYW5kbGUiLCJub2RlRGltZW5zaW9ucyIsImlubGluZURpbWVuc2lvbnMiLCJoYXNQb2ludGVyRXZlbnRzIiwib25Nb3VzZUVudGVySGFuZGxlciIsIm9uTW91c2VNb3ZlSGFuZGxlciIsIm9uTW91c2VMZWF2ZUhhbmRsZXIiLCJvbkNvbnRleHRNZW51SGFuZGxlciIsIm9uRG91YmxlQ2xpY2tIYW5kbGVyIiwib25TZWxlY3ROb2RlSGFuZGxlciIsInNlbGVjdE5vZGVzT25EcmFnIiwibm9kZURyYWdUaHJlc2hvbGQiLCJ0b0xvd2VyQ2FzZSIsIm9uRm9jdXMiLCJhdXRvUGFuT25Ob2RlRm9jdXMiLCJ3aXRoaW5WaWV3cG9ydCIsInBhcmVudCIsInpJbmRleCIsInoiLCJwb2ludGVyRXZlbnRzIiwidmlzaWJpbGl0eSIsInJvbGUiLCJhcmlhUm9sZSIsImFyaWFMYWJlbCIsImRvbUF0dHJpYnV0ZXMiLCJwb3NpdGlvbkFic29sdXRlWCIsInBvc2l0aW9uQWJzb2x1dGVZIiwiZGVsZXRhYmxlIiwic2VsZWN0b3IkYiIsIk5vZGVSZW5kZXJlckNvbXBvbmVudCIsIm9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMiLCJvbk5vZGVDbGljayIsIm9uTm9kZU1vdXNlRW50ZXIiLCJvbk5vZGVNb3VzZU1vdmUiLCJvbk5vZGVNb3VzZUxlYXZlIiwib25Ob2RlQ29udGV4dE1lbnUiLCJvbk5vZGVEb3VibGVDbGljayIsIk5vZGVSZW5kZXJlciIsInVzZVZpc2libGVFZGdlSWRzIiwiZWRnZUlkcyIsInZpc2libGVFZGdlSWRzIiwic291cmNlTm9kZSIsInRhcmdldE5vZGUiLCJBcnJvd1N5bWJvbCIsImNvbG9yIiwic3Ryb2tlV2lkdGgiLCJzdHJva2UiLCJzdHJva2VMaW5lY2FwIiwiZmlsbCIsInN0cm9rZUxpbmVqb2luIiwicG9pbnRzIiwiQXJyb3dDbG9zZWRTeW1ib2wiLCJNYXJrZXJTeW1ib2xzIiwiQXJyb3ciLCJBcnJvd0Nsb3NlZCIsInVzZU1hcmtlclN5bWJvbCIsInN5bWJvbCIsInN5bWJvbEV4aXN0cyIsIk1hcmtlciIsIm1hcmtlclVuaXRzIiwib3JpZW50IiwiU3ltYm9sIiwibWFya2VyV2lkdGgiLCJtYXJrZXJIZWlnaHQiLCJ2aWV3Qm94IiwicmVmWCIsInJlZlkiLCJNYXJrZXJEZWZpbml0aW9ucyIsImRlZmF1bHRDb2xvciIsIm1hcmtlcnMiLCJkZWZhdWx0TWFya2VyU3RhcnQiLCJtYXJrZXJTdGFydCIsImRlZmF1bHRNYXJrZXJFbmQiLCJtYXJrZXJFbmQiLCJtYXJrZXIiLCJNYXJrZXJEZWZpbml0aW9ucyQxIiwiRWRnZVRleHRDb21wb25lbnQiLCJsYWJlbFN0eWxlIiwibGFiZWxTaG93QmciLCJsYWJlbEJnU3R5bGUiLCJsYWJlbEJnUGFkZGluZyIsImxhYmVsQmdCb3JkZXJSYWRpdXMiLCJlZGdlVGV4dEJib3giLCJzZXRFZGdlVGV4dEJib3giLCJlZGdlVGV4dENsYXNzZXMiLCJlZGdlVGV4dFJlZiIsInRleHRCYm94IiwiZ2V0QkJveCIsInJ4IiwicnkiLCJkeSIsIkVkZ2VUZXh0IiwiQmFzZUVkZ2UiLCJwYXRoIiwibGFiZWxYIiwibGFiZWxZIiwiaW50ZXJhY3Rpb25XaWR0aCIsImQiLCJzdHJva2VPcGFjaXR5IiwiZ2V0Q29udHJvbCIsInBvcyIsIngxIiwieTEiLCJ4MiIsInkyIiwiTGVmdCIsIlJpZ2h0IiwiZ2V0U2ltcGxlQmV6aWVyUGF0aCIsInNvdXJjZVgiLCJzb3VyY2VZIiwidGFyZ2V0WCIsInRhcmdldFkiLCJzb3VyY2VDb250cm9sWCIsInNvdXJjZUNvbnRyb2xZIiwidGFyZ2V0Q29udHJvbFgiLCJ0YXJnZXRDb250cm9sWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwiY3JlYXRlU2ltcGxlQmV6aWVyRWRnZSIsIl9pZCIsImlzSW50ZXJuYWwiLCJTaW1wbGVCZXppZXJFZGdlIiwiU2ltcGxlQmV6aWVyRWRnZUludGVybmFsIiwiY3JlYXRlU21vb3RoU3RlcEVkZ2UiLCJwYXRoT3B0aW9ucyIsImJvcmRlclJhZGl1cyIsIm9mZnNldCIsInN0ZXBQb3NpdGlvbiIsIlNtb290aFN0ZXBFZGdlIiwiU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCIsImNyZWF0ZVN0ZXBFZGdlIiwiU3RlcEVkZ2UiLCJTdGVwRWRnZUludGVybmFsIiwiY3JlYXRlU3RyYWlnaHRFZGdlIiwiU3RyYWlnaHRFZGdlIiwiU3RyYWlnaHRFZGdlSW50ZXJuYWwiLCJjcmVhdGVCZXppZXJFZGdlIiwiY3VydmF0dXJlIiwiQmV6aWVyRWRnZSIsIkJlemllckVkZ2VJbnRlcm5hbCIsImJ1aWx0aW5FZGdlVHlwZXMiLCJzdHJhaWdodCIsInN0ZXAiLCJzbW9vdGhzdGVwIiwic2ltcGxlYmV6aWVyIiwibnVsbFBvc2l0aW9uIiwic2hpZnRYIiwic2hpZnQiLCJzaGlmdFkiLCJFZGdlVXBkYXRlckNsYXNzTmFtZSIsIkVkZ2VBbmNob3IiLCJjZW50ZXJYIiwiY2VudGVyWSIsInJhZGl1cyIsIm9uTW91c2VPdXQiLCJjeCIsImN5IiwiciIsIkVkZ2VVcGRhdGVBbmNob3JzIiwiaXNSZWNvbm5lY3RhYmxlIiwicmVjb25uZWN0UmFkaXVzIiwib25SZWNvbm5lY3QiLCJvblJlY29ubmVjdFN0YXJ0Iiwib25SZWNvbm5lY3RFbmQiLCJzZXRSZWNvbm5lY3RpbmciLCJzZXRVcGRhdGVIb3ZlciIsImhhbmRsZUVkZ2VVcGRhdGVyIiwib3Bwb3NpdGVIYW5kbGUiLCJfb25SZWNvbm5lY3RFbmQiLCJldnQiLCJvbkNvbm5lY3RFZGdlIiwiX29uQ29ubmVjdFN0YXJ0IiwiX2V2ZW50IiwiZWRnZVVwZGF0ZXJUeXBlIiwib25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24iLCJ0YXJnZXRIYW5kbGUiLCJvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biIsInNvdXJjZUhhbmRsZSIsIm9uUmVjb25uZWN0TW91c2VFbnRlciIsIm9uUmVjb25uZWN0TW91c2VPdXQiLCJFZGdlV3JhcHBlciIsImVkZ2VzRm9jdXNhYmxlIiwiZWRnZXNSZWNvbm5lY3RhYmxlIiwiZWRnZVR5cGVzIiwiZWRnZVR5cGUiLCJFZGdlQ29tcG9uZW50IiwicmVjb25uZWN0YWJsZSIsImVkZ2VSZWYiLCJ1cGRhdGVIb3ZlciIsInJlY29ubmVjdGluZyIsImVkZ2VQb3NpdGlvbiIsImVsZXZhdGVPblNlbGVjdCIsImVsZXZhdGVFZGdlc09uU2VsZWN0IiwibWFya2VyU3RhcnRVcmwiLCJtYXJrZXJFbmRVcmwiLCJvbkVkZ2VDbGljayIsImFkZFNlbGVjdGVkRWRnZXMiLCJvbkVkZ2VEb3VibGVDbGljayIsIm9uRWRnZUNvbnRleHRNZW51Iiwib25FZGdlTW91c2VFbnRlciIsIm9uRWRnZU1vdXNlTW92ZSIsIm9uRWRnZU1vdXNlTGVhdmUiLCJhbmltYXRlZCIsImluYWN0aXZlIiwidXBkYXRpbmciLCJzb3VyY2VIYW5kbGVJZCIsInRhcmdldEhhbmRsZUlkIiwic2VsZWN0b3IkYSIsIkVkZ2VSZW5kZXJlckNvbXBvbmVudCIsImRlZmF1bHRNYXJrZXJDb2xvciIsIkVkZ2VSZW5kZXJlciIsInNlbGVjdG9yJDkiLCJWaWV3cG9ydCIsInVzZU9uSW5pdEhhbmRsZXIiLCJvbkluaXQiLCJyZkluc3RhbmNlIiwic2V0VGltZW91dCIsInNlbGVjdG9yJDgiLCJzeW5jVmlld3BvcnQiLCJ1c2VWaWV3cG9ydFN5bmMiLCJzdG9yZVNlbGVjdG9yJDEiLCJ0byIsImdldFNlbGVjdG9yIiwiY29ubmVjdGlvblNlbGVjdG9yIiwiY29tYmluZWRTZWxlY3RvciIsInVzZUNvbm5lY3Rpb24iLCJzZWxlY3RvciQ3IiwiQ29ubmVjdGlvbkxpbmVXcmFwcGVyIiwiY29tcG9uZW50IiwicmVuZGVyQ29ubmVjdGlvbiIsIkNvbm5lY3Rpb25MaW5lIiwiQ3VzdG9tQ29tcG9uZW50IiwiQmV6aWVyIiwiZnJvbU5vZGUiLCJmcm9tUG9zaXRpb24iLCJ0b05vZGUiLCJjb25uZWN0aW9uTGluZVR5cGUiLCJjb25uZWN0aW9uTGluZVN0eWxlIiwiZnJvbVgiLCJmcm9tWSIsInRvWCIsInRvWSIsImNvbm5lY3Rpb25TdGF0dXMiLCJwYXRoUGFyYW1zIiwiU2ltcGxlQmV6aWVyIiwiU3RlcCIsIlNtb290aFN0ZXAiLCJlbXB0eVR5cGVzIiwidXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyIsIm5vZGVPckVkZ2VUeXBlcyIsInR5cGVzUmVmIiwicHJvY2VzcyIsInVzZWRLZXlzIiwidXNlU3R5bGVzTG9hZGVkV2FybmluZyIsImNoZWNrZWQiLCJwYW5lIiwicXVlcnlTZWxlY3RvciIsImdldENvbXB1dGVkU3R5bGUiLCJHcmFwaFZpZXdDb21wb25lbnQiLCJjb25uZWN0aW9uTGluZUNvbXBvbmVudCIsImNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUiLCJHcmFwaFZpZXciLCJnZXRJbml0aWFsU3RhdGUiLCJzdG9yZUVkZ2VzIiwic3RvcmVOb2RlcyIsInN0b3JlTm9kZU9yaWdpbiIsInN0b3JlTm9kZUV4dGVudCIsIm5vZGVzSW5pdGlhbGl6ZWQiLCJlbGV2YXRlTm9kZXNPblNlbGVjdCIsImF1dG9QYW5Pbk5vZGVEcmFnIiwiZGVidWciLCJjcmVhdGVTdG9yZSIsInJlc29sdmVGaXRWaWV3IiwiY2hlY2tFcXVhbGl0eSIsInVwZGF0ZWRJbnRlcm5hbHMiLCJjb25zb2xlIiwibG9nIiwibm9kZURyYWdJdGVtcyIsInBhcmVudEV4cGFuZENoaWxkcmVuIiwiZHJhZ0l0ZW0iLCJleHBhbmRQYXJlbnQiLCJtYXgiLCJyZWN0IiwicGFyZW50RXhwYW5kQ2hhbmdlcyIsInVwZGF0ZWROb2RlcyIsInVwZGF0ZWRFZGdlcyIsImNoYW5nZWRFZGdlcyIsIm5vZGVzVG9VbnNlbGVjdCIsImVkZ2VzVG9VbnNlbGVjdCIsInNldFNjYWxlRXh0ZW50IiwiY2xpY2tEaXN0YW5jZSIsInNldENsaWNrRGlzdGFuY2UiLCJuZXh0Tm9kZUV4dGVudCIsImRlbHRhIiwibmV4dFpvb20iLCJpcyIsIlJlYWN0Rmxvd1Byb3ZpZGVyIiwiaW5pdGlhbE5vZGVzIiwiaW5pdGlhbEVkZ2VzIiwiaW5pdGlhbE1pblpvb20iLCJpbml0aWFsTWF4Wm9vbSIsImluaXRpYWxGaXRWaWV3T3B0aW9ucyIsIldyYXBwZXIiLCJpc1dyYXBwZWQiLCJ3cmFwcGVyU3R5bGUiLCJSZWFjdEZsb3ciLCJvbk5vZGVEcmFnU3RhcnQiLCJvbk5vZGVEcmFnIiwib25Ob2RlRHJhZ1N0b3AiLCJvblNlbGVjdGlvbkRyYWdTdGFydCIsIm9uU2VsZWN0aW9uRHJhZyIsIm9uU2VsZWN0aW9uRHJhZ1N0b3AiLCJkZWZhdWx0Vmlld3BvcnQkMSIsImF0dHJpYnV0aW9uUG9zaXRpb24iLCJvblNjcm9sbCIsImNvbG9yTW9kZUNsYXNzTmFtZSIsIndyYXBwZXJPblNjcm9sbCIsInNjcm9sbFRvIiwiYmVoYXZpb3IiLCJzZWxlY3RvciQ2IiwiRWRnZUxhYmVsUmVuZGVyZXIiLCJlZGdlTGFiZWxSZW5kZXJlciIsInNlbGVjdG9yJDUiLCJWaWV3cG9ydFBvcnRhbCIsInZpZXdQb3J0YWxEaXYiLCJ1c2VVcGRhdGVOb2RlSW50ZXJuYWxzIiwidXBkYXRlSWRzIiwidXBkYXRlSWQiLCJ0cmlnZ2VyRml0VmlldyIsIm5vZGVzU2VsZWN0b3IiLCJ1c2VOb2RlcyIsImVkZ2VzU2VsZWN0b3IiLCJ1c2VFZGdlcyIsInZpZXdwb3J0U2VsZWN0b3IiLCJ1c2VWaWV3cG9ydCIsInVzZU5vZGVzU3RhdGUiLCJuZHMiLCJ1c2VFZGdlc1N0YXRlIiwiZWRzIiwidXNlT25WaWV3cG9ydENoYW5nZSIsIm9uU3RhcnQiLCJvbkNoYW5nZSIsIm9uRW5kIiwidXNlT25TZWxlY3Rpb25DaGFuZ2UiLCJuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyIsIm5leHRIYW5kbGVycyIsInNlbGVjdG9yJDQiLCJpbmNsdWRlSGlkZGVuTm9kZXMiLCJ1c2VOb2Rlc0luaXRpYWxpemVkIiwiaW5pdGlhbGl6ZWQiLCJ1c2VIYW5kbGVDb25uZWN0aW9ucyIsIm9uRGlzY29ubmVjdCIsIndhcm4iLCJfbm9kZUlkIiwiY3VycmVudE5vZGVJZCIsInByZXZDb25uZWN0aW9ucyIsIl9jb25uZWN0aW9ucyIsImVycm9yMDE0IiwidXNlTm9kZUNvbm5lY3Rpb25zIiwidXNlTm9kZXNEYXRhIiwibm9kZXNEYXRhIiwiaXNBcnJheU9mSWRzIiwiX25vZGVJZHMiLCJ1c2VJbnRlcm5hbE5vZGUiLCJMaW5lUGF0dGVybiIsImxpbmVXaWR0aCIsInZhcmlhbnQiLCJEb3RQYXR0ZXJuIiwiQmFja2dyb3VuZFZhcmlhbnQiLCJkZWZhdWx0U2l6ZSIsIkRvdHMiLCJMaW5lcyIsIkNyb3NzIiwic2VsZWN0b3IkMyIsInBhdHRlcm5JZCIsIkJhY2tncm91bmRDb21wb25lbnQiLCJnYXAiLCJiZ0NvbG9yIiwicGF0dGVybkNsYXNzTmFtZSIsInBhdHRlcm5TaXplIiwiaXNEb3RzIiwiaXNDcm9zcyIsImdhcFhZIiwic2NhbGVkR2FwIiwic2NhbGVkU2l6ZSIsIm9mZnNldFhZIiwicGF0dGVybkRpbWVuc2lvbnMiLCJzY2FsZWRPZmZzZXQiLCJfcGF0dGVybklkIiwicGF0dGVyblVuaXRzIiwicGF0dGVyblRyYW5zZm9ybSIsIkJhY2tncm91bmQiLCJQbHVzSWNvbiIsInhtbG5zIiwiTWludXNJY29uIiwiRml0Vmlld0ljb24iLCJMb2NrSWNvbiIsIlVubG9ja0ljb24iLCJDb250cm9sQnV0dG9uIiwic2VsZWN0b3IkMiIsImlzSW50ZXJhY3RpdmUiLCJtaW5ab29tUmVhY2hlZCIsIm1heFpvb21SZWFjaGVkIiwiQ29udHJvbHNDb21wb25lbnQiLCJzaG93Wm9vbSIsInNob3dGaXRWaWV3Iiwic2hvd0ludGVyYWN0aXZlIiwib25ab29tSW4iLCJvblpvb21PdXQiLCJvbkZpdFZpZXciLCJvbkludGVyYWN0aXZlQ2hhbmdlIiwib3JpZW50YXRpb24iLCJvblpvb21JbkhhbmRsZXIiLCJvblpvb21PdXRIYW5kbGVyIiwib25GaXRWaWV3SGFuZGxlciIsIm9uVG9nZ2xlSW50ZXJhY3Rpdml0eSIsIm9yaWVudGF0aW9uQ2xhc3MiLCJ0aXRsZSIsIkNvbnRyb2xzIiwiTWluaU1hcE5vZGVDb21wb25lbnQiLCJzdHJva2VDb2xvciIsInNoYXBlUmVuZGVyaW5nIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRDb2xvciIsIk1pbmlNYXBOb2RlIiwic2VsZWN0b3JOb2RlSWRzIiwiZ2V0QXR0ckZ1bmN0aW9uIiwiZnVuYyIsIkZ1bmN0aW9uIiwiTWluaU1hcE5vZGVzIiwibm9kZVN0cm9rZUNvbG9yIiwibm9kZUNvbG9yIiwibm9kZUNsYXNzTmFtZSIsIm5vZGVCb3JkZXJSYWRpdXMiLCJub2RlU3Ryb2tlV2lkdGgiLCJub2RlQ29tcG9uZW50Iiwibm9kZUNvbG9yRnVuYyIsIm5vZGVTdHJva2VDb2xvckZ1bmMiLCJub2RlQ2xhc3NOYW1lRnVuYyIsImNocm9tZSIsIk5vZGVDb21wb25lbnRXcmFwcGVyIiwiTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lciIsIk1pbmlNYXBOb2RlcyQxIiwiZGVmYXVsdFdpZHRoIiwiZGVmYXVsdEhlaWdodCIsImZpbHRlckhpZGRlbiIsInNlbGVjdG9yJDEiLCJ2aWV3QkIiLCJib3VuZGluZ1JlY3QiLCJmbG93V2lkdGgiLCJmbG93SGVpZ2h0IiwiQVJJQV9MQUJFTF9LRVkiLCJNaW5pTWFwQ29tcG9uZW50IiwibWFza0NvbG9yIiwibWFza1N0cm9rZUNvbG9yIiwibWFza1N0cm9rZVdpZHRoIiwicGFubmFibGUiLCJ6b29tYWJsZSIsImludmVyc2VQYW4iLCJ6b29tU3RlcCIsIm9mZnNldFNjYWxlIiwic3ZnIiwiZWxlbWVudFdpZHRoIiwiZWxlbWVudEhlaWdodCIsInNjYWxlZFdpZHRoIiwic2NhbGVkSGVpZ2h0Iiwidmlld1NjYWxlIiwidmlld1dpZHRoIiwidmlld0hlaWdodCIsImxhYmVsbGVkQnkiLCJ2aWV3U2NhbGVSZWYiLCJtaW5pbWFwSW5zdGFuY2UiLCJnZXRWaWV3U2NhbGUiLCJvblN2Z0NsaWNrIiwicG9pbnRlciIsIm9uU3ZnTm9kZUNsaWNrIiwiX2FyaWFMYWJlbCIsImZpbGxSdWxlIiwiTWluaU1hcCIsInNjYWxlU2VsZWN0b3IiLCJjYWxjdWxhdGVTY2FsZSIsImRlZmF1bHRQb3NpdGlvbnMiLCJMaW5lIiwiUmVzaXplQ29udHJvbCIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwibWF4V2lkdGgiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJtYXhIZWlnaHQiLCJrZWVwQXNwZWN0UmF0aW8iLCJyZXNpemVEaXJlY3Rpb24iLCJhdXRvU2NhbGUiLCJzaG91bGRSZXNpemUiLCJvblJlc2l6ZVN0YXJ0Iiwib25SZXNpemUiLCJvblJlc2l6ZUVuZCIsImNvbnRleHROb2RlSWQiLCJyZXNpemVDb250cm9sUmVmIiwiaXNIYW5kbGVDb250cm9sIiwic2NhbGUiLCJyZXNpemVyIiwiY29udHJvbFBvc2l0aW9uIiwicGFuZURvbU5vZGUiLCJjaGlsZENoYW5nZXMiLCJvcmlnaW4iLCJjaGlsZCIsInBvc2l0aW9uQ2hhbmdlIiwiZGltZW5zaW9uQ2hhbmdlIiwiY2hpbGRDaGFuZ2UiLCJib3VuZGFyaWVzIiwicG9zaXRpb25DbGFzc05hbWVzIiwiTm9kZVJlc2l6ZUNvbnRyb2wiLCJOb2RlUmVzaXplciIsImlzVmlzaWJsZSIsImhhbmRsZUNsYXNzTmFtZSIsImhhbmRsZVN0eWxlIiwibGluZUNsYXNzTmFtZSIsImxpbmVTdHlsZSIsIk5vZGVUb29sYmFyUG9ydGFsIiwid3JhcHBlclJlZiIsIm5vZGVFcXVhbGl0eUZuIiwibm9kZXNFcXVhbGl0eUZuIiwic3RvcmVTZWxlY3RvciIsInNlbGVjdGVkTm9kZXNDb3VudCIsIk5vZGVUb29sYmFyIiwiYWxpZ24iLCJpbnRlcm5hbE5vZGVzIiwibm9kZXNBcnJheSIsImFjYyIsInRyaW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/system/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xyflow/system/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ResizeControlVariant: () => (/* binding */ ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   XYDrag: () => (/* binding */ XYDrag),\n/* harmony export */   XYHandle: () => (/* binding */ XYHandle),\n/* harmony export */   XYMinimap: () => (/* binding */ XYMinimap),\n/* harmony export */   XYPanZoom: () => (/* binding */ XYPanZoom),\n/* harmony export */   XYResizer: () => (/* binding */ XYResizer),\n/* harmony export */   XY_RESIZER_HANDLE_POSITIONS: () => (/* binding */ XY_RESIZER_HANDLE_POSITIONS),\n/* harmony export */   XY_RESIZER_LINE_POSITIONS: () => (/* binding */ XY_RESIZER_LINE_POSITIONS),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   adoptUserNodes: () => (/* binding */ adoptUserNodes),\n/* harmony export */   areConnectionMapsEqual: () => (/* binding */ areConnectionMapsEqual),\n/* harmony export */   areSetsEqual: () => (/* binding */ areSetsEqual),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   calcAutoPan: () => (/* binding */ calcAutoPan),\n/* harmony export */   calculateNodePosition: () => (/* binding */ calculateNodePosition),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   clampPosition: () => (/* binding */ clampPosition),\n/* harmony export */   clampPositionToParent: () => (/* binding */ clampPositionToParent),\n/* harmony export */   createMarkerIds: () => (/* binding */ createMarkerIds),\n/* harmony export */   defaultAriaLabelConfig: () => (/* binding */ defaultAriaLabelConfig),\n/* harmony export */   devWarn: () => (/* binding */ devWarn),\n/* harmony export */   elementSelectionKeys: () => (/* binding */ elementSelectionKeys),\n/* harmony export */   errorMessages: () => (/* binding */ errorMessages),\n/* harmony export */   evaluateAbsolutePosition: () => (/* binding */ evaluateAbsolutePosition),\n/* harmony export */   fitViewport: () => (/* binding */ fitViewport),\n/* harmony export */   getBezierEdgeCenter: () => (/* binding */ getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfBoxes: () => (/* binding */ getBoundsOfBoxes),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getDimensions: () => (/* binding */ getDimensions),\n/* harmony export */   getEdgeCenter: () => (/* binding */ getEdgeCenter),\n/* harmony export */   getEdgePosition: () => (/* binding */ getEdgePosition),\n/* harmony export */   getElementsToRemove: () => (/* binding */ getElementsToRemove),\n/* harmony export */   getElevatedEdgeZIndex: () => (/* binding */ getElevatedEdgeZIndex),\n/* harmony export */   getEventPosition: () => (/* binding */ getEventPosition),\n/* harmony export */   getHandleBounds: () => (/* binding */ getHandleBounds),\n/* harmony export */   getHandlePosition: () => (/* binding */ getHandlePosition),\n/* harmony export */   getHostForElement: () => (/* binding */ getHostForElement),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getInternalNodesBounds: () => (/* binding */ getInternalNodesBounds),\n/* harmony export */   getMarkerId: () => (/* binding */ getMarkerId),\n/* harmony export */   getNodeDimensions: () => (/* binding */ getNodeDimensions),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getNodeToolbarTransform: () => (/* binding */ getNodeToolbarTransform),\n/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),\n/* harmony export */   getNodesInside: () => (/* binding */ getNodesInside),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getOverlappingArea: () => (/* binding */ getOverlappingArea),\n/* harmony export */   getPointerPosition: () => (/* binding */ getPointerPosition),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),\n/* harmony export */   handleConnectionChange: () => (/* binding */ handleConnectionChange),\n/* harmony export */   handleExpandParent: () => (/* binding */ handleExpandParent),\n/* harmony export */   infiniteExtent: () => (/* binding */ infiniteExtent),\n/* harmony export */   initialConnection: () => (/* binding */ initialConnection),\n/* harmony export */   isCoordinateExtent: () => (/* binding */ isCoordinateExtent),\n/* harmony export */   isEdgeBase: () => (/* binding */ isEdgeBase),\n/* harmony export */   isEdgeVisible: () => (/* binding */ isEdgeVisible),\n/* harmony export */   isInputDOMNode: () => (/* binding */ isInputDOMNode),\n/* harmony export */   isInternalNodeBase: () => (/* binding */ isInternalNodeBase),\n/* harmony export */   isMacOs: () => (/* binding */ isMacOs),\n/* harmony export */   isMouseEvent: () => (/* binding */ isMouseEvent),\n/* harmony export */   isNodeBase: () => (/* binding */ isNodeBase),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   isRectObject: () => (/* binding */ isRectObject),\n/* harmony export */   mergeAriaLabelConfig: () => (/* binding */ mergeAriaLabelConfig),\n/* harmony export */   nodeHasDimensions: () => (/* binding */ nodeHasDimensions),\n/* harmony export */   nodeToBox: () => (/* binding */ nodeToBox),\n/* harmony export */   nodeToRect: () => (/* binding */ nodeToRect),\n/* harmony export */   oppositePosition: () => (/* binding */ oppositePosition),\n/* harmony export */   panBy: () => (/* binding */ panBy),\n/* harmony export */   pointToRendererPoint: () => (/* binding */ pointToRendererPoint),\n/* harmony export */   reconnectEdge: () => (/* binding */ reconnectEdge),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   rendererPointToPoint: () => (/* binding */ rendererPointToPoint),\n/* harmony export */   shallowNodeData: () => (/* binding */ shallowNodeData),\n/* harmony export */   snapPosition: () => (/* binding */ snapPosition),\n/* harmony export */   updateAbsolutePositions: () => (/* binding */ updateAbsolutePositions),\n/* harmony export */   updateConnectionLookup: () => (/* binding */ updateConnectionLookup),\n/* harmony export */   updateNodeInternals: () => (/* binding */ updateNodeInternals),\n/* harmony export */   withResolvers: () => (/* binding */ withResolvers)\n/* harmony export */ });\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-interpolate */ \"(ssr)/./node_modules/d3-interpolate/src/value.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ \"(ssr)/./node_modules/d3-interpolate/src/zoom.js\");\n\n\n\n\n\nconst errorMessages = {\n    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',\n    error002: () => \"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType) => `Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',\n    error005: () => 'Only child nodes can use a parent extent.',\n    error006: () => \"Can't create edge. An edge needs a source and a target.\",\n    error007: (id) => `The old edge with id=${id} does not exist.`,\n    error009: (type) => `Marker type \"${type}\" doesn't exist.`,\n    error008: (handleType, { id, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: \"${handleType === 'source' ? sourceHandle : targetHandle}\", edge id: ${id}.`,\n    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',\n    error011: (edgeType) => `Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id) => `Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n    error013: (lib = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,\n    error014: () => 'useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.',\n    error015: () => 'It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs.',\n};\nconst infiniteExtent = [\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n];\nconst elementSelectionKeys = ['Enter', ' ', 'Escape'];\nconst defaultAriaLabelConfig = {\n    'node.a11yDescription.default': 'Press enter or space to select a node. Press delete to remove it and escape to cancel.',\n    'node.a11yDescription.keyboardDisabled': 'Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.',\n    'node.a11yDescription.ariaLiveMessage': ({ direction, x, y }) => `Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,\n    'edge.a11yDescription.default': 'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.',\n    // Control elements\n    'controls.ariaLabel': 'Control Panel',\n    'controls.zoomIn.ariaLabel': 'Zoom In',\n    'controls.zoomOut.ariaLabel': 'Zoom Out',\n    'controls.fitView.ariaLabel': 'Fit View',\n    'controls.interactive.ariaLabel': 'Toggle Interactivity',\n    // Mini map\n    'minimap.ariaLabel': 'Mini Map',\n    // Handle\n    'handle.ariaLabel': 'Handle',\n};\n\n/**\n * The `ConnectionMode` is used to set the mode of connection between nodes.\n * The `Strict` mode is the default one and only allows source to target edges.\n * `Loose` mode allows source to source and target to target edges as well.\n *\n * @public\n */\nvar ConnectionMode;\n(function (ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\n/**\n * This enum is used to set the different modes of panning the viewport when the\n * user scrolls. The `Free` mode allows the user to pan in any direction by scrolling\n * with a device like a trackpad. The `Vertical` and `Horizontal` modes restrict\n * scroll panning to only the vertical or horizontal axis, respectively.\n *\n * @public\n */\nvar PanOnScrollMode;\n(function (PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function (SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nconst initialConnection = {\n    inProgress: false,\n    isValid: null,\n    from: null,\n    fromHandle: null,\n    fromPosition: null,\n    fromNode: null,\n    to: null,\n    toHandle: null,\n    toPosition: null,\n    toNode: null,\n};\n\n/**\n * If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)\n *component, it will dictate the style of connection line rendered when creating\n *new edges.\n *\n * @public\n *\n * @remarks If you choose to render a custom connection line component, this value will be\n *passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).\n */\nvar ConnectionLineType;\n(function (ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\n/**\n * Edges may optionally have a marker on either end. The MarkerType type enumerates\n * the options available to you when configuring a given marker.\n *\n * @public\n */\nvar MarkerType;\n(function (MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n\n/**\n * While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a\n * component in the corners of a container, the `Position` enum is less precise and used\n * primarily in relation to edges and handles.\n *\n * @public\n */\nvar Position;\n(function (Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top,\n};\n\n/**\n * @internal\n */\nfunction areConnectionMapsEqual(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b || a.size !== b.size) {\n        return false;\n    }\n    if (!a.size && !b.size) {\n        return true;\n    }\n    for (const key of a.keys()) {\n        if (!b.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * We call the callback for all connections in a that are not in b\n *\n * @internal\n */\nfunction handleConnectionChange(a, b, cb) {\n    if (!cb) {\n        return;\n    }\n    const diff = [];\n    a.forEach((connection, key) => {\n        if (!b?.has(key)) {\n            diff.push(connection);\n        }\n    });\n    if (diff.length) {\n        cb(diff);\n    }\n}\nfunction getConnectionStatus(isValid) {\n    return isValid === null ? null : isValid ? 'valid' : 'invalid';\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Test whether an object is usable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */\nconst isEdgeBase = (element) => 'id' in element && 'source' in element && 'target' in element;\n/**\n * Test whether an object is usable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */\nconst isNodeBase = (element) => 'id' in element && 'position' in element && !('source' in element) && !('target' in element);\nconst isInternalNodeBase = (element) => 'id' in element && 'internals' in element && !('source' in element) && !('target' in element);\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _target_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the source is the given node.\n *\n * @example\n * ```ts\n *import { getOutgoers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const outgoers = getOutgoers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getOutgoers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const outgoerIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.source === node.id) {\n            outgoerIds.add(edge.target);\n        }\n    });\n    return nodes.filter((n) => outgoerIds.has(n.id));\n};\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _source_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the target is the given node.\n *\n * @example\n * ```ts\n *import { getIncomers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const incomers = getIncomers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getIncomers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const incomersIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.target === node.id) {\n            incomersIds.add(edge.source);\n        }\n    });\n    return nodes.filter((n) => incomersIds.has(n.id));\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {\n    const { width, height } = getNodeDimensions(node);\n    const origin = node.origin ?? nodeOrigin;\n    const offsetX = width * origin[0];\n    const offsetY = height * origin[1];\n    return {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY,\n    };\n};\n/**\n * Returns the bounding box that contains all the given nodes in an array. This can\n * be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)\n * to calculate the correct transform to fit the given nodes in a viewport.\n * @public\n * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.\n * @param nodes - Nodes to calculate the bounds for.\n * @returns Bounding box enclosing all nodes.\n *\n * @remarks This function was previously called `getRectOfNodes`\n *\n * @example\n * ```js\n *import { getNodesBounds } from '@xyflow/react';\n *\n *const nodes = [\n *  {\n *    id: 'a',\n *    position: { x: 0, y: 0 },\n *    data: { label: 'a' },\n *    width: 50,\n *    height: 25,\n *  },\n *  {\n *    id: 'b',\n *    position: { x: 100, y: 100 },\n *    data: { label: 'b' },\n *    width: 50,\n *    height: 25,\n *  },\n *];\n *\n *const bounds = getNodesBounds(nodes);\n *```\n */\nconst getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {\n    if ( true && !params.nodeLookup) {\n        console.warn('Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.');\n    }\n    if (nodes.length === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    const box = nodes.reduce((currBox, nodeOrId) => {\n        const isId = typeof nodeOrId === 'string';\n        let currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;\n        if (params.nodeLookup) {\n            currentNode = isId\n                ? params.nodeLookup.get(nodeOrId)\n                : !isInternalNodeBase(nodeOrId)\n                    ? params.nodeLookup.get(nodeOrId.id)\n                    : nodeOrId;\n        }\n        const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };\n        return getBoundsOfBoxes(currBox, nodeBox);\n    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });\n    return boxToRect(box);\n};\n/**\n * Determines a bounding box that contains all given nodes in an array\n * @internal\n */\nconst getInternalNodesBounds = (nodeLookup, params = {}) => {\n    if (nodeLookup.size === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };\n    nodeLookup.forEach((node) => {\n        if (params.filter === undefined || params.filter(node)) {\n            const nodeBox = nodeToBox(node);\n            box = getBoundsOfBoxes(box, nodeBox);\n        }\n    });\n    return boxToRect(box);\n};\nconst getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, \n// set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false) => {\n    const paneRect = {\n        ...pointToRendererPoint(rect, [tx, ty, tScale]),\n        width: rect.width / tScale,\n        height: rect.height / tScale,\n    };\n    const visibleNodes = [];\n    for (const node of nodes.values()) {\n        const { measured, selectable = true, hidden = false } = node;\n        if ((excludeNonSelectableNodes && !selectable) || hidden) {\n            continue;\n        }\n        const width = measured.width ?? node.width ?? node.initialWidth ?? null;\n        const height = measured.height ?? node.height ?? node.initialHeight ?? null;\n        const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));\n        const area = (width ?? 0) * (height ?? 0);\n        const partiallyVisible = partially && overlappingArea > 0;\n        const forceInitialRender = !node.internals.handleBounds;\n        const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    }\n    return visibleNodes;\n};\n/**\n * This utility filters an array of edges, keeping only those where either the source or target\n * node is present in the given array of nodes.\n * @public\n * @param nodes - Nodes you want to get the connected edges for.\n * @param edges - All edges.\n * @returns Array of edges that connect any of the given nodes with each other.\n *\n * @example\n * ```js\n *import { getConnectedEdges } from '@xyflow/react';\n *\n *const nodes = [\n *  { id: 'a', position: { x: 0, y: 0 } },\n *  { id: 'b', position: { x: 100, y: 0 } },\n *];\n *\n *const edges = [\n *  { id: 'a->c', source: 'a', target: 'c' },\n *  { id: 'c->d', source: 'c', target: 'd' },\n *];\n *\n *const connectedEdges = getConnectedEdges(nodes, edges);\n * // => [{ id: 'a->c', source: 'a', target: 'c' }]\n *```\n */\nconst getConnectedEdges = (nodes, edges) => {\n    const nodeIds = new Set();\n    nodes.forEach((node) => {\n        nodeIds.add(node.id);\n    });\n    return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));\n};\nfunction getFitViewNodes(nodeLookup, options) {\n    const fitViewNodes = new Map();\n    const optionNodeIds = options?.nodes ? new Set(options.nodes.map((node) => node.id)) : null;\n    nodeLookup.forEach((n) => {\n        const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);\n        if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {\n            fitViewNodes.set(n.id, n);\n        }\n    });\n    return fitViewNodes;\n}\nasync function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {\n    if (nodes.size === 0) {\n        return Promise.resolve(true);\n    }\n    const nodesToFit = getFitViewNodes(nodes, options);\n    const bounds = getInternalNodesBounds(nodesToFit);\n    const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);\n    await panZoom.setViewport(viewport, {\n        duration: options?.duration,\n        ease: options?.ease,\n        interpolate: options?.interpolate,\n    });\n    return Promise.resolve(true);\n}\n/**\n * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.\n *\n * @internal\n * @returns position, positionAbsolute\n */\nfunction calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError, }) {\n    const node = nodeLookup.get(nodeId);\n    const parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;\n    const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };\n    const origin = node.origin ?? nodeOrigin;\n    let extent = node.extent || nodeExtent;\n    if (node.extent === 'parent' && !node.expandParent) {\n        if (!parentNode) {\n            onError?.('005', errorMessages['error005']());\n        }\n        else {\n            const parentWidth = parentNode.measured.width;\n            const parentHeight = parentNode.measured.height;\n            if (parentWidth && parentHeight) {\n                extent = [\n                    [parentX, parentY],\n                    [parentX + parentWidth, parentY + parentHeight],\n                ];\n            }\n        }\n    }\n    else if (parentNode && isCoordinateExtent(node.extent)) {\n        extent = [\n            [node.extent[0][0] + parentX, node.extent[0][1] + parentY],\n            [node.extent[1][0] + parentX, node.extent[1][1] + parentY],\n        ];\n    }\n    const positionAbsolute = isCoordinateExtent(extent)\n        ? clampPosition(nextPosition, extent, node.measured)\n        : nextPosition;\n    if (node.measured.width === undefined || node.measured.height === undefined) {\n        onError?.('015', errorMessages['error015']());\n    }\n    return {\n        position: {\n            x: positionAbsolute.x - parentX + (node.measured.width ?? 0) * origin[0],\n            y: positionAbsolute.y - parentY + (node.measured.height ?? 0) * origin[1],\n        },\n        positionAbsolute,\n    };\n}\n/**\n * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted\n * @internal\n * @param param.nodesToRemove - The nodes to remove\n * @param param.edgesToRemove - The edges to remove\n * @param param.nodes - All nodes\n * @param param.edges - All edges\n * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted\n * @returns nodes: nodes that can be deleted, edges: edges that can be deleted\n */\nasync function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete, }) {\n    const nodeIds = new Set(nodesToRemove.map((node) => node.id));\n    const matchingNodes = [];\n    for (const node of nodes) {\n        if (node.deletable === false) {\n            continue;\n        }\n        const isIncluded = nodeIds.has(node.id);\n        const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);\n        if (isIncluded || parentHit) {\n            matchingNodes.push(node);\n        }\n    }\n    const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));\n    const deletableEdges = edges.filter((edge) => edge.deletable !== false);\n    const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);\n    const matchingEdges = connectedEdges;\n    for (const edge of deletableEdges) {\n        const isIncluded = edgeIds.has(edge.id);\n        if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {\n            matchingEdges.push(edge);\n        }\n    }\n    if (!onBeforeDelete) {\n        return {\n            edges: matchingEdges,\n            nodes: matchingNodes,\n        };\n    }\n    const onBeforeDeleteResult = await onBeforeDelete({\n        nodes: matchingNodes,\n        edges: matchingEdges,\n    });\n    if (typeof onBeforeDeleteResult === 'boolean') {\n        return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };\n    }\n    return onBeforeDeleteResult;\n}\n\nconst clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);\nconst clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({\n    x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),\n    y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0)),\n});\nfunction clampPositionToParent(childPosition, childDimensions, parent) {\n    const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);\n    const { x: parentX, y: parentY } = parent.internals.positionAbsolute;\n    return clampPosition(childPosition, [\n        [parentX, parentY],\n        [parentX + parentWidth, parentY + parentHeight],\n    ], childDimensions);\n}\n/**\n * Calculates the velocity of panning when the mouse is close to the edge of the canvas\n * @internal\n * @param value - One dimensional poition of the mouse (x or y)\n * @param min - Minimal position on canvas before panning starts\n * @param max - Maximal position on canvas before panning starts\n * @returns - A number between 0 and 1 that represents the velocity of panning\n */\nconst calcAutoPanVelocity = (value, min, max) => {\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, min) / min;\n    }\n    else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, min) / min;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds, speed = 15, distance = 40) => {\n    const xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;\n    const yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;\n    return [xMovement, yMovement];\n};\nconst getBoundsOfBoxes = (box1, box2) => ({\n    x: Math.min(box1.x, box2.x),\n    y: Math.min(box1.y, box2.y),\n    x2: Math.max(box1.x2, box2.x2),\n    y2: Math.max(box1.y2, box2.y2),\n});\nconst rectToBox = ({ x, y, width, height }) => ({\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n});\nconst boxToRect = ({ x, y, x2, y2 }) => ({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y,\n});\nconst nodeToRect = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n};\nconst nodeToBox = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),\n        y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0),\n    };\n};\nconst getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB) => {\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nconst isNumeric = (n) => !isNaN(n) && isFinite(n);\n// used for a11y key board controls for nodes and edges\nconst devWarn = (id, message) => {\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst snapPosition = (position, snapGrid = [1, 1]) => {\n    return {\n        x: snapGrid[0] * Math.round(position.x / snapGrid[0]),\n        y: snapGrid[1] * Math.round(position.y / snapGrid[1]),\n    };\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale,\n    };\n    return snapToGrid ? snapPosition(position, snapGrid) : position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty,\n    };\n};\n/**\n * Parses a single padding value to a number\n * @internal\n * @param padding - Padding to parse\n * @param viewport - Width or height of the viewport\n * @returns The padding in pixels\n */\nfunction parsePadding(padding, viewport) {\n    if (typeof padding === 'number') {\n        return Math.floor((viewport - viewport / (1 + padding)) * 0.5);\n    }\n    if (typeof padding === 'string' && padding.endsWith('px')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(paddingValue);\n        }\n    }\n    if (typeof padding === 'string' && padding.endsWith('%')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(viewport * paddingValue * 0.01);\n        }\n    }\n    console.error(`[React Flow] The padding value \"${padding}\" is invalid. Please provide a number or a string with a valid unit (px or %).`);\n    return 0;\n}\n/**\n * Parses the paddings to an object with top, right, bottom, left, x and y paddings\n * @internal\n * @param padding - Padding to parse\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the paddings in pixels\n */\nfunction parsePaddings(padding, width, height) {\n    if (typeof padding === 'string' || typeof padding === 'number') {\n        const paddingY = parsePadding(padding, height);\n        const paddingX = parsePadding(padding, width);\n        return {\n            top: paddingY,\n            right: paddingX,\n            bottom: paddingY,\n            left: paddingX,\n            x: paddingX * 2,\n            y: paddingY * 2,\n        };\n    }\n    if (typeof padding === 'object') {\n        const top = parsePadding(padding.top ?? padding.y ?? 0, height);\n        const bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height);\n        const left = parsePadding(padding.left ?? padding.x ?? 0, width);\n        const right = parsePadding(padding.right ?? padding.x ?? 0, width);\n        return { top, right, bottom, left, x: left + right, y: top + bottom };\n    }\n    return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };\n}\n/**\n * Calculates the resulting paddings if the new viewport is applied\n * @internal\n * @param bounds - Bounds to fit inside viewport\n * @param x - X position of the viewport\n * @param y - Y position of the viewport\n * @param zoom - Zoom level of the viewport\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the minimum padding required to fit the bounds inside the viewport\n */\nfunction calculateAppliedPaddings(bounds, x, y, zoom, width, height) {\n    const { x: left, y: top } = rendererPointToPoint(bounds, [x, y, zoom]);\n    const { x: boundRight, y: boundBottom } = rendererPointToPoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, [x, y, zoom]);\n    const right = width - boundRight;\n    const bottom = height - boundBottom;\n    return {\n        left: Math.floor(left),\n        top: Math.floor(top),\n        right: Math.floor(right),\n        bottom: Math.floor(bottom),\n    };\n}\n/**\n * Returns a viewport that encloses the given bounds with padding.\n * @public\n * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}\n * @param bounds - Bounds to fit inside viewport.\n * @param width - Width of the viewport.\n * @param height  - Height of the viewport.\n * @param minZoom - Minimum zoom level of the resulting viewport.\n * @param maxZoom - Maximum zoom level of the resulting viewport.\n * @param padding - Padding around the bounds.\n * @returns A transformed {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}.\n * @example\n * const { x, y, zoom } = getViewportForBounds(\n * { x: 0, y: 0, width: 100, height: 100},\n * 1200, 800, 0.5, 2);\n */\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {\n    // First we resolve all the paddings to actual pixel values\n    const p = parsePaddings(padding, width, height);\n    const xZoom = (width - p.x) / bounds.width;\n    const yZoom = (height - p.y) / bounds.height;\n    // We calculate the new x, y, zoom for a centered view\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    // Then we calculate the minimum padding, to respect asymmetric paddings\n    const newPadding = calculateAppliedPaddings(bounds, x, y, clampedZoom, width, height);\n    // We only want to have an offset if the newPadding is smaller than the required padding\n    const offset = {\n        left: Math.min(newPadding.left - p.left, 0),\n        top: Math.min(newPadding.top - p.top, 0),\n        right: Math.min(newPadding.right - p.right, 0),\n        bottom: Math.min(newPadding.bottom - p.bottom, 0),\n    };\n    return {\n        x: x - offset.left + offset.right,\n        y: y - offset.top + offset.bottom,\n        zoom: clampedZoom,\n    };\n};\nconst isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;\nfunction isCoordinateExtent(extent) {\n    return extent !== undefined && extent !== null && extent !== 'parent';\n}\nfunction getNodeDimensions(node) {\n    return {\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n}\nfunction nodeHasDimensions(node) {\n    return ((node.measured?.width ?? node.width ?? node.initialWidth) !== undefined &&\n        (node.measured?.height ?? node.height ?? node.initialHeight) !== undefined);\n}\n/**\n * Convert child position to aboslute position\n *\n * @internal\n * @param position\n * @param parentId\n * @param nodeLookup\n * @param nodeOrigin\n * @returns an internal node with an absolute position\n */\nfunction evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {\n    const positionAbsolute = { ...position };\n    const parent = nodeLookup.get(parentId);\n    if (parent) {\n        const origin = parent.origin || nodeOrigin;\n        positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];\n        positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];\n    }\n    return positionAbsolute;\n}\nfunction areSetsEqual(a, b) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a) {\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Polyfill for Promise.withResolvers until we can use it in all browsers\n * @internal\n */\nfunction withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\nfunction mergeAriaLabelConfig(partial) {\n    return { ...defaultAriaLabelConfig, ...(partial || {}) };\n}\n\nfunction getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform, containerBounds }) {\n    const { x, y } = getEventPosition(event);\n    const pointerPos = pointToRendererPoint({ x: x - (containerBounds?.left ?? 0), y: y - (containerBounds?.top ?? 0) }, transform);\n    const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;\n    // we need the snapped position in order to be able to skip unnecessary drag events\n    return {\n        xSnapped,\n        ySnapped,\n        ...pointerPos,\n    };\n}\nconst getDimensions = (node) => ({\n    width: node.offsetWidth,\n    height: node.offsetHeight,\n});\nconst getHostForElement = (element) => element?.getRootNode?.() || window?.document;\nconst inputTags = ['INPUT', 'SELECT', 'TEXTAREA'];\nfunction isInputDOMNode(event) {\n    // using composed path for handling shadow dom\n    const target = (event.composedPath?.()?.[0] || event.target);\n    if (target?.nodeType !== 1 /* Node.ELEMENT_NODE */)\n        return false;\n    const isInput = inputTags.includes(target.nodeName) || target.hasAttribute('contenteditable');\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target.closest('.nokey');\n}\nconst isMouseEvent = (event) => 'clientX' in event;\nconst getEventPosition = (event, bounds) => {\n    const isMouse = isMouseEvent(event);\n    const evtX = isMouse ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouse ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0),\n    };\n};\n/*\n * The handle bounds are calculated relative to the node element.\n * We store them in the internals object of the node in order to avoid\n * unnecessary recalculations.\n */\nconst getHandleBounds = (type, nodeElement, nodeBounds, zoom, nodeId) => {\n    const handles = nodeElement.querySelectorAll(`.${type}`);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    return Array.from(handles).map((handle) => {\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute('data-handleid'),\n            type,\n            nodeId,\n            position: handle.getAttribute('data-handlepos'),\n            x: (handleBounds.left - nodeBounds.left) / zoom,\n            y: (handleBounds.top - nodeBounds.top) / zoom,\n            ...getDimensions(handle),\n        };\n    });\n};\n\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY, }) {\n    /*\n     * cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n     * https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n     */\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [centerX, centerY, offsetX, offsetY];\n}\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch (pos) {\n        case Position.Left:\n            return [x1 - calculateControlOffset(x1 - x2, c), y1];\n        case Position.Right:\n            return [x1 + calculateControlOffset(x2 - x1, c), y1];\n        case Position.Top:\n            return [x1, y1 - calculateControlOffset(y1 - y2, c)];\n        case Position.Bottom:\n            return [x1, y1 + calculateControlOffset(y2 - y1, c)];\n    }\n}\n/**\n * The `getBezierPath` util returns everything you need to render a bezier edge\n *between two nodes.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *});\n *```\n *\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to\n *work with multiple edge paths at once.\n */\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25, }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature,\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature,\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY,\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY,\n    ];\n}\n\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY, }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [centerX, centerY, xOffset, yOffset];\n}\n/**\n * Returns the z-index for an edge based on the node it connects and whether it is selected.\n * By default, edges are rendered below nodes. This behaviour is different for edges that are\n * connected to nodes with a parent, as they are rendered above the parent node.\n */\nfunction getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex, elevateOnSelect = false, }) {\n    if (zIndex !== undefined) {\n        return zIndex;\n    }\n    const edgeZ = elevateOnSelect && selected ? 1000 : 0;\n    const nodeZ = Math.max(sourceNode.parentId || (elevateOnSelect && sourceNode.selected) ? sourceNode.internals.z : 0, targetNode.parentId || (elevateOnSelect && targetNode.selected) ? targetNode.internals.z : 0);\n    return edgeZ + nodeZ;\n}\nfunction isEdgeVisible({ sourceNode, targetNode, width, height, transform }) {\n    const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewRect = {\n        x: -transform[0] / transform[2],\n        y: -transform[1] / transform[2],\n        width: width / transform[2],\n        height: height / transform[2],\n    };\n    return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;\n}\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;\nconst connectionExists = (edge, edges) => {\n    return edges.some((el) => el.source === edge.source &&\n        el.target === edge.target &&\n        (el.sourceHandle === edge.sourceHandle || (!el.sourceHandle && !edge.sourceHandle)) &&\n        (el.targetHandle === edge.targetHandle || (!el.targetHandle && !edge.targetHandle)));\n};\n/**\n * This util is a convenience function to add a new Edge to an array of edges. It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.\n * @public\n * @param edgeParams - Either an `Edge` or a `Connection` you want to add.\n * @param edges - The array of all current edges.\n * @returns A new array of edges with the new edge added.\n *\n * @remarks If an edge with the same `target` and `source` already exists (and the same\n *`targetHandle` and `sourceHandle` if those are set), then this util won't add\n *a new edge even if the `id` property is different.\n *\n */\nconst addEdge = (edgeParams, edges) => {\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    let edge;\n    if (isEdgeBase(edgeParams)) {\n        edge = { ...edgeParams };\n    }\n    else {\n        edge = {\n            ...edgeParams,\n            id: getEdgeId(edgeParams),\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    if (edge.sourceHandle === null) {\n        delete edge.sourceHandle;\n    }\n    if (edge.targetHandle === null) {\n        delete edge.targetHandle;\n    }\n    return edges.concat(edge);\n};\n/**\n * A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.\n *This searches your edge array for an edge with a matching `id` and updates its\n *properties with the connection you provide.\n * @public\n * @param oldEdge - The edge you want to update.\n * @param newConnection - The new connection you want to update the edge with.\n * @param edges - The array of all current edges.\n * @returns The updated edges array.\n *\n * @example\n * ```js\n *const onReconnect = useCallback(\n *  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),[]);\n *```\n */\nconst reconnectEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const foundEdge = edges.find((e) => e.id === oldEdge.id);\n    if (!foundEdge) {\n        devWarn('007', errorMessages['error007'](oldEdgeId));\n        return edges;\n    }\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle,\n    };\n    return edges.filter((e) => e.id !== oldEdgeId).concat(edge);\n};\n\n/**\n * Calculates the straight line path between two points.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY, }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n    });\n    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\n\nconst handleDirections = {\n    [Position.Left]: { x: -1, y: 0 },\n    [Position.Right]: { x: 1, y: 0 },\n    [Position.Top]: { x: 0, y: -1 },\n    [Position.Bottom]: { x: 0, y: 1 },\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target, }) => {\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };\n    }\n    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };\n};\nconst distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n/*\n * With this function we try to mimic an orthogonal edge routing behaviour\n * It's not as good as a real orthogonal edge routing, but it's faster and good enough as a default for step and smooth step edges\n */\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, stepPosition, }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };\n    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped,\n    });\n    const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = { x: 0, y: 0 };\n    const targetGapOffset = { x: 0, y: 0 };\n    const [, , defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        if (dirAccessor === 'x') {\n            // Primary direction is horizontal, so stepPosition affects X coordinate\n            centerX = center.x ?? (sourceGapped.x + (targetGapped.x - sourceGapped.x) * stepPosition);\n            centerY = center.y ?? (sourceGapped.y + targetGapped.y) / 2;\n        }\n        else {\n            // Primary direction is vertical, so stepPosition affects Y coordinate  \n            centerX = center.x ?? (sourceGapped.x + targetGapped.x) / 2;\n            centerY = center.y ?? (sourceGapped.y + (targetGapped.y - sourceGapped.y) * stepPosition);\n        }\n        /*\n         *    --->\n         *    |\n         * >---\n         */\n        const verticalSplit = [\n            { x: centerX, y: sourceGapped.y },\n            { x: centerX, y: targetGapped.y },\n        ];\n        /*\n         *    |\n         *  ---\n         *  |\n         */\n        const horizontalSplit = [\n            { x: sourceGapped.x, y: centerY },\n            { x: targetGapped.x, y: centerY },\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n        }\n        else {\n            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n        }\n    }\n    else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];\n        const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];\n        // this handles edges with same handle positions\n        if (dirAccessor === 'x') {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        }\n        else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n                else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = (sourceDir[dirAccessor] === 1 && ((!isSameDir && sourceGtTargetOppo) || (isSameDir && sourceLtTargetOppo))) ||\n                (sourceDir[dirAccessor] !== 1 && ((!isSameDir && sourceLtTargetOppo) || (isSameDir && sourceGtTargetOppo)));\n            if (flipSourceTarget) {\n                points = dirAccessor === 'x' ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };\n        const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        }\n        else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },\n        ...points,\n        { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },\n        target,\n    ];\n    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if ((a.x === x && x === c.x) || (a.y === y && y === c.y)) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\n/**\n * The `getSmoothStepPath` util returns everything you need to render a stepped path\n * between two nodes. The `borderRadius` property can be used to choose how rounded\n * the corners of those steps are.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, stepPosition = 0.5, }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: { x: sourceX, y: sourceY },\n        sourcePosition,\n        target: { x: targetX, y: targetY },\n        targetPosition,\n        center: { x: centerX, y: centerY },\n        offset,\n        stepPosition,\n    });\n    const path = points.reduce((res, p, i) => {\n        let segment = '';\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        }\n        else {\n            segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, '');\n    return [path, labelX, labelY, offsetX, offsetY];\n}\n\nfunction isNodeInitialized(node) {\n    return (node &&\n        !!(node.internals.handleBounds || node.handles?.length) &&\n        !!(node.measured.width || node.width || node.initialWidth));\n}\nfunction getEdgePosition(params) {\n    const { sourceNode, targetNode } = params;\n    if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {\n        return null;\n    }\n    const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);\n    const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);\n    const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);\n    const targetHandle = getHandle$1(\n    // when connection type is loose we can define all handles as sources and connect source -> source\n    params.connectionMode === ConnectionMode.Strict\n        ? targetHandleBounds?.target ?? []\n        : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []), params.targetHandle);\n    if (!sourceHandle || !targetHandle) {\n        params.onError?.('008', errorMessages['error008'](!sourceHandle ? 'source' : 'target', {\n            id: params.id,\n            sourceHandle: params.sourceHandle,\n            targetHandle: params.targetHandle,\n        }));\n        return null;\n    }\n    const sourcePosition = sourceHandle?.position || Position.Bottom;\n    const targetPosition = targetHandle?.position || Position.Top;\n    const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);\n    const target = getHandlePosition(targetNode, targetHandle, targetPosition);\n    return {\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n        sourcePosition,\n        targetPosition,\n    };\n}\nfunction toHandleBounds(handles) {\n    if (!handles) {\n        return null;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of handles) {\n        handle.width = handle.width ?? 1;\n        handle.height = handle.height ?? 1;\n        if (handle.type === 'source') {\n            source.push(handle);\n        }\n        else if (handle.type === 'target') {\n            target.push(handle);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {\n    const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;\n    const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;\n    const { width, height } = handle ?? getNodeDimensions(node);\n    if (center) {\n        return { x: x + width / 2, y: y + height / 2 };\n    }\n    const position = handle?.position ?? fallbackPosition;\n    switch (position) {\n        case Position.Top:\n            return { x: x + width / 2, y };\n        case Position.Right:\n            return { x: x + width, y: y + height / 2 };\n        case Position.Bottom:\n            return { x: x + width / 2, y: y + height };\n        case Position.Left:\n            return { x, y: y + height / 2 };\n    }\n}\nfunction getHandle$1(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    // if no handleId is given, we use the first handle, otherwise we check for the id\n    return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;\n}\n\nfunction getMarkerId(marker, id) {\n    if (!marker) {\n        return '';\n    }\n    if (typeof marker === 'string') {\n        return marker;\n    }\n    const idPrefix = id ? `${id}__` : '';\n    return `${idPrefix}${Object.keys(marker)\n        .sort()\n        .map((key) => `${key}=${marker[key]}`)\n        .join('&')}`;\n}\nfunction createMarkerIds(edges, { id, defaultColor, defaultMarkerStart, defaultMarkerEnd, }) {\n    const ids = new Set();\n    return edges\n        .reduce((markers, edge) => {\n        [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {\n            if (marker && typeof marker === 'object') {\n                const markerId = getMarkerId(marker, id);\n                if (!ids.has(markerId)) {\n                    markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });\n                    ids.add(markerId);\n                }\n            }\n        });\n        return markers;\n    }, [])\n        .sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {\n    let alignmentOffset = 0.5;\n    if (align === 'start') {\n        alignmentOffset = 0;\n    }\n    else if (align === 'end') {\n        alignmentOffset = 1;\n    }\n    /*\n     * position === Position.Top\n     * we set the x any y position of the toolbar based on the nodes position\n     */\n    let pos = [\n        (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,\n        nodeRect.y * viewport.zoom + viewport.y - offset,\n    ];\n    // and than shift it based on the alignment. The shift values are in %.\n    let shift = [-100 * alignmentOffset, -100];\n    switch (position) {\n        case Position.Right:\n            pos = [\n                (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [0, -100 * alignmentOffset];\n            break;\n        case Position.Bottom:\n            pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;\n            shift[1] = 0;\n            break;\n        case Position.Left:\n            pos = [\n                nodeRect.x * viewport.zoom + viewport.x - offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [-100, -100 * alignmentOffset];\n            break;\n    }\n    return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\n\nconst defaultOptions = {\n    nodeOrigin: [0, 0],\n    nodeExtent: infiniteExtent,\n    elevateNodesOnSelect: true,\n    defaults: {},\n};\nconst adoptUserNodesDefaultOptions = {\n    ...defaultOptions,\n    checkEquality: true,\n};\nfunction mergeObjects(base, incoming) {\n    const result = { ...base };\n    for (const key in incoming) {\n        if (incoming[key] !== undefined) {\n            // typecast is safe here, because we check for undefined\n            result[key] = incoming[key];\n        }\n    }\n    return result;\n}\nfunction updateAbsolutePositions(nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(defaultOptions, options);\n    for (const node of nodeLookup.values()) {\n        if (node.parentId) {\n            updateChildNode(node, nodeLookup, parentLookup, _options);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);\n            const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));\n            node.internals.positionAbsolute = clampedPosition;\n        }\n    }\n}\nfunction parseHandles(userNode, internalNode) {\n    if (!userNode.handles) {\n        return !userNode.measured ? undefined : internalNode?.internals.handleBounds;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of userNode.handles) {\n        const handleBounds = {\n            width: handle.width ?? 1,\n            height: handle.height ?? 1,\n            nodeId: userNode.id,\n            x: handle.x,\n            y: handle.y,\n            position: handle.position,\n            type: handle.type,\n        };\n        if (handle.type === 'source') {\n            source.push(handleBounds);\n        }\n        else if (handle.type === 'target') {\n            target.push(handleBounds);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction adoptUserNodes(nodes, nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(adoptUserNodesDefaultOptions, options);\n    let nodesInitialized = nodes.length > 0;\n    const tmpLookup = new Map(nodeLookup);\n    const selectedNodeZ = _options?.elevateNodesOnSelect ? 1000 : 0;\n    nodeLookup.clear();\n    parentLookup.clear();\n    for (const userNode of nodes) {\n        let internalNode = tmpLookup.get(userNode.id);\n        if (_options.checkEquality && userNode === internalNode?.internals.userNode) {\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);\n            const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));\n            internalNode = {\n                ..._options.defaults,\n                ...userNode,\n                measured: {\n                    width: userNode.measured?.width,\n                    height: userNode.measured?.height,\n                },\n                internals: {\n                    positionAbsolute: clampedPosition,\n                    // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured\n                    handleBounds: parseHandles(userNode, internalNode),\n                    z: calculateZ(userNode, selectedNodeZ),\n                    userNode,\n                },\n            };\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        if ((internalNode.measured === undefined ||\n            internalNode.measured.width === undefined ||\n            internalNode.measured.height === undefined) &&\n            !internalNode.hidden) {\n            nodesInitialized = false;\n        }\n        if (userNode.parentId) {\n            updateChildNode(internalNode, nodeLookup, parentLookup, options);\n        }\n    }\n    return nodesInitialized;\n}\nfunction updateParentLookup(node, parentLookup) {\n    if (!node.parentId) {\n        return;\n    }\n    const childNodes = parentLookup.get(node.parentId);\n    if (childNodes) {\n        childNodes.set(node.id, node);\n    }\n    else {\n        parentLookup.set(node.parentId, new Map([[node.id, node]]));\n    }\n}\n/**\n * Updates positionAbsolute and zIndex of a child node and the parentLookup.\n */\nfunction updateChildNode(node, nodeLookup, parentLookup, options) {\n    const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options);\n    const parentId = node.parentId;\n    const parentNode = nodeLookup.get(parentId);\n    if (!parentNode) {\n        console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);\n        return;\n    }\n    updateParentLookup(node, parentLookup);\n    const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;\n    const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);\n    const { positionAbsolute } = node.internals;\n    const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;\n    if (positionChanged || z !== node.internals.z) {\n        // we create a new object to mark the node as updated\n        nodeLookup.set(node.id, {\n            ...node,\n            internals: {\n                ...node.internals,\n                positionAbsolute: positionChanged ? { x, y } : positionAbsolute,\n                z,\n            },\n        });\n    }\n}\nfunction calculateZ(node, selectedNodeZ) {\n    return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n}\nfunction calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {\n    const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;\n    const childDimensions = getNodeDimensions(childNode);\n    const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);\n    const clampedPosition = isCoordinateExtent(childNode.extent)\n        ? clampPosition(positionWithOrigin, childNode.extent, childDimensions)\n        : positionWithOrigin;\n    let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);\n    if (childNode.extent === 'parent') {\n        absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);\n    }\n    const childZ = calculateZ(childNode, selectedNodeZ);\n    const parentZ = parentNode.internals.z ?? 0;\n    return {\n        x: absolutePosition.x,\n        y: absolutePosition.y,\n        z: parentZ >= childZ ? parentZ + 1 : childZ,\n    };\n}\nfunction handleExpandParent(children, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {\n    const changes = [];\n    const parentExpansions = new Map();\n    // determine the expanded rectangle the child nodes would take for each parent\n    for (const child of children) {\n        const parent = nodeLookup.get(child.parentId);\n        if (!parent) {\n            continue;\n        }\n        const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent);\n        const expandedRect = getBoundsOfRects(parentRect, child.rect);\n        parentExpansions.set(child.parentId, { expandedRect, parent });\n    }\n    if (parentExpansions.size > 0) {\n        parentExpansions.forEach(({ expandedRect, parent }, parentId) => {\n            // determine the position & dimensions of the parent\n            const positionAbsolute = parent.internals.positionAbsolute;\n            const dimensions = getNodeDimensions(parent);\n            const origin = parent.origin ?? nodeOrigin;\n            // determine how much the parent expands in width and position\n            const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;\n            const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;\n            const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));\n            const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));\n            const widthChange = (newWidth - dimensions.width) * origin[0];\n            const heightChange = (newHeight - dimensions.height) * origin[1];\n            // We need to correct the position of the parent node if the origin is not [0,0]\n            if (xChange > 0 || yChange > 0 || widthChange || heightChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'position',\n                    position: {\n                        x: parent.position.x - xChange + widthChange,\n                        y: parent.position.y - yChange + heightChange,\n                    },\n                });\n                /*\n                 * We move all child nodes in the oppsite direction\n                 * so the x,y changes of the parent do not move the children\n                 */\n                parentLookup.get(parentId)?.forEach((childNode) => {\n                    if (!children.some((child) => child.id === childNode.id)) {\n                        changes.push({\n                            id: childNode.id,\n                            type: 'position',\n                            position: {\n                                x: childNode.position.x + xChange,\n                                y: childNode.position.y + yChange,\n                            },\n                        });\n                    }\n                });\n            }\n            // We need to correct the dimensions of the parent node if the origin is not [0,0]\n            if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'dimensions',\n                    setAttributes: true,\n                    dimensions: {\n                        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),\n                        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0),\n                    },\n                });\n            }\n        });\n    }\n    return changes;\n}\nfunction updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {\n    const viewportNode = domNode?.querySelector('.xyflow__viewport');\n    let updatedInternals = false;\n    if (!viewportNode) {\n        return { changes: [], updatedInternals };\n    }\n    const changes = [];\n    const style = window.getComputedStyle(viewportNode);\n    const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n    // in this array we collect nodes, that might trigger changes (like expanding parent)\n    const parentExpandChildren = [];\n    for (const update of updates.values()) {\n        const node = nodeLookup.get(update.id);\n        if (!node) {\n            continue;\n        }\n        if (node.hidden) {\n            nodeLookup.set(node.id, {\n                ...node,\n                internals: {\n                    ...node.internals,\n                    handleBounds: undefined,\n                },\n            });\n            updatedInternals = true;\n            continue;\n        }\n        const dimensions = getDimensions(update.nodeElement);\n        const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;\n        const doUpdate = !!(dimensions.width &&\n            dimensions.height &&\n            (dimensionChanged || !node.internals.handleBounds || update.force));\n        if (doUpdate) {\n            const nodeBounds = update.nodeElement.getBoundingClientRect();\n            const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;\n            let { positionAbsolute } = node.internals;\n            if (node.parentId && node.extent === 'parent') {\n                positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));\n            }\n            else if (extent) {\n                positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);\n            }\n            const newNode = {\n                ...node,\n                measured: dimensions,\n                internals: {\n                    ...node.internals,\n                    positionAbsolute,\n                    handleBounds: {\n                        source: getHandleBounds('source', update.nodeElement, nodeBounds, zoom, node.id),\n                        target: getHandleBounds('target', update.nodeElement, nodeBounds, zoom, node.id),\n                    },\n                },\n            };\n            nodeLookup.set(node.id, newNode);\n            if (node.parentId) {\n                updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin });\n            }\n            updatedInternals = true;\n            if (dimensionChanged) {\n                changes.push({\n                    id: node.id,\n                    type: 'dimensions',\n                    dimensions,\n                });\n                if (node.expandParent && node.parentId) {\n                    parentExpandChildren.push({\n                        id: node.id,\n                        parentId: node.parentId,\n                        rect: nodeToRect(newNode, nodeOrigin),\n                    });\n                }\n            }\n        }\n    }\n    if (parentExpandChildren.length > 0) {\n        const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n        changes.push(...parentExpandChanges);\n    }\n    return { changes, updatedInternals };\n}\nasync function panBy({ delta, panZoom, transform, translateExtent, width, height, }) {\n    if (!panZoom || (!delta.x && !delta.y)) {\n        return Promise.resolve(false);\n    }\n    const nextViewport = await panZoom.setViewportConstrained({\n        x: transform[0] + delta.x,\n        y: transform[1] + delta.y,\n        zoom: transform[2],\n    }, [\n        [0, 0],\n        [width, height],\n    ], translateExtent);\n    const transformChanged = !!nextViewport &&\n        (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);\n    return Promise.resolve(transformChanged);\n}\n/**\n * this function adds the connection to the connectionLookup\n * at the following keys: nodeId-type-handleId, nodeId-type and nodeId\n * @param type type of the connection\n * @param connection connection that should be added to the lookup\n * @param connectionKey at which key the connection should be added\n * @param connectionLookup reference to the connection lookup\n * @param nodeId nodeId of the connection\n * @param handleId handleId of the conneciton\n */\nfunction addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {\n    /*\n     * We add the connection to the connectionLookup at the following keys\n     * 1. nodeId, 2. nodeId-type, 3. nodeId-type-handleId\n     * If the key already exists, we add the connection to the existing map\n     */\n    let key = nodeId;\n    const nodeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, nodeMap.set(connectionKey, connection));\n    key = `${nodeId}-${type}`;\n    const typeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, typeMap.set(connectionKey, connection));\n    if (handleId) {\n        key = `${nodeId}-${type}-${handleId}`;\n        const handleMap = connectionLookup.get(key) || new Map();\n        connectionLookup.set(key, handleMap.set(connectionKey, connection));\n    }\n}\nfunction updateConnectionLookup(connectionLookup, edgeLookup, edges) {\n    connectionLookup.clear();\n    edgeLookup.clear();\n    for (const edge of edges) {\n        const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge;\n        const connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle };\n        const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;\n        const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;\n        addConnectionToLookup('source', connection, targetKey, connectionLookup, sourceNode, sourceHandle);\n        addConnectionToLookup('target', connection, sourceKey, connectionLookup, targetNode, targetHandle);\n        edgeLookup.set(edge.id, edge);\n    }\n}\n\nfunction shallowNodeData(a, b) {\n    if (a === null || b === null) {\n        return false;\n    }\n    const _a = Array.isArray(a) ? a : [a];\n    const _b = Array.isArray(b) ? b : [b];\n    if (_a.length !== _b.length) {\n        return false;\n    }\n    for (let i = 0; i < _a.length; i++) {\n        if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isParentSelected(node, nodeLookup) {\n    if (!node.parentId) {\n        return false;\n    }\n    const parentNode = nodeLookup.get(node.parentId);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeLookup);\n}\nfunction hasSelector(target, selector, domNode) {\n    let current = target;\n    do {\n        if (current?.matches?.(selector))\n            return true;\n        if (current === domNode)\n            return false;\n        current = current?.parentElement;\n    } while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {\n    const dragItems = new Map();\n    for (const [id, node] of nodeLookup) {\n        if ((node.selected || node.id === nodeId) &&\n            (!node.parentId || !isParentSelected(node, nodeLookup)) &&\n            (node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'))) {\n            const internalNode = nodeLookup.get(id);\n            if (internalNode) {\n                dragItems.set(id, {\n                    id,\n                    position: internalNode.position || { x: 0, y: 0 },\n                    distance: {\n                        x: mousePos.x - internalNode.internals.positionAbsolute.x,\n                        y: mousePos.y - internalNode.internals.positionAbsolute.y,\n                    },\n                    extent: internalNode.extent,\n                    parentId: internalNode.parentId,\n                    origin: internalNode.origin,\n                    expandParent: internalNode.expandParent,\n                    internals: {\n                        positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 },\n                    },\n                    measured: {\n                        width: internalNode.measured.width ?? 0,\n                        height: internalNode.measured.height ?? 0,\n                    },\n                });\n            }\n        }\n    }\n    return dragItems;\n}\n/*\n * returns two params:\n * 1. the dragged node (or the first of the list, if we are dragging a node selection)\n * 2. array of selected nodes (for multi selections)\n */\nfunction getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true, }) {\n    const nodesFromDragItems = [];\n    for (const [id, dragItem] of dragItems) {\n        const node = nodeLookup.get(id)?.internals.userNode;\n        if (node) {\n            nodesFromDragItems.push({\n                ...node,\n                position: dragItem.position,\n                dragging,\n            });\n        }\n    }\n    if (!nodeId) {\n        return [nodesFromDragItems[0], nodesFromDragItems];\n    }\n    const node = nodeLookup.get(nodeId)?.internals.userNode;\n    return [\n        !node\n            ? nodesFromDragItems[0]\n            : {\n                ...node,\n                position: dragItems.get(nodeId)?.position || node.position,\n                dragging,\n            },\n        nodesFromDragItems,\n    ];\n}\n/**\n * If a selection is being dragged we want to apply the same snap offset to all nodes in the selection.\n * This function calculates the snap offset based on the first node in the selection.\n */\nfunction calculateSnapOffset({ dragItems, snapGrid, x, y, }) {\n    const refDragItem = dragItems.values().next().value;\n    if (!refDragItem) {\n        return null;\n    }\n    const refPos = {\n        x: x - refDragItem.distance.x,\n        y: y - refDragItem.distance.y,\n    };\n    const refPosSnapped = snapPosition(refPos, snapGrid);\n    return {\n        x: refPosSnapped.x - refPos.x,\n        y: refPosSnapped.y - refPos.y,\n    };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop, }) {\n    let lastPos = { x: null, y: null };\n    let autoPanId = 0;\n    let dragItems = new Map();\n    let autoPanStarted = false;\n    let mousePosition = { x: 0, y: 0 };\n    let containerBounds = null;\n    let dragStarted = false;\n    let d3Selection = null;\n    let abortDrag = false; // prevents unintentional dragging on multitouch\n    let nodePositionsChanged = false;\n    // we store the last drag event to be able to use it in the update function\n    let dragEvent = null;\n    // public functions\n    function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0, }) {\n        d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n        function updateNodes({ x, y }) {\n            const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions, } = getStoreItems();\n            lastPos = { x, y };\n            let hasChange = false;\n            const isMultiDrag = dragItems.size > 1;\n            const nodesBox = isMultiDrag && nodeExtent ? rectToBox(getInternalNodesBounds(dragItems)) : null;\n            const multiDragSnapOffset = isMultiDrag && snapToGrid\n                ? calculateSnapOffset({\n                    dragItems,\n                    snapGrid,\n                    x,\n                    y,\n                })\n                : null;\n            for (const [id, dragItem] of dragItems) {\n                /*\n                 * if the node is not in the nodeLookup anymore, it was probably deleted while dragging\n                 */\n                if (!nodeLookup.has(id)) {\n                    continue;\n                }\n                let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };\n                if (snapToGrid) {\n                    nextPosition = multiDragSnapOffset\n                        ? {\n                            x: Math.round(nextPosition.x + multiDragSnapOffset.x),\n                            y: Math.round(nextPosition.y + multiDragSnapOffset.y),\n                        }\n                        : snapPosition(nextPosition, snapGrid);\n                }\n                let adjustedNodeExtent = null;\n                if (isMultiDrag && nodeExtent && !dragItem.extent && nodesBox) {\n                    const { positionAbsolute } = dragItem.internals;\n                    const x1 = positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                    const x2 = positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];\n                    const y1 = positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                    const y2 = positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];\n                    adjustedNodeExtent = [\n                        [x1, y1],\n                        [x2, y2],\n                    ];\n                }\n                const { position, positionAbsolute } = calculateNodePosition({\n                    nodeId: id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent: adjustedNodeExtent ? adjustedNodeExtent : nodeExtent,\n                    nodeOrigin,\n                    onError,\n                });\n                // we want to make sure that we only fire a change event when there is a change\n                hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;\n                dragItem.position = position;\n                dragItem.internals.positionAbsolute = positionAbsolute;\n            }\n            nodePositionsChanged = nodePositionsChanged || hasChange;\n            if (!hasChange) {\n                return;\n            }\n            updateNodePositions(dragItems, true);\n            if (dragEvent && (onDrag || onNodeDrag || (!nodeId && onSelectionDrag))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDrag?.(dragEvent, dragItems, currentNode, currentNodes);\n                onNodeDrag?.(dragEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDrag?.(dragEvent, currentNodes);\n                }\n            }\n        }\n        async function autoPan() {\n            if (!containerBounds) {\n                return;\n            }\n            const { transform, panBy, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();\n            if (!autoPanOnNodeDrag) {\n                autoPanStarted = false;\n                cancelAnimationFrame(autoPanId);\n                return;\n            }\n            const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);\n            if (xMovement !== 0 || yMovement !== 0) {\n                lastPos.x = (lastPos.x ?? 0) - xMovement / transform[2];\n                lastPos.y = (lastPos.y ?? 0) - yMovement / transform[2];\n                if (await panBy({ x: xMovement, y: yMovement })) {\n                    updateNodes(lastPos);\n                }\n            }\n            autoPanId = requestAnimationFrame(autoPan);\n        }\n        function startDrag(event) {\n            const { nodeLookup, multiSelectionActive, nodesDraggable, transform, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges, } = getStoreItems();\n            dragStarted = true;\n            if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                if (!nodeLookup.get(nodeId)?.selected) {\n                    // we need to reset selected nodes when selectNodesOnDrag=false\n                    unselectNodesAndEdges();\n                }\n            }\n            if (isSelectable && selectNodesOnDrag && nodeId) {\n                onNodeMouseDown?.(nodeId);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);\n            if (dragItems.size > 0 && (onDragStart || onNodeDragStart || (!nodeId && onSelectionDragStart))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDragStart?.(event.sourceEvent, currentNodes);\n                }\n            }\n        }\n        const d3DragInstance = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .clickDistance(nodeClickDistance)\n            .on('start', (event) => {\n            const { domNode, nodeDragThreshold, transform, snapGrid, snapToGrid } = getStoreItems();\n            containerBounds = domNode?.getBoundingClientRect() || null;\n            abortDrag = false;\n            nodePositionsChanged = false;\n            dragEvent = event.sourceEvent;\n            if (nodeDragThreshold === 0) {\n                startDrag(event);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n        })\n            .on('drag', (event) => {\n            const { autoPanOnNodeDrag, transform, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            dragEvent = event.sourceEvent;\n            if ((event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1) ||\n                // if user deletes a node while dragging, we need to abort the drag to prevent errors\n                (nodeId && !nodeLookup.has(nodeId))) {\n                abortDrag = true;\n            }\n            if (abortDrag) {\n                return;\n            }\n            if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {\n                autoPanStarted = true;\n                autoPan();\n            }\n            if (!dragStarted) {\n                // Calculate distance in client coordinates for consistent drag threshold behavior across zoom levels\n                const currentMousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                const x = currentMousePosition.x - mousePosition.x;\n                const y = currentMousePosition.y - mousePosition.y;\n                const distance = Math.sqrt(x * x + y * y);\n                if (distance > nodeDragThreshold) {\n                    startDrag(event);\n                }\n            }\n            // skip events without movement\n            if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {\n                mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                updateNodes(pointerPos);\n            }\n        })\n            .on('end', (event) => {\n            if (!dragStarted || abortDrag) {\n                return;\n            }\n            autoPanStarted = false;\n            dragStarted = false;\n            cancelAnimationFrame(autoPanId);\n            if (dragItems.size > 0) {\n                const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();\n                if (nodePositionsChanged) {\n                    updateNodePositions(dragItems, false);\n                    nodePositionsChanged = false;\n                }\n                if (onDragStop || onNodeDragStop || (!nodeId && onSelectionDragStop)) {\n                    const [currentNode, currentNodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems,\n                        nodeLookup,\n                        dragging: false,\n                    });\n                    onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                    onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes);\n                    if (!nodeId) {\n                        onSelectionDragStop?.(event.sourceEvent, currentNodes);\n                    }\n                }\n            }\n        })\n            .filter((event) => {\n            const target = event.target;\n            const isDraggable = !event.button &&\n                (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) &&\n                (!handleSelector || hasSelector(target, handleSelector, domNode));\n            return isDraggable;\n        });\n        d3Selection.call(d3DragInstance);\n    }\n    function destroy() {\n        d3Selection?.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\nfunction getNodesWithinDistance(position, nodeLookup, distance) {\n    const nodes = [];\n    const rect = {\n        x: position.x - distance,\n        y: position.y - distance,\n        width: distance * 2,\n        height: distance * 2,\n    };\n    for (const node of nodeLookup.values()) {\n        if (getOverlappingArea(rect, nodeToRect(node)) > 0) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n/*\n * this distance is used for the area around the user pointer\n * while doing a connection for finding the closest nodes\n */\nconst ADDITIONAL_DISTANCE = 250;\nfunction getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {\n    let closestHandles = [];\n    let minDistance = Infinity;\n    const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);\n    for (const node of closeNodes) {\n        const allHandles = [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n        for (const handle of allHandles) {\n            // if the handle is the same as the fromHandle we skip it\n            if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {\n                continue;\n            }\n            // determine absolute position of the handle\n            const { x, y } = getHandlePosition(node, handle, handle.position, true);\n            const distance = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));\n            if (distance > connectionRadius) {\n                continue;\n            }\n            if (distance < minDistance) {\n                closestHandles = [{ ...handle, x, y }];\n                minDistance = distance;\n            }\n            else if (distance === minDistance) {\n                // when multiple handles are on the same distance we collect all of them\n                closestHandles.push({ ...handle, x, y });\n            }\n        }\n    }\n    if (!closestHandles.length) {\n        return null;\n    }\n    // when multiple handles overlay each other we prefer the opposite handle\n    if (closestHandles.length > 1) {\n        const oppositeHandleType = fromHandle.type === 'source' ? 'target' : 'source';\n        return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];\n    }\n    return closestHandles[0];\n}\nfunction getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {\n    const node = nodeLookup.get(nodeId);\n    if (!node) {\n        return null;\n    }\n    const handles = connectionMode === 'strict'\n        ? node.internals.handleBounds?.[handleType]\n        : [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n    const handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;\n    return handle && withAbsolutePosition\n        ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) }\n        : handle;\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    }\n    else if (handleDomNode?.classList.contains('target')) {\n        return 'target';\n    }\n    else if (handleDomNode?.classList.contains('source')) {\n        return 'source';\n    }\n    return null;\n}\nfunction isConnectionValid(isInsideConnectionRadius, isHandleValid) {\n    let isValid = null;\n    if (isHandleValid) {\n        isValid = true;\n    }\n    else if (isInsideConnectionRadius && !isHandleValid) {\n        isValid = false;\n    }\n    return isValid;\n}\n\nconst alwaysValid = () => true;\nfunction onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, dragThreshold = 1, handleDomNode, }) {\n    // when xyflow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const handleType = getHandleType(edgeUpdaterType, handleDomNode);\n    const containerBounds = domNode?.getBoundingClientRect();\n    let connectionStarted = false;\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);\n    if (!fromHandleInternal) {\n        return;\n    }\n    let position = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let resultHandleDomNode = null;\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    function autoPan() {\n        if (!autoPanOnConnect || !containerBounds) {\n            return;\n        }\n        const [x, y] = calcAutoPan(position, containerBounds, autoPanSpeed);\n        panBy({ x, y });\n        autoPanId = requestAnimationFrame(autoPan);\n    }\n    // Stays the same for all consecutive pointermove events\n    const fromHandle = {\n        ...fromHandleInternal,\n        nodeId,\n        type: handleType,\n        position: fromHandleInternal.position,\n    };\n    const fromNodeInternal = nodeLookup.get(nodeId);\n    const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);\n    let previousConnection = {\n        inProgress: true,\n        isValid: null,\n        from,\n        fromHandle,\n        fromPosition: fromHandle.position,\n        fromNode: fromNodeInternal,\n        to: position,\n        toHandle: null,\n        toPosition: oppositePosition[fromHandle.position],\n        toNode: null,\n    };\n    function startConnection() {\n        connectionStarted = true;\n        updateConnection(previousConnection);\n        onConnectStart?.(event, { nodeId, handleId, handleType });\n    }\n    if (dragThreshold === 0) {\n        startConnection();\n    }\n    function onPointerMove(event) {\n        if (!connectionStarted) {\n            const { x: evtX, y: evtY } = getEventPosition(event);\n            const dx = evtX - x;\n            const dy = evtY - y;\n            const nextConnectionStarted = dx * dx + dy * dy > dragThreshold * dragThreshold;\n            if (!nextConnectionStarted) {\n                return;\n            }\n            startConnection();\n        }\n        if (!getFromHandle() || !fromHandle) {\n            onPointerUp(event);\n            return;\n        }\n        const transform = getTransform();\n        position = getEventPosition(event, containerBounds);\n        closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        const result = isValidHandle(event, {\n            handle: closestHandle,\n            connectionMode,\n            fromNodeId: nodeId,\n            fromHandleId: handleId,\n            fromType: isTarget ? 'target' : 'source',\n            isValidConnection,\n            doc,\n            lib,\n            flowId,\n            nodeLookup,\n        });\n        resultHandleDomNode = result.handleDomNode;\n        connection = result.connection;\n        isValid = isConnectionValid(!!closestHandle, result.isValid);\n        const newConnection = {\n            // from stays the same\n            ...previousConnection,\n            isValid,\n            to: result.toHandle && isValid\n                ? rendererPointToPoint({ x: result.toHandle.x, y: result.toHandle.y }, transform)\n                : position,\n            toHandle: result.toHandle,\n            toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],\n            toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,\n        };\n        /*\n         * we don't want to trigger an update when the connection\n         * is snapped to the same handle as before\n         */\n        if (isValid &&\n            closestHandle &&\n            previousConnection.toHandle &&\n            newConnection.toHandle &&\n            previousConnection.toHandle.type === newConnection.toHandle.type &&\n            previousConnection.toHandle.nodeId === newConnection.toHandle.nodeId &&\n            previousConnection.toHandle.id === newConnection.toHandle.id &&\n            previousConnection.to.x === newConnection.to.x &&\n            previousConnection.to.y === newConnection.to.y) {\n            return;\n        }\n        updateConnection(newConnection);\n        previousConnection = newConnection;\n    }\n    function onPointerUp(event) {\n        // Prevent multi-touch aborting connection\n        if ('touches' in event && event.touches.length > 0) {\n            return;\n        }\n        if (connectionStarted) {\n            if ((closestHandle || resultHandleDomNode) && connection && isValid) {\n                onConnect?.(connection);\n            }\n            /*\n             * it's important to get a fresh reference from the store here\n             * in order to get the latest state of onConnectEnd\n             */\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { inProgress, ...connectionState } = previousConnection;\n            const finalConnectionState = {\n                ...connectionState,\n                toPosition: previousConnection.toHandle ? previousConnection.toPosition : null,\n            };\n            onConnectEnd?.(event, finalConnectionState);\n            if (edgeUpdaterType) {\n                onReconnectEnd?.(event, finalConnectionState);\n            }\n        }\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        resultHandleDomNode = null;\n        doc.removeEventListener('mousemove', onPointerMove);\n        doc.removeEventListener('mouseup', onPointerUp);\n        doc.removeEventListener('touchmove', onPointerMove);\n        doc.removeEventListener('touchend', onPointerUp);\n    }\n    doc.addEventListener('mousemove', onPointerMove);\n    doc.addEventListener('mouseup', onPointerUp);\n    doc.addEventListener('touchmove', onPointerMove);\n    doc.addEventListener('touchend', onPointerUp);\n}\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup, }) {\n    const isTarget = fromType === 'target';\n    const handleDomNode = handle\n        ? doc.querySelector(`.${lib}-flow__handle[data-id=\"${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`)\n        : null;\n    const { x, y } = getEventPosition(event);\n    const handleBelow = doc.elementFromPoint(x, y);\n    /*\n     * we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n     * because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n     */\n    const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;\n    const result = {\n        handleDomNode: handleToCheck,\n        isValid: false,\n        connection: null,\n        toHandle: null,\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute('data-nodeid');\n        const handleId = handleToCheck.getAttribute('data-handleid');\n        const connectable = handleToCheck.classList.contains('connectable');\n        const connectableEnd = handleToCheck.classList.contains('connectableend');\n        if (!handleNodeId || !handleType) {\n            return result;\n        }\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId,\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable &&\n            (connectionMode === ConnectionMode.Strict\n                ? (isTarget && handleType === 'source') || (!isTarget && handleType === 'target')\n                : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        result.isValid = isValid && isValidConnection(connection);\n        result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, true);\n    }\n    return result;\n}\nconst XYHandle = {\n    onPointerDown,\n    isValid: isValidHandle,\n};\n\nfunction XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ translateExtent, width, height, zoomStep = 1, pannable = true, zoomable = true, inversePan = false, }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const zoomHandler = (event) => {\n            if (event.sourceEvent.type !== 'wheel' || !panZoom) {\n                return;\n            }\n            const transform = getTransform();\n            const factor = event.sourceEvent.ctrlKey && isMacOs() ? 10 : 1;\n            const pinchDelta = -event.sourceEvent.deltaY *\n                (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *\n                zoomStep;\n            const nextZoom = transform[2] * Math.pow(2, pinchDelta * factor);\n            panZoom.scaleTo(nextZoom);\n        };\n        let panStart = [0, 0];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panStartHandler = (event) => {\n            if (event.sourceEvent.type === 'mousedown' || event.sourceEvent.type === 'touchstart') {\n                panStart = [\n                    event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                    event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n                ];\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panHandler = (event) => {\n            const transform = getTransform();\n            if ((event.sourceEvent.type !== 'mousemove' && event.sourceEvent.type !== 'touchmove') || !panZoom) {\n                return;\n            }\n            const panCurrent = [\n                event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n            ];\n            const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];\n            panStart = panCurrent;\n            const moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);\n            const position = {\n                x: transform[0] - panDelta[0] * moveScale,\n                y: transform[1] - panDelta[1] * moveScale,\n            };\n            const extent = [\n                [0, 0],\n                [width, height],\n            ];\n            panZoom.setViewportConstrained({\n                x: position.x,\n                y: position.y,\n                zoom: transform[2],\n            }, extent, translateExtent);\n        };\n        const zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n            .on('start', panStartHandler)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom', pannable ? panHandler : null)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom.wheel', zoomable ? zoomHandler : null);\n        selection.call(zoomAndPanHandler, {});\n    }\n    function destroy() {\n        selection.on('zoom', null);\n    }\n    return {\n        update,\n        destroy,\n        pointer: d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;\nconst transformToViewport = (transform) => ({\n    x: transform.x,\n    y: transform.y,\n    zoom: transform.k,\n});\nconst viewportToTransform = ({ x, y, zoom }) => d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity.translate(x, y).scale(zoom);\nconst isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\n// taken from d3-ease: https://github.com/d3/d3-ease/blob/main/src/cubic.js\nconst defaultEase = (t) => ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\nconst getD3Transition = (selection, duration = 0, ease = defaultEase, onEnd = () => { }) => {\n    const hasDuration = typeof duration === 'number' && duration > 0;\n    if (!hasDuration) {\n        onEnd();\n    }\n    return hasDuration ? selection.transition().duration(duration).ease(ease).on('end', onEnd) : selection;\n};\nconst wheelDelta = (event) => {\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\n\nfunction createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd, }) {\n    return (event) => {\n        if (isWrappedWithClass(event, noWheelClassName)) {\n            return false;\n        }\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        const currentZoom = d3Selection.property('__zoom').k || 1;\n        // macos sets ctrlKey=true for pinch gesture on a trackpad\n        if (event.ctrlKey && zoomOnPinch) {\n            const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(event);\n            const pinchDelta = wheelDelta(event);\n            const zoom = currentZoom * Math.pow(2, pinchDelta);\n            // @ts-ignore\n            d3Zoom.scaleTo(d3Selection, zoom, point, event);\n            return;\n        }\n        /*\n         * increase scroll speed in firefox\n         * firefox: deltaMode === 1; chrome: deltaMode === 0\n         */\n        const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n        let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n        let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n        // this enables vertical scrolling with shift + scroll on windows\n        if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n            deltaX = event.deltaY * deltaNormalize;\n            deltaY = 0;\n        }\n        d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, \n        // @ts-ignore\n        { internal: true });\n        const nextViewport = transformToViewport(d3Selection.property('__zoom'));\n        clearTimeout(zoomPanValues.panScrollTimeout);\n        /*\n         * for pan on scroll we need to handle the event calls on our own\n         * we can't use the start, zoom and end events from d3-zoom\n         * because start and move gets called on every scroll event and not once at the beginning\n         */\n        if (!zoomPanValues.isPanScrolling) {\n            zoomPanValues.isPanScrolling = true;\n            onPanZoomStart?.(event, nextViewport);\n        }\n        if (zoomPanValues.isPanScrolling) {\n            onPanZoom?.(event, nextViewport);\n            zoomPanValues.panScrollTimeout = setTimeout(() => {\n                onPanZoomEnd?.(event, nextViewport);\n                zoomPanValues.isPanScrolling = false;\n            }, 150);\n        }\n    };\n}\nfunction createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {\n    return function (event, d) {\n        const isWheel = event.type === 'wheel';\n        // we still want to enable pinch zooming even if preventScrolling is set to false\n        const preventZoom = !preventScrolling && isWheel && !event.ctrlKey;\n        const hasNoWheelClass = isWrappedWithClass(event, noWheelClassName);\n        // if user is pinch zooming above a nowheel element, we don't want the browser to zoom\n        if (event.ctrlKey && isWheel && hasNoWheelClass) {\n            event.preventDefault();\n        }\n        if (preventZoom || hasNoWheelClass) {\n            return null;\n        }\n        event.preventDefault();\n        d3ZoomHandler.call(this, event, d);\n    };\n}\nfunction createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        const viewport = transformToViewport(event.transform);\n        // we need to remember it here, because it's always 0 in the \"zoom\" event\n        zoomPanValues.mouseButton = event.sourceEvent?.button || 0;\n        zoomPanValues.isZoomingOrPanning = true;\n        zoomPanValues.prevViewport = viewport;\n        if (event.sourceEvent?.type === 'mousedown') {\n            onDraggingChange(true);\n        }\n        if (onPanZoomStart) {\n            onPanZoomStart?.(event.sourceEvent, viewport);\n        }\n    };\n}\nfunction createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom, }) {\n    return (event) => {\n        zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));\n        if (!event.sourceEvent?.sync) {\n            onTransformChange([event.transform.x, event.transform.y, event.transform.k]);\n        }\n        if (onPanZoom && !event.sourceEvent?.internal) {\n            onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));\n        }\n    };\n}\nfunction createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu, }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        zoomPanValues.isZoomingOrPanning = false;\n        if (onPaneContextMenu &&\n            isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) &&\n            !zoomPanValues.usedRightMouseButton &&\n            event.sourceEvent) {\n            onPaneContextMenu(event.sourceEvent);\n        }\n        zoomPanValues.usedRightMouseButton = false;\n        onDraggingChange(false);\n        if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {\n            const viewport = transformToViewport(event.transform);\n            zoomPanValues.prevViewport = viewport;\n            clearTimeout(zoomPanValues.timerId);\n            zoomPanValues.timerId = setTimeout(() => {\n                onPanZoomEnd?.(event.sourceEvent, viewport);\n            }, \n            // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll\n            panOnScroll ? 150 : 0);\n        }\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, connectionInProgress, }) {\n    return (event) => {\n        const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n        const pinchZoom = zoomOnPinch && event.ctrlKey;\n        const isWheelEvent = event.type === 'wheel';\n        if (event.button === 1 &&\n            event.type === 'mousedown' &&\n            (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {\n            return true;\n        }\n        // if all interactions are disabled, we prevent all zoom events\n        if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n            return false;\n        }\n        // during a selection we prevent all other interactions\n        if (userSelectionActive) {\n            return false;\n        }\n        // we want to disable pinch-zooming while making a connection\n        if (connectionInProgress && !isWheelEvent) {\n            return false;\n        }\n        // if the target element is inside an element with the nowheel class, we prevent zooming\n        if (isWrappedWithClass(event, noWheelClassName) && isWheelEvent) {\n            return false;\n        }\n        // if the target element is inside an element with the nopan class, we prevent panning\n        if (isWrappedWithClass(event, noPanClassName) &&\n            (!isWheelEvent || (panOnScroll && isWheelEvent && !zoomActivationKeyPressed))) {\n            return false;\n        }\n        if (!zoomOnPinch && event.ctrlKey && isWheelEvent) {\n            return false;\n        }\n        if (!zoomOnPinch && event.type === 'touchstart' && event.touches?.length > 1) {\n            event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom\n            return false;\n        }\n        // when there is no scroll handling enabled, we prevent all wheel events\n        if (!zoomScroll && !panOnScroll && !pinchZoom && isWheelEvent) {\n            return false;\n        }\n        // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n        if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {\n            return false;\n        }\n        // if the pane is only movable using allowed clicks\n        if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {\n            return false;\n        }\n        // We only allow right clicks if pan on drag is set to right click\n        const buttonAllowed = (Array.isArray(panOnDrag) && panOnDrag.includes(event.button)) || !event.button || event.button <= 1;\n        // default filter for d3-zoom\n        return (!event.ctrlKey || isWheelEvent) && buttonAllowed;\n    };\n}\n\nfunction XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange, }) {\n    const zoomPanValues = {\n        isZoomingOrPanning: false,\n        usedRightMouseButton: false,\n        prevViewport: { x: 0, y: 0, zoom: 0 },\n        mouseButton: 0,\n        timerId: undefined,\n        panScrollTimeout: undefined,\n        isPanScrolling: false,\n    };\n    const bbox = domNode.getBoundingClientRect();\n    const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n        .clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance)\n        .scaleExtent([minZoom, maxZoom])\n        .translateExtent(translateExtent);\n    const d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode).call(d3ZoomInstance);\n    setViewportConstrained({\n        x: viewport.x,\n        y: viewport.y,\n        zoom: clamp(viewport.zoom, minZoom, maxZoom),\n    }, [\n        [0, 0],\n        [bbox.width, bbox.height],\n    ], translateExtent);\n    const d3ZoomHandler = d3Selection.on('wheel.zoom');\n    const d3DblClickZoomHandler = d3Selection.on('dblclick.zoom');\n    d3ZoomInstance.wheelDelta(wheelDelta);\n    function setTransform(transform, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).transform(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), transform);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    // public functions\n    function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, connectionInProgress, }) {\n        if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {\n            destroy();\n        }\n        const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;\n        const wheelHandler = isPanOnScroll\n            ? createPanOnScrollHandler({\n                zoomPanValues,\n                noWheelClassName,\n                d3Selection,\n                d3Zoom: d3ZoomInstance,\n                panOnScrollMode,\n                panOnScrollSpeed,\n                zoomOnPinch,\n                onPanZoomStart,\n                onPanZoom,\n                onPanZoomEnd,\n            })\n            : createZoomOnScrollHandler({\n                noWheelClassName,\n                preventScrolling,\n                d3ZoomHandler,\n            });\n        d3Selection.on('wheel.zoom', wheelHandler, { passive: false });\n        if (!userSelectionActive) {\n            // pan zoom start\n            const startHandler = createPanZoomStartHandler({\n                zoomPanValues,\n                onDraggingChange,\n                onPanZoomStart,\n            });\n            d3ZoomInstance.on('start', startHandler);\n            // pan zoom\n            const panZoomHandler = createPanZoomHandler({\n                zoomPanValues,\n                panOnDrag,\n                onPaneContextMenu: !!onPaneContextMenu,\n                onPanZoom,\n                onTransformChange,\n            });\n            d3ZoomInstance.on('zoom', panZoomHandler);\n            // pan zoom end\n            const panZoomEndHandler = createPanZoomEndHandler({\n                zoomPanValues,\n                panOnDrag,\n                panOnScroll,\n                onPaneContextMenu,\n                onPanZoomEnd,\n                onDraggingChange,\n            });\n            d3ZoomInstance.on('end', panZoomEndHandler);\n        }\n        const filter = createFilter({\n            zoomActivationKeyPressed,\n            panOnDrag,\n            zoomOnScroll,\n            panOnScroll,\n            zoomOnDoubleClick,\n            zoomOnPinch,\n            userSelectionActive,\n            noPanClassName,\n            noWheelClassName,\n            lib,\n            connectionInProgress,\n        });\n        d3ZoomInstance.filter(filter);\n        /*\n         * We cannot add zoomOnDoubleClick to the filter above because\n         * double tapping on touch screens circumvents the filter and\n         * dblclick.zoom is fired on the selection directly\n         */\n        if (zoomOnDoubleClick) {\n            d3Selection.on('dblclick.zoom', d3DblClickZoomHandler);\n        }\n        else {\n            d3Selection.on('dblclick.zoom', null);\n        }\n    }\n    function destroy() {\n        d3ZoomInstance.on('zoom', null);\n    }\n    async function setViewportConstrained(viewport, extent, translateExtent) {\n        const nextTransform = viewportToTransform(viewport);\n        const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent);\n        if (contrainedTransform) {\n            await setTransform(contrainedTransform);\n        }\n        return new Promise((resolve) => resolve(contrainedTransform));\n    }\n    async function setViewport(viewport, options) {\n        const nextTransform = viewportToTransform(viewport);\n        await setTransform(nextTransform, options);\n        return new Promise((resolve) => resolve(nextTransform));\n    }\n    function syncViewport(viewport) {\n        if (d3Selection) {\n            const nextTransform = viewportToTransform(viewport);\n            const currentTransform = d3Selection.property('__zoom');\n            if (currentTransform.k !== viewport.zoom ||\n                currentTransform.x !== viewport.x ||\n                currentTransform.y !== viewport.y) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: true });\n            }\n        }\n    }\n    function getViewport() {\n        const transform = d3Selection ? (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(d3Selection.node()) : { x: 0, y: 0, k: 1 };\n        return { x: transform.x, y: transform.y, zoom: transform.k };\n    }\n    function scaleTo(zoom, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).scaleTo(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), zoom);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function scaleBy(factor, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).scaleBy(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), factor);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function setScaleExtent(scaleExtent) {\n        d3ZoomInstance?.scaleExtent(scaleExtent);\n    }\n    function setTranslateExtent(translateExtent) {\n        d3ZoomInstance?.translateExtent(translateExtent);\n    }\n    function setClickDistance(distance) {\n        const validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;\n        d3ZoomInstance?.clickDistance(validDistance);\n    }\n    return {\n        update,\n        destroy,\n        setViewport,\n        setViewportConstrained,\n        getViewport,\n        scaleTo,\n        scaleBy,\n        setScaleExtent,\n        setTranslateExtent,\n        syncViewport,\n        setClickDistance,\n    };\n}\n\n/**\n * Used to determine the variant of the resize control\n *\n * @public\n */\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\nconst XY_RESIZER_HANDLE_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst XY_RESIZER_LINE_POSITIONS = ['top', 'right', 'bottom', 'left'];\n\n/**\n * Get all connecting edges for a given set of nodes\n * @param width - new width of the node\n * @param prevWidth - previous width of the node\n * @param height - new height of the node\n * @param prevHeight - previous height of the node\n * @param affectsX - whether to invert the resize direction for the x axis\n * @param affectsY - whether to invert the resize direction for the y axis\n * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease\n */\nfunction getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY, }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && affectsX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && affectsY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n/**\n * Parses the control position that is being dragged to dimensions that are being resized\n * @param controlPosition - position of the control that is being dragged\n * @returns isHorizontal, isVertical, affectsX, affectsY,\n */\nfunction getControlDirection(controlPosition) {\n    const isHorizontal = controlPosition.includes('right') || controlPosition.includes('left');\n    const isVertical = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const affectsX = controlPosition.includes('left');\n    const affectsY = controlPosition.includes('top');\n    return {\n        isHorizontal,\n        isVertical,\n        affectsX,\n        affectsY,\n    };\n}\nfunction getLowerExtentClamp(lowerExtent, lowerBound) {\n    return Math.max(0, lowerBound - lowerExtent);\n}\nfunction getUpperExtentClamp(upperExtent, upperBound) {\n    return Math.max(0, upperExtent - upperBound);\n}\nfunction getSizeClamp(size, minSize, maxSize) {\n    return Math.max(0, minSize - size, size - maxSize);\n}\nfunction xor(a, b) {\n    return a ? !b : b;\n}\n/**\n * Calculates new width & height and x & y of node after resize based on pointer position\n * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,\n * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed\n * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes\n * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!\n * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the\n * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,\n * the resize amount is always kept in distX & distY amount (the distance in mouse movement)\n * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.\n * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],\n * then calculating the restrictions as usual\n * @param startValues - starting values of resize\n * @param controlDirection - dimensions affected by the resize\n * @param pointerPosition - the current pointer position corrected for snapping\n * @param boundaries - minimum and maximum dimensions of the node\n * @param keepAspectRatio - prevent changes of asprect ratio\n * @returns x, y, width and height of the node after resize\n */\nfunction getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {\n    let { affectsX, affectsY } = controlDirection;\n    const { isHorizontal, isVertical } = controlDirection;\n    const isDiagonal = isHorizontal && isVertical;\n    const { xSnapped, ySnapped } = pointerPosition;\n    const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;\n    const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;\n    let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);\n    let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);\n    const newWidth = startWidth + (affectsX ? -distX : distX);\n    const newHeight = startHeight + (affectsY ? -distY : distY);\n    const originOffsetX = -nodeOrigin[0] * startWidth;\n    const originOffsetY = -nodeOrigin[1] * startHeight;\n    // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize\n    let clampX = getSizeClamp(newWidth, minWidth, maxWidth);\n    let clampY = getSizeClamp(newHeight, minHeight, maxHeight);\n    // Check if extent is restricting the resize\n    if (extent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);\n        }\n        else if (!affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);\n        }\n        if (affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);\n        }\n        else if (!affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the child extent is restricting the resize\n    if (childExtent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);\n        }\n        else if (!affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);\n        }\n        if (affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);\n        }\n        else if (!affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the aspect ratio resizing of the other side is restricting the resize\n    if (keepAspectRatio) {\n        if (isHorizontal) {\n            // Check if the max dimensions might be restricting the resize\n            const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;\n            clampX = Math.max(clampX, aspectHeightClamp);\n            // Check if the extent is restricting the resize\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) *\n                            aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n            // Check if the child extent is restricting the resize\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n        }\n        // Do the same thing for vertical resizing\n        if (isVertical) {\n            const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;\n            clampY = Math.max(clampY, aspectWidthClamp);\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) /\n                            aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n        }\n    }\n    distY = distY + (distY < 0 ? clampY : -clampY);\n    distX = distX + (distX < 0 ? clampX : -clampX);\n    if (keepAspectRatio) {\n        if (isDiagonal) {\n            if (newWidth > newHeight * aspectRatio) {\n                distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;\n            }\n            else {\n                distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;\n            }\n        }\n        else {\n            if (isHorizontal) {\n                distY = distX / aspectRatio;\n                affectsY = affectsX;\n            }\n            else {\n                distX = distY * aspectRatio;\n                affectsX = affectsY;\n            }\n        }\n    }\n    const x = affectsX ? startX + distX : startX;\n    const y = affectsY ? startY + distY : startY;\n    return {\n        width: startWidth + (affectsX ? -distX : distX),\n        height: startHeight + (affectsY ? -distY : distY),\n        x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,\n        y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y,\n    };\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction nodeToParentExtent(node) {\n    return [\n        [0, 0],\n        [node.measured.width, node.measured.height],\n    ];\n}\nfunction nodeToChildExtent(child, parent, nodeOrigin) {\n    const x = parent.position.x + child.position.x;\n    const y = parent.position.y + child.position.y;\n    const width = child.measured.width ?? 0;\n    const height = child.measured.height ?? 0;\n    const originOffsetX = nodeOrigin[0] * width;\n    const originOffsetY = nodeOrigin[1] * height;\n    return [\n        [x - originOffsetX, y - originOffsetY],\n        [x + width - originOffsetX, y + height - originOffsetY],\n    ];\n}\nfunction XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ controlPosition, boundaries, keepAspectRatio, resizeDirection, onResizeStart, onResize, onResizeEnd, shouldResize, }) {\n        let prevValues = { ...initPrevValues };\n        let startValues = { ...initStartValues };\n        const controlDirection = getControlDirection(controlPosition);\n        let node = undefined;\n        let containerBounds = null;\n        let childNodes = [];\n        let parentNode = undefined; // Needed to fix expandParent\n        let parentExtent = undefined;\n        let childExtent = undefined;\n        // we only want to trigger onResizeEnd if onResize was actually called\n        let resizeDetected = false;\n        const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .on('start', (event) => {\n            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();\n            node = nodeLookup.get(nodeId);\n            if (!node) {\n                return;\n            }\n            containerBounds = paneDomNode?.getBoundingClientRect() ?? null;\n            const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            prevValues = {\n                width: node.measured.width ?? 0,\n                height: node.measured.height ?? 0,\n                x: node.position.x ?? 0,\n                y: node.position.y ?? 0,\n            };\n            startValues = {\n                ...prevValues,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.width / prevValues.height,\n            };\n            parentNode = undefined;\n            if (node.parentId && (node.extent === 'parent' || node.expandParent)) {\n                parentNode = nodeLookup.get(node.parentId);\n                parentExtent = parentNode && node.extent === 'parent' ? nodeToParentExtent(parentNode) : undefined;\n            }\n            /*\n             * Collect all child nodes to correct their relative positions when top/left changes\n             * Determine largest minimal extent the parent node is allowed to resize to\n             */\n            childNodes = [];\n            childExtent = undefined;\n            for (const [childId, child] of nodeLookup) {\n                if (child.parentId === nodeId) {\n                    childNodes.push({\n                        id: childId,\n                        position: { ...child.position },\n                        extent: child.extent,\n                    });\n                    if (child.extent === 'parent' || child.expandParent) {\n                        const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);\n                        if (childExtent) {\n                            childExtent = [\n                                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],\n                                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])],\n                            ];\n                        }\n                        else {\n                            childExtent = extent;\n                        }\n                    }\n                }\n            }\n            onResizeStart?.(event, { ...prevValues });\n        })\n            .on('drag', (event) => {\n            const { transform, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();\n            const pointerPosition = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            const childChanges = [];\n            if (!node) {\n                return;\n            }\n            const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;\n            const change = {};\n            const nodeOrigin = node.origin ?? storeNodeOrigin;\n            const { width, height, x, y } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent);\n            const isWidthChange = width !== prevWidth;\n            const isHeightChange = height !== prevHeight;\n            const isXPosChange = x !== prevX && isWidthChange;\n            const isYPosChange = y !== prevY && isHeightChange;\n            if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {\n                return;\n            }\n            if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {\n                change.x = isXPosChange ? x : prevValues.x;\n                change.y = isYPosChange ? y : prevValues.y;\n                prevValues.x = change.x;\n                prevValues.y = change.y;\n                /*\n                 * when top/left changes, correct the relative positions of child nodes\n                 * so that they stay in the same position\n                 */\n                if (childNodes.length > 0) {\n                    const xChange = x - prevX;\n                    const yChange = y - prevY;\n                    for (const childNode of childNodes) {\n                        childNode.position = {\n                            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),\n                            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight),\n                        };\n                        childChanges.push(childNode);\n                    }\n                }\n            }\n            if (isWidthChange || isHeightChange) {\n                change.width =\n                    isWidthChange && (!resizeDirection || resizeDirection === 'horizontal') ? width : prevValues.width;\n                change.height =\n                    isHeightChange && (!resizeDirection || resizeDirection === 'vertical') ? height : prevValues.height;\n                prevValues.width = change.width;\n                prevValues.height = change.height;\n            }\n            // Fix expandParent when resizing from top/left\n            if (parentNode && node.expandParent) {\n                const xLimit = nodeOrigin[0] * (change.width ?? 0);\n                if (change.x && change.x < xLimit) {\n                    prevValues.x = xLimit;\n                    startValues.x = startValues.x - (change.x - xLimit);\n                }\n                const yLimit = nodeOrigin[1] * (change.height ?? 0);\n                if (change.y && change.y < yLimit) {\n                    prevValues.y = yLimit;\n                    startValues.y = startValues.y - (change.y - yLimit);\n                }\n            }\n            const direction = getResizeDirection({\n                width: prevValues.width,\n                prevWidth,\n                height: prevValues.height,\n                prevHeight,\n                affectsX: controlDirection.affectsX,\n                affectsY: controlDirection.affectsY,\n            });\n            const nextValues = { ...prevValues, direction };\n            const callResize = shouldResize?.(event, nextValues);\n            if (callResize === false) {\n                return;\n            }\n            resizeDetected = true;\n            onResize?.(event, nextValues);\n            onChange(change, childChanges);\n        })\n            .on('end', (event) => {\n            if (!resizeDetected) {\n                return;\n            }\n            onResizeEnd?.(event, { ...prevValues });\n            onEnd?.({ ...prevValues });\n            resizeDetected = false;\n        });\n        selection.call(dragHandler);\n    }\n    function destroy() {\n        selection.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9zeXN0ZW0vZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ2dCO0FBQ2E7QUFDRTs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQsd0NBQXdDLEtBQUs7QUFDN0MsNkJBQTZCLGdDQUFnQyxpQ0FBaUMsWUFBWSxjQUFjLHNEQUFzRCxjQUFjLEdBQUc7QUFDL0w7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRCx1Q0FBdUMsR0FBRztBQUMxQyx3R0FBd0csSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQiw0QkFBNEIsVUFBVSxxQkFBcUIsRUFBRSxPQUFPLEVBQUU7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xELHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXktaXQtcmlnaHQvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9zeXN0ZW0vZGlzdC9lc20vaW5kZXguanM/NjkyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkcmFnIH0gZnJvbSAnZDMtZHJhZyc7XG5pbXBvcnQgeyBzZWxlY3QsIHBvaW50ZXIgfSBmcm9tICdkMy1zZWxlY3Rpb24nO1xuaW1wb3J0IHsgem9vbSwgem9vbUlkZW50aXR5LCB6b29tVHJhbnNmb3JtIH0gZnJvbSAnZDMtem9vbSc7XG5pbXBvcnQgeyBpbnRlcnBvbGF0ZVpvb20sIGludGVycG9sYXRlIH0gZnJvbSAnZDMtaW50ZXJwb2xhdGUnO1xuXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xuICAgIGVycm9yMDAxOiAoKSA9PiAnW1JlYWN0IEZsb3ddOiBTZWVtcyBsaWtlIHlvdSBoYXZlIG5vdCB1c2VkIHp1c3RhbmQgcHJvdmlkZXIgYXMgYW4gYW5jZXN0b3IuIEhlbHA6IGh0dHBzOi8vcmVhY3RmbG93LmRldi9lcnJvciMwMDEnLFxuICAgIGVycm9yMDAyOiAoKSA9PiBcIkl0IGxvb2tzIGxpa2UgeW91J3ZlIGNyZWF0ZWQgYSBuZXcgbm9kZVR5cGVzIG9yIGVkZ2VUeXBlcyBvYmplY3QuIElmIHRoaXMgd2Fzbid0IG9uIHB1cnBvc2UgcGxlYXNlIGRlZmluZSB0aGUgbm9kZVR5cGVzL2VkZ2VUeXBlcyBvdXRzaWRlIG9mIHRoZSBjb21wb25lbnQgb3IgbWVtb2l6ZSB0aGVtLlwiLFxuICAgIGVycm9yMDAzOiAobm9kZVR5cGUpID0+IGBOb2RlIHR5cGUgXCIke25vZGVUeXBlfVwiIG5vdCBmb3VuZC4gVXNpbmcgZmFsbGJhY2sgdHlwZSBcImRlZmF1bHRcIi5gLFxuICAgIGVycm9yMDA0OiAoKSA9PiAnVGhlIFJlYWN0IEZsb3cgcGFyZW50IGNvbnRhaW5lciBuZWVkcyBhIHdpZHRoIGFuZCBhIGhlaWdodCB0byByZW5kZXIgdGhlIGdyYXBoLicsXG4gICAgZXJyb3IwMDU6ICgpID0+ICdPbmx5IGNoaWxkIG5vZGVzIGNhbiB1c2UgYSBwYXJlbnQgZXh0ZW50LicsXG4gICAgZXJyb3IwMDY6ICgpID0+IFwiQ2FuJ3QgY3JlYXRlIGVkZ2UuIEFuIGVkZ2UgbmVlZHMgYSBzb3VyY2UgYW5kIGEgdGFyZ2V0LlwiLFxuICAgIGVycm9yMDA3OiAoaWQpID0+IGBUaGUgb2xkIGVkZ2Ugd2l0aCBpZD0ke2lkfSBkb2VzIG5vdCBleGlzdC5gLFxuICAgIGVycm9yMDA5OiAodHlwZSkgPT4gYE1hcmtlciB0eXBlIFwiJHt0eXBlfVwiIGRvZXNuJ3QgZXhpc3QuYCxcbiAgICBlcnJvcjAwODogKGhhbmRsZVR5cGUsIHsgaWQsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0SGFuZGxlIH0pID0+IGBDb3VsZG4ndCBjcmVhdGUgZWRnZSBmb3IgJHtoYW5kbGVUeXBlfSBoYW5kbGUgaWQ6IFwiJHtoYW5kbGVUeXBlID09PSAnc291cmNlJyA/IHNvdXJjZUhhbmRsZSA6IHRhcmdldEhhbmRsZX1cIiwgZWRnZSBpZDogJHtpZH0uYCxcbiAgICBlcnJvcjAxMDogKCkgPT4gJ0hhbmRsZTogTm8gbm9kZSBpZCBmb3VuZC4gTWFrZSBzdXJlIHRvIG9ubHkgdXNlIGEgSGFuZGxlIGluc2lkZSBhIGN1c3RvbSBOb2RlLicsXG4gICAgZXJyb3IwMTE6IChlZGdlVHlwZSkgPT4gYEVkZ2UgdHlwZSBcIiR7ZWRnZVR5cGV9XCIgbm90IGZvdW5kLiBVc2luZyBmYWxsYmFjayB0eXBlIFwiZGVmYXVsdFwiLmAsXG4gICAgZXJyb3IwMTI6IChpZCkgPT4gYE5vZGUgd2l0aCBpZCBcIiR7aWR9XCIgZG9lcyBub3QgZXhpc3QsIGl0IG1heSBoYXZlIGJlZW4gcmVtb3ZlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBub2RlIGlzIGRlbGV0ZWQgYmVmb3JlIHRoZSBcIm9uTm9kZUNsaWNrXCIgaGFuZGxlciBpcyBjYWxsZWQuYCxcbiAgICBlcnJvcjAxMzogKGxpYiA9ICdyZWFjdCcpID0+IGBJdCBzZWVtcyB0aGF0IHlvdSBoYXZlbid0IGxvYWRlZCB0aGUgc3R5bGVzLiBQbGVhc2UgaW1wb3J0ICdAeHlmbG93LyR7bGlifS9kaXN0L3N0eWxlLmNzcycgb3IgYmFzZS5jc3MgdG8gbWFrZSBzdXJlIGV2ZXJ5dGhpbmcgaXMgd29ya2luZyBwcm9wZXJseS5gLFxuICAgIGVycm9yMDE0OiAoKSA9PiAndXNlTm9kZUNvbm5lY3Rpb25zOiBObyBub2RlIElEIGZvdW5kLiBDYWxsIHVzZU5vZGVDb25uZWN0aW9ucyBpbnNpZGUgYSBjdXN0b20gTm9kZSBvciBwcm92aWRlIGEgbm9kZSBJRC4nLFxuICAgIGVycm9yMDE1OiAoKSA9PiAnSXQgc2VlbXMgdGhhdCB5b3UgYXJlIHRyeWluZyB0byBkcmFnIGEgbm9kZSB0aGF0IGlzIG5vdCBpbml0aWFsaXplZC4gUGxlYXNlIHVzZSBvbk5vZGVzQ2hhbmdlIGFzIGV4cGxhaW5lZCBpbiB0aGUgZG9jcy4nLFxufTtcbmNvbnN0IGluZmluaXRlRXh0ZW50ID0gW1xuICAgIFtOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sXG4gICAgW051bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSxcbl07XG5jb25zdCBlbGVtZW50U2VsZWN0aW9uS2V5cyA9IFsnRW50ZXInLCAnICcsICdFc2NhcGUnXTtcbmNvbnN0IGRlZmF1bHRBcmlhTGFiZWxDb25maWcgPSB7XG4gICAgJ25vZGUuYTExeURlc2NyaXB0aW9uLmRlZmF1bHQnOiAnUHJlc3MgZW50ZXIgb3Igc3BhY2UgdG8gc2VsZWN0IGEgbm9kZS4gUHJlc3MgZGVsZXRlIHRvIHJlbW92ZSBpdCBhbmQgZXNjYXBlIHRvIGNhbmNlbC4nLFxuICAgICdub2RlLmExMXlEZXNjcmlwdGlvbi5rZXlib2FyZERpc2FibGVkJzogJ1ByZXNzIGVudGVyIG9yIHNwYWNlIHRvIHNlbGVjdCBhIG5vZGUuIFlvdSBjYW4gdGhlbiB1c2UgdGhlIGFycm93IGtleXMgdG8gbW92ZSB0aGUgbm9kZSBhcm91bmQuIFByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgYW5kIGVzY2FwZSB0byBjYW5jZWwuJyxcbiAgICAnbm9kZS5hMTF5RGVzY3JpcHRpb24uYXJpYUxpdmVNZXNzYWdlJzogKHsgZGlyZWN0aW9uLCB4LCB5IH0pID0+IGBNb3ZlZCBzZWxlY3RlZCBub2RlICR7ZGlyZWN0aW9ufS4gTmV3IHBvc2l0aW9uLCB4OiAke3h9LCB5OiAke3l9YCxcbiAgICAnZWRnZS5hMTF5RGVzY3JpcHRpb24uZGVmYXVsdCc6ICdQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYW4gZWRnZS4gWW91IGNhbiB0aGVuIHByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgb3IgZXNjYXBlIHRvIGNhbmNlbC4nLFxuICAgIC8vIENvbnRyb2wgZWxlbWVudHNcbiAgICAnY29udHJvbHMuYXJpYUxhYmVsJzogJ0NvbnRyb2wgUGFuZWwnLFxuICAgICdjb250cm9scy56b29tSW4uYXJpYUxhYmVsJzogJ1pvb20gSW4nLFxuICAgICdjb250cm9scy56b29tT3V0LmFyaWFMYWJlbCc6ICdab29tIE91dCcsXG4gICAgJ2NvbnRyb2xzLmZpdFZpZXcuYXJpYUxhYmVsJzogJ0ZpdCBWaWV3JyxcbiAgICAnY29udHJvbHMuaW50ZXJhY3RpdmUuYXJpYUxhYmVsJzogJ1RvZ2dsZSBJbnRlcmFjdGl2aXR5JyxcbiAgICAvLyBNaW5pIG1hcFxuICAgICdtaW5pbWFwLmFyaWFMYWJlbCc6ICdNaW5pIE1hcCcsXG4gICAgLy8gSGFuZGxlXG4gICAgJ2hhbmRsZS5hcmlhTGFiZWwnOiAnSGFuZGxlJyxcbn07XG5cbi8qKlxuICogVGhlIGBDb25uZWN0aW9uTW9kZWAgaXMgdXNlZCB0byBzZXQgdGhlIG1vZGUgb2YgY29ubmVjdGlvbiBiZXR3ZWVuIG5vZGVzLlxuICogVGhlIGBTdHJpY3RgIG1vZGUgaXMgdGhlIGRlZmF1bHQgb25lIGFuZCBvbmx5IGFsbG93cyBzb3VyY2UgdG8gdGFyZ2V0IGVkZ2VzLlxuICogYExvb3NlYCBtb2RlIGFsbG93cyBzb3VyY2UgdG8gc291cmNlIGFuZCB0YXJnZXQgdG8gdGFyZ2V0IGVkZ2VzIGFzIHdlbGwuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgQ29ubmVjdGlvbk1vZGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25Nb2RlKSB7XG4gICAgQ29ubmVjdGlvbk1vZGVbXCJTdHJpY3RcIl0gPSBcInN0cmljdFwiO1xuICAgIENvbm5lY3Rpb25Nb2RlW1wiTG9vc2VcIl0gPSBcImxvb3NlXCI7XG59KShDb25uZWN0aW9uTW9kZSB8fCAoQ29ubmVjdGlvbk1vZGUgPSB7fSkpO1xuLyoqXG4gKiBUaGlzIGVudW0gaXMgdXNlZCB0byBzZXQgdGhlIGRpZmZlcmVudCBtb2RlcyBvZiBwYW5uaW5nIHRoZSB2aWV3cG9ydCB3aGVuIHRoZVxuICogdXNlciBzY3JvbGxzLiBUaGUgYEZyZWVgIG1vZGUgYWxsb3dzIHRoZSB1c2VyIHRvIHBhbiBpbiBhbnkgZGlyZWN0aW9uIGJ5IHNjcm9sbGluZ1xuICogd2l0aCBhIGRldmljZSBsaWtlIGEgdHJhY2twYWQuIFRoZSBgVmVydGljYWxgIGFuZCBgSG9yaXpvbnRhbGAgbW9kZXMgcmVzdHJpY3RcbiAqIHNjcm9sbCBwYW5uaW5nIHRvIG9ubHkgdGhlIHZlcnRpY2FsIG9yIGhvcml6b250YWwgYXhpcywgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFBhbk9uU2Nyb2xsTW9kZTtcbihmdW5jdGlvbiAoUGFuT25TY3JvbGxNb2RlKSB7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiRnJlZVwiXSA9IFwiZnJlZVwiO1xuICAgIFBhbk9uU2Nyb2xsTW9kZVtcIlZlcnRpY2FsXCJdID0gXCJ2ZXJ0aWNhbFwiO1xuICAgIFBhbk9uU2Nyb2xsTW9kZVtcIkhvcml6b250YWxcIl0gPSBcImhvcml6b250YWxcIjtcbn0pKFBhbk9uU2Nyb2xsTW9kZSB8fCAoUGFuT25TY3JvbGxNb2RlID0ge30pKTtcbnZhciBTZWxlY3Rpb25Nb2RlO1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25Nb2RlKSB7XG4gICAgU2VsZWN0aW9uTW9kZVtcIlBhcnRpYWxcIl0gPSBcInBhcnRpYWxcIjtcbiAgICBTZWxlY3Rpb25Nb2RlW1wiRnVsbFwiXSA9IFwiZnVsbFwiO1xufSkoU2VsZWN0aW9uTW9kZSB8fCAoU2VsZWN0aW9uTW9kZSA9IHt9KSk7XG5jb25zdCBpbml0aWFsQ29ubmVjdGlvbiA9IHtcbiAgICBpblByb2dyZXNzOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBudWxsLFxuICAgIGZyb206IG51bGwsXG4gICAgZnJvbUhhbmRsZTogbnVsbCxcbiAgICBmcm9tUG9zaXRpb246IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG86IG51bGwsXG4gICAgdG9IYW5kbGU6IG51bGwsXG4gICAgdG9Qb3NpdGlvbjogbnVsbCxcbiAgICB0b05vZGU6IG51bGwsXG59O1xuXG4vKipcbiAqIElmIHlvdSBzZXQgdGhlIGBjb25uZWN0aW9uTGluZVR5cGVgIHByb3Agb24geW91ciBbYDxSZWFjdEZsb3cgLz5gXSgvYXBpLXJlZmVyZW5jZS9yZWFjdC1mbG93I2Nvbm5lY3Rpb24tY29ubmVjdGlvbkxpbmVUeXBlKVxuICpjb21wb25lbnQsIGl0IHdpbGwgZGljdGF0ZSB0aGUgc3R5bGUgb2YgY29ubmVjdGlvbiBsaW5lIHJlbmRlcmVkIHdoZW4gY3JlYXRpbmdcbiAqbmV3IGVkZ2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAcmVtYXJrcyBJZiB5b3UgY2hvb3NlIHRvIHJlbmRlciBhIGN1c3RvbSBjb25uZWN0aW9uIGxpbmUgY29tcG9uZW50LCB0aGlzIHZhbHVlIHdpbGwgYmVcbiAqcGFzc2VkIHRvIHlvdXIgY29tcG9uZW50IGFzIHBhcnQgb2YgaXRzIFtgQ29ubmVjdGlvbkxpbmVDb21wb25lbnRQcm9wc2BdKC9hcGktcmVmZXJlbmNlL3R5cGVzL2Nvbm5lY3Rpb24tbGluZS1jb21wb25lbnQtcHJvcHMpLlxuICovXG52YXIgQ29ubmVjdGlvbkxpbmVUeXBlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uTGluZVR5cGUpIHtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJCZXppZXJcIl0gPSBcImRlZmF1bHRcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTdHJhaWdodFwiXSA9IFwic3RyYWlnaHRcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTdGVwXCJdID0gXCJzdGVwXCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU21vb3RoU3RlcFwiXSA9IFwic21vb3Roc3RlcFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlNpbXBsZUJlemllclwiXSA9IFwic2ltcGxlYmV6aWVyXCI7XG59KShDb25uZWN0aW9uTGluZVR5cGUgfHwgKENvbm5lY3Rpb25MaW5lVHlwZSA9IHt9KSk7XG4vKipcbiAqIEVkZ2VzIG1heSBvcHRpb25hbGx5IGhhdmUgYSBtYXJrZXIgb24gZWl0aGVyIGVuZC4gVGhlIE1hcmtlclR5cGUgdHlwZSBlbnVtZXJhdGVzXG4gKiB0aGUgb3B0aW9ucyBhdmFpbGFibGUgdG8geW91IHdoZW4gY29uZmlndXJpbmcgYSBnaXZlbiBtYXJrZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgTWFya2VyVHlwZTtcbihmdW5jdGlvbiAoTWFya2VyVHlwZSkge1xuICAgIE1hcmtlclR5cGVbXCJBcnJvd1wiXSA9IFwiYXJyb3dcIjtcbiAgICBNYXJrZXJUeXBlW1wiQXJyb3dDbG9zZWRcIl0gPSBcImFycm93Y2xvc2VkXCI7XG59KShNYXJrZXJUeXBlIHx8IChNYXJrZXJUeXBlID0ge30pKTtcblxuLyoqXG4gKiBXaGlsZSBbYFBhbmVsUG9zaXRpb25gXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9wYW5lbC1wb3NpdGlvbikgY2FuIGJlIHVzZWQgdG8gcGxhY2UgYVxuICogY29tcG9uZW50IGluIHRoZSBjb3JuZXJzIG9mIGEgY29udGFpbmVyLCB0aGUgYFBvc2l0aW9uYCBlbnVtIGlzIGxlc3MgcHJlY2lzZSBhbmQgdXNlZFxuICogcHJpbWFyaWx5IGluIHJlbGF0aW9uIHRvIGVkZ2VzIGFuZCBoYW5kbGVzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFBvc2l0aW9uO1xuKGZ1bmN0aW9uIChQb3NpdGlvbikge1xuICAgIFBvc2l0aW9uW1wiTGVmdFwiXSA9IFwibGVmdFwiO1xuICAgIFBvc2l0aW9uW1wiVG9wXCJdID0gXCJ0b3BcIjtcbiAgICBQb3NpdGlvbltcIlJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICAgIFBvc2l0aW9uW1wiQm90dG9tXCJdID0gXCJib3R0b21cIjtcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XG5jb25zdCBvcHBvc2l0ZVBvc2l0aW9uID0ge1xuICAgIFtQb3NpdGlvbi5MZWZ0XTogUG9zaXRpb24uUmlnaHQsXG4gICAgW1Bvc2l0aW9uLlJpZ2h0XTogUG9zaXRpb24uTGVmdCxcbiAgICBbUG9zaXRpb24uVG9wXTogUG9zaXRpb24uQm90dG9tLFxuICAgIFtQb3NpdGlvbi5Cb3R0b21dOiBQb3NpdGlvbi5Ub3AsXG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBhcmVDb25uZWN0aW9uTWFwc0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYSB8fCAhYiB8fCBhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghYS5zaXplICYmICFiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGEua2V5cygpKSB7XG4gICAgICAgIGlmICghYi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXZSBjYWxsIHRoZSBjYWxsYmFjayBmb3IgYWxsIGNvbm5lY3Rpb25zIGluIGEgdGhhdCBhcmUgbm90IGluIGJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShhLCBiLCBjYikge1xuICAgIGlmICghY2IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaWZmID0gW107XG4gICAgYS5mb3JFYWNoKChjb25uZWN0aW9uLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKCFiPy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgZGlmZi5wdXNoKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRpZmYubGVuZ3RoKSB7XG4gICAgICAgIGNiKGRpZmYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbm5lY3Rpb25TdGF0dXMoaXNWYWxpZCkge1xuICAgIHJldHVybiBpc1ZhbGlkID09PSBudWxsID8gbnVsbCA6IGlzVmFsaWQgPyAndmFsaWQnIDogJ2ludmFsaWQnO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgdXNhYmxlIGFzIGFuIEVkZ2VcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBFZGdlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIEVkZ2VcbiAqL1xuY29uc3QgaXNFZGdlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ3NvdXJjZScgaW4gZWxlbWVudCAmJiAndGFyZ2V0JyBpbiBlbGVtZW50O1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzYWJsZSBhcyBhIE5vZGVcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBOb2RlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIE5vZGVcbiAqL1xuY29uc3QgaXNOb2RlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ3Bvc2l0aW9uJyBpbiBlbGVtZW50ICYmICEoJ3NvdXJjZScgaW4gZWxlbWVudCkgJiYgISgndGFyZ2V0JyBpbiBlbGVtZW50KTtcbmNvbnN0IGlzSW50ZXJuYWxOb2RlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ2ludGVybmFscycgaW4gZWxlbWVudCAmJiAhKCdzb3VyY2UnIGluIGVsZW1lbnQpICYmICEoJ3RhcmdldCcgaW4gZWxlbWVudCk7XG4vKipcbiAqIFRoaXMgdXRpbCBpcyB1c2VkIHRvIHRlbGwgeW91IHdoYXQgbm9kZXMsIGlmIGFueSwgYXJlIGNvbm5lY3RlZCB0byB0aGUgZ2l2ZW4gbm9kZVxuICogYXMgdGhlIF90YXJnZXRfIG9mIGFuIGVkZ2UuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGdldCB0aGUgY29ubmVjdGVkIG5vZGVzIGZyb20uXG4gKiBAcGFyYW0gbm9kZXMgLSBUaGUgYXJyYXkgb2YgYWxsIG5vZGVzLlxuICogQHBhcmFtIGVkZ2VzIC0gVGhlIGFycmF5IG9mIGFsbCBlZGdlcy5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIHRoYXQgYXJlIGNvbm5lY3RlZCBvdmVyIGVkZ2VzIHdoZXJlIHRoZSBzb3VyY2UgaXMgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKmltcG9ydCB7IGdldE91dGdvZXJzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtdO1xuICpjb25zdCBlZGdlcyA9IFtdO1xuICpcbiAqY29uc3Qgb3V0Z29lcnMgPSBnZXRPdXRnb2VycyhcbiAqICB7IGlkOiAnMScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSwgZGF0YTogeyBsYWJlbDogJ25vZGUnIH0gfSxcbiAqICBub2RlcyxcbiAqICBlZGdlcyxcbiAqKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldE91dGdvZXJzID0gKG5vZGUsIG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGlmICghbm9kZS5pZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IG91dGdvZXJJZHMgPSBuZXcgU2V0KCk7XG4gICAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICBpZiAoZWRnZS5zb3VyY2UgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgIG91dGdvZXJJZHMuYWRkKGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKG4pID0+IG91dGdvZXJJZHMuaGFzKG4uaWQpKTtcbn07XG4vKipcbiAqIFRoaXMgdXRpbCBpcyB1c2VkIHRvIHRlbGwgeW91IHdoYXQgbm9kZXMsIGlmIGFueSwgYXJlIGNvbm5lY3RlZCB0byB0aGUgZ2l2ZW4gbm9kZVxuICogYXMgdGhlIF9zb3VyY2VfIG9mIGFuIGVkZ2UuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGdldCB0aGUgY29ubmVjdGVkIG5vZGVzIGZyb20uXG4gKiBAcGFyYW0gbm9kZXMgLSBUaGUgYXJyYXkgb2YgYWxsIG5vZGVzLlxuICogQHBhcmFtIGVkZ2VzIC0gVGhlIGFycmF5IG9mIGFsbCBlZGdlcy5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIHRoYXQgYXJlIGNvbm5lY3RlZCBvdmVyIGVkZ2VzIHdoZXJlIHRoZSB0YXJnZXQgaXMgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKmltcG9ydCB7IGdldEluY29tZXJzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtdO1xuICpjb25zdCBlZGdlcyA9IFtdO1xuICpcbiAqY29uc3QgaW5jb21lcnMgPSBnZXRJbmNvbWVycyhcbiAqICB7IGlkOiAnMScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSwgZGF0YTogeyBsYWJlbDogJ25vZGUnIH0gfSxcbiAqICBub2RlcyxcbiAqICBlZGdlcyxcbiAqKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldEluY29tZXJzID0gKG5vZGUsIG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGlmICghbm9kZS5pZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGluY29tZXJzSWRzID0gbmV3IFNldCgpO1xuICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgICAgaWYgKGVkZ2UudGFyZ2V0ID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICBpbmNvbWVyc0lkcy5hZGQoZWRnZS5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobikgPT4gaW5jb21lcnNJZHMuaGFzKG4uaWQpKTtcbn07XG5jb25zdCBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUub3JpZ2luID8/IG5vZGVPcmlnaW47XG4gICAgY29uc3Qgb2Zmc2V0WCA9IHdpZHRoICogb3JpZ2luWzBdO1xuICAgIGNvbnN0IG9mZnNldFkgPSBoZWlnaHQgKiBvcmlnaW5bMV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogbm9kZS5wb3NpdGlvbi54IC0gb2Zmc2V0WCxcbiAgICAgICAgeTogbm9kZS5wb3NpdGlvbi55IC0gb2Zmc2V0WSxcbiAgICB9O1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IHRoYXQgY29udGFpbnMgYWxsIHRoZSBnaXZlbiBub2RlcyBpbiBhbiBhcnJheS4gVGhpcyBjYW5cbiAqIGJlIHVzZWZ1bCB3aGVuIGNvbWJpbmVkIHdpdGggW2BnZXRWaWV3cG9ydEZvckJvdW5kc2BdKC9hcGktcmVmZXJlbmNlL3V0aWxzL2dldC12aWV3cG9ydC1mb3ItYm91bmRzKVxuICogdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB0byBmaXQgdGhlIGdpdmVuIG5vZGVzIGluIGEgdmlld3BvcnQuXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBVc2VmdWwgd2hlbiBjb21iaW5lZCB3aXRoIHtAbGluayBnZXRWaWV3cG9ydEZvckJvdW5kc30gdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB0byBmaXQgdGhlIGdpdmVuIG5vZGVzIGluIGEgdmlld3BvcnQuXG4gKiBAcGFyYW0gbm9kZXMgLSBOb2RlcyB0byBjYWxjdWxhdGUgdGhlIGJvdW5kcyBmb3IuXG4gKiBAcmV0dXJucyBCb3VuZGluZyBib3ggZW5jbG9zaW5nIGFsbCBub2Rlcy5cbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGNhbGxlZCBgZ2V0UmVjdE9mTm9kZXNgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGdldE5vZGVzQm91bmRzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtcbiAqICB7XG4gKiAgICBpZDogJ2EnLFxuICogICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxuICogICAgZGF0YTogeyBsYWJlbDogJ2EnIH0sXG4gKiAgICB3aWR0aDogNTAsXG4gKiAgICBoZWlnaHQ6IDI1LFxuICogIH0sXG4gKiAge1xuICogICAgaWQ6ICdiJyxcbiAqICAgIHBvc2l0aW9uOiB7IHg6IDEwMCwgeTogMTAwIH0sXG4gKiAgICBkYXRhOiB7IGxhYmVsOiAnYicgfSxcbiAqICAgIHdpZHRoOiA1MCxcbiAqICAgIGhlaWdodDogMjUsXG4gKiAgfSxcbiAqXTtcbiAqXG4gKmNvbnN0IGJvdW5kcyA9IGdldE5vZGVzQm91bmRzKG5vZGVzKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldE5vZGVzQm91bmRzID0gKG5vZGVzLCBwYXJhbXMgPSB7IG5vZGVPcmlnaW46IFswLCAwXSB9KSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICFwYXJhbXMubm9kZUxvb2t1cCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1BsZWFzZSB1c2UgYGdldE5vZGVzQm91bmRzYCBmcm9tIGB1c2VSZWFjdEZsb3dgL2B1c2VTdmVsdGVGbG93YCBob29rIHRvIGVuc3VyZSBjb3JyZWN0IHZhbHVlcyBmb3Igc3ViIGZsb3dzLiBJZiBub3QgcG9zc2libGUsIHlvdSBoYXZlIHRvIHByb3ZpZGUgYSBub2RlTG9va3VwIHRvIHN1cHBvcnQgc3ViIGZsb3dzLicpO1xuICAgIH1cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgYm94ID0gbm9kZXMucmVkdWNlKChjdXJyQm94LCBub2RlT3JJZCkgPT4ge1xuICAgICAgICBjb25zdCBpc0lkID0gdHlwZW9mIG5vZGVPcklkID09PSAnc3RyaW5nJztcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gIXBhcmFtcy5ub2RlTG9va3VwICYmICFpc0lkID8gbm9kZU9ySWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwYXJhbXMubm9kZUxvb2t1cCkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBpc0lkXG4gICAgICAgICAgICAgICAgPyBwYXJhbXMubm9kZUxvb2t1cC5nZXQobm9kZU9ySWQpXG4gICAgICAgICAgICAgICAgOiAhaXNJbnRlcm5hbE5vZGVCYXNlKG5vZGVPcklkKVxuICAgICAgICAgICAgICAgICAgICA/IHBhcmFtcy5ub2RlTG9va3VwLmdldChub2RlT3JJZC5pZClcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlT3JJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlQm94ID0gY3VycmVudE5vZGUgPyBub2RlVG9Cb3goY3VycmVudE5vZGUsIHBhcmFtcy5ub2RlT3JpZ2luKSA6IHsgeDogMCwgeTogMCwgeDI6IDAsIHkyOiAwIH07XG4gICAgICAgIHJldHVybiBnZXRCb3VuZHNPZkJveGVzKGN1cnJCb3gsIG5vZGVCb3gpO1xuICAgIH0sIHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MjogLUluZmluaXR5IH0pO1xuICAgIHJldHVybiBib3hUb1JlY3QoYm94KTtcbn07XG4vKipcbiAqIERldGVybWluZXMgYSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBhbGwgZ2l2ZW4gbm9kZXMgaW4gYW4gYXJyYXlcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzID0gKG5vZGVMb29rdXAsIHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgaWYgKG5vZGVMb29rdXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgfVxuICAgIGxldCBib3ggPSB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSwgeDI6IC1JbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9O1xuICAgIG5vZGVMb29rdXAuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAocGFyYW1zLmZpbHRlciA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcy5maWx0ZXIobm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVCb3ggPSBub2RlVG9Cb3gobm9kZSk7XG4gICAgICAgICAgICBib3ggPSBnZXRCb3VuZHNPZkJveGVzKGJveCwgbm9kZUJveCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYm94VG9SZWN0KGJveCk7XG59O1xuY29uc3QgZ2V0Tm9kZXNJbnNpZGUgPSAobm9kZXMsIHJlY3QsIFt0eCwgdHksIHRTY2FsZV0gPSBbMCwgMCwgMV0sIHBhcnRpYWxseSA9IGZhbHNlLCBcbi8vIHNldCBleGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzIGlmIHlvdSB3YW50IHRvIHBheSBhdHRlbnRpb24gdG8gdGhlIG5vZGVzIFwic2VsZWN0YWJsZVwiIGF0dHJpYnV0ZVxuZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgcGFuZVJlY3QgPSB7XG4gICAgICAgIC4uLnBvaW50VG9SZW5kZXJlclBvaW50KHJlY3QsIFt0eCwgdHksIHRTY2FsZV0pLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAvIHRTY2FsZSxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHRTY2FsZSxcbiAgICB9O1xuICAgIGNvbnN0IHZpc2libGVOb2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcy52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCB7IG1lYXN1cmVkLCBzZWxlY3RhYmxlID0gdHJ1ZSwgaGlkZGVuID0gZmFsc2UgfSA9IG5vZGU7XG4gICAgICAgIGlmICgoZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyAmJiAhc2VsZWN0YWJsZSkgfHwgaGlkZGVuKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aWR0aCA9IG1lYXN1cmVkLndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gbnVsbDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyBudWxsO1xuICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEocGFuZVJlY3QsIG5vZGVUb1JlY3Qobm9kZSkpO1xuICAgICAgICBjb25zdCBhcmVhID0gKHdpZHRoID8/IDApICogKGhlaWdodCA/PyAwKTtcbiAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICBjb25zdCBmb3JjZUluaXRpYWxSZW5kZXIgPSAhbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzO1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBmb3JjZUluaXRpYWxSZW5kZXIgfHwgcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gYXJlYTtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSB8fCBub2RlLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB2aXNpYmxlTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmlzaWJsZU5vZGVzO1xufTtcbi8qKlxuICogVGhpcyB1dGlsaXR5IGZpbHRlcnMgYW4gYXJyYXkgb2YgZWRnZXMsIGtlZXBpbmcgb25seSB0aG9zZSB3aGVyZSBlaXRoZXIgdGhlIHNvdXJjZSBvciB0YXJnZXRcbiAqIG5vZGUgaXMgcHJlc2VudCBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZXMgLSBOb2RlcyB5b3Ugd2FudCB0byBnZXQgdGhlIGNvbm5lY3RlZCBlZGdlcyBmb3IuXG4gKiBAcGFyYW0gZWRnZXMgLSBBbGwgZWRnZXMuXG4gKiBAcmV0dXJucyBBcnJheSBvZiBlZGdlcyB0aGF0IGNvbm5lY3QgYW55IG9mIHRoZSBnaXZlbiBub2RlcyB3aXRoIGVhY2ggb3RoZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGdldENvbm5lY3RlZEVkZ2VzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtcbiAqICB7IGlkOiAnYScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSB9LFxuICogIHsgaWQ6ICdiJywgcG9zaXRpb246IHsgeDogMTAwLCB5OiAwIH0gfSxcbiAqXTtcbiAqXG4gKmNvbnN0IGVkZ2VzID0gW1xuICogIHsgaWQ6ICdhLT5jJywgc291cmNlOiAnYScsIHRhcmdldDogJ2MnIH0sXG4gKiAgeyBpZDogJ2MtPmQnLCBzb3VyY2U6ICdjJywgdGFyZ2V0OiAnZCcgfSxcbiAqXTtcbiAqXG4gKmNvbnN0IGNvbm5lY3RlZEVkZ2VzID0gZ2V0Q29ubmVjdGVkRWRnZXMobm9kZXMsIGVkZ2VzKTtcbiAqIC8vID0+IFt7IGlkOiAnYS0+YycsIHNvdXJjZTogJ2EnLCB0YXJnZXQ6ICdjJyB9XVxuICpgYGBcbiAqL1xuY29uc3QgZ2V0Q29ubmVjdGVkRWRnZXMgPSAobm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IG5ldyBTZXQoKTtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIG5vZGVJZHMuYWRkKG5vZGUuaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGVkZ2UpID0+IG5vZGVJZHMuaGFzKGVkZ2Uuc291cmNlKSB8fCBub2RlSWRzLmhhcyhlZGdlLnRhcmdldCkpO1xufTtcbmZ1bmN0aW9uIGdldEZpdFZpZXdOb2Rlcyhub2RlTG9va3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZml0Vmlld05vZGVzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9wdGlvbk5vZGVJZHMgPSBvcHRpb25zPy5ub2RlcyA/IG5ldyBTZXQob3B0aW9ucy5ub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKSA6IG51bGw7XG4gICAgbm9kZUxvb2t1cC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IG4ubWVhc3VyZWQud2lkdGggJiYgbi5tZWFzdXJlZC5oZWlnaHQgJiYgKG9wdGlvbnM/LmluY2x1ZGVIaWRkZW5Ob2RlcyB8fCAhbi5oaWRkZW4pO1xuICAgICAgICBpZiAoaXNWaXNpYmxlICYmICghb3B0aW9uTm9kZUlkcyB8fCBvcHRpb25Ob2RlSWRzLmhhcyhuLmlkKSkpIHtcbiAgICAgICAgICAgIGZpdFZpZXdOb2Rlcy5zZXQobi5pZCwgbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZml0Vmlld05vZGVzO1xufVxuYXN5bmMgZnVuY3Rpb24gZml0Vmlld3BvcnQoeyBub2Rlcywgd2lkdGgsIGhlaWdodCwgcGFuWm9vbSwgbWluWm9vbSwgbWF4Wm9vbSB9LCBvcHRpb25zKSB7XG4gICAgaWYgKG5vZGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXNUb0ZpdCA9IGdldEZpdFZpZXdOb2Rlcyhub2Rlcywgb3B0aW9ucyk7XG4gICAgY29uc3QgYm91bmRzID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2Rlc1RvRml0KTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucz8ubWluWm9vbSA/PyBtaW5ab29tLCBvcHRpb25zPy5tYXhab29tID8/IG1heFpvb20sIG9wdGlvbnM/LnBhZGRpbmcgPz8gMC4xKTtcbiAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHZpZXdwb3J0LCB7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbixcbiAgICAgICAgZWFzZTogb3B0aW9ucz8uZWFzZSxcbiAgICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnM/LmludGVycG9sYXRlLFxuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgbmV4dCBwb3NpdGlvbiBvZiBhIG5vZGUsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIG5vZGUncyBleHRlbnQsIHBhcmVudCBub2RlLCBhbmQgb3JpZ2luLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgcG9zaXRpb24sIHBvc2l0aW9uQWJzb2x1dGVcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTm9kZVBvc2l0aW9uKHsgbm9kZUlkLCBuZXh0UG9zaXRpb24sIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gPSBbMCwgMF0sIG5vZGVFeHRlbnQsIG9uRXJyb3IsIH0pIHtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRJZCA/IG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHsgeDogcGFyZW50WCwgeTogcGFyZW50WSB9ID0gcGFyZW50Tm9kZSA/IHBhcmVudE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgOiB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBvcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgIGxldCBleHRlbnQgPSBub2RlLmV4dGVudCB8fCBub2RlRXh0ZW50O1xuICAgIGlmIChub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcgJiYgIW5vZGUuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgb25FcnJvcj8uKCcwMDUnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNSddKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50V2lkdGggPSBwYXJlbnROb2RlLm1lYXN1cmVkLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SGVpZ2h0ID0gcGFyZW50Tm9kZS5tZWFzdXJlZC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAocGFyZW50V2lkdGggJiYgcGFyZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBbcGFyZW50WCwgcGFyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtwYXJlbnRYICsgcGFyZW50V2lkdGgsIHBhcmVudFkgKyBwYXJlbnRIZWlnaHRdLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50Tm9kZSAmJiBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpKSB7XG4gICAgICAgIGV4dGVudCA9IFtcbiAgICAgICAgICAgIFtub2RlLmV4dGVudFswXVswXSArIHBhcmVudFgsIG5vZGUuZXh0ZW50WzBdWzFdICsgcGFyZW50WV0sXG4gICAgICAgICAgICBbbm9kZS5leHRlbnRbMV1bMF0gKyBwYXJlbnRYLCBub2RlLmV4dGVudFsxXVsxXSArIHBhcmVudFldLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbkFic29sdXRlID0gaXNDb29yZGluYXRlRXh0ZW50KGV4dGVudClcbiAgICAgICAgPyBjbGFtcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgZXh0ZW50LCBub2RlLm1lYXN1cmVkKVxuICAgICAgICA6IG5leHRQb3NpdGlvbjtcbiAgICBpZiAobm9kZS5tZWFzdXJlZC53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IG5vZGUubWVhc3VyZWQuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTUnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxNSddKCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zaXRpb25BYnNvbHV0ZS54IC0gcGFyZW50WCArIChub2RlLm1lYXN1cmVkLndpZHRoID8/IDApICogb3JpZ2luWzBdLFxuICAgICAgICAgICAgeTogcG9zaXRpb25BYnNvbHV0ZS55IC0gcGFyZW50WSArIChub2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwKSAqIG9yaWdpblsxXSxcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYXNzIGluIG5vZGVzICYgZWRnZXMgdG8gZGVsZXRlLCBnZXQgYXJyYXlzIG9mIG5vZGVzIGFuZCBlZGdlcyB0aGF0IGFjdHVhbGx5IGNhbiBiZSBkZWxldGVkXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBwYXJhbS5ub2Rlc1RvUmVtb3ZlIC0gVGhlIG5vZGVzIHRvIHJlbW92ZVxuICogQHBhcmFtIHBhcmFtLmVkZ2VzVG9SZW1vdmUgLSBUaGUgZWRnZXMgdG8gcmVtb3ZlXG4gKiBAcGFyYW0gcGFyYW0ubm9kZXMgLSBBbGwgbm9kZXNcbiAqIEBwYXJhbSBwYXJhbS5lZGdlcyAtIEFsbCBlZGdlc1xuICogQHBhcmFtIHBhcmFtLm9uQmVmb3JlRGVsZXRlIC0gQ2FsbGJhY2sgdG8gY2hlY2sgd2hpY2ggbm9kZXMgYW5kIGVkZ2VzIGNhbiBiZSBkZWxldGVkXG4gKiBAcmV0dXJucyBub2Rlczogbm9kZXMgdGhhdCBjYW4gYmUgZGVsZXRlZCwgZWRnZXM6IGVkZ2VzIHRoYXQgY2FuIGJlIGRlbGV0ZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RWxlbWVudHNUb1JlbW92ZSh7IG5vZGVzVG9SZW1vdmUgPSBbXSwgZWRnZXNUb1JlbW92ZSA9IFtdLCBub2RlcywgZWRnZXMsIG9uQmVmb3JlRGVsZXRlLCB9KSB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IG5ldyBTZXQobm9kZXNUb1JlbW92ZS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKTtcbiAgICBjb25zdCBtYXRjaGluZ05vZGVzID0gW107XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2RlLmRlbGV0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzSW5jbHVkZWQgPSBub2RlSWRzLmhhcyhub2RlLmlkKTtcbiAgICAgICAgY29uc3QgcGFyZW50SGl0ID0gIWlzSW5jbHVkZWQgJiYgbm9kZS5wYXJlbnRJZCAmJiBtYXRjaGluZ05vZGVzLmZpbmQoKG4pID0+IG4uaWQgPT09IG5vZGUucGFyZW50SWQpO1xuICAgICAgICBpZiAoaXNJbmNsdWRlZCB8fCBwYXJlbnRIaXQpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlZGdlSWRzID0gbmV3IFNldChlZGdlc1RvUmVtb3ZlLm1hcCgoZWRnZSkgPT4gZWRnZS5pZCkpO1xuICAgIGNvbnN0IGRlbGV0YWJsZUVkZ2VzID0gZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLmRlbGV0YWJsZSAhPT0gZmFsc2UpO1xuICAgIGNvbnN0IGNvbm5lY3RlZEVkZ2VzID0gZ2V0Q29ubmVjdGVkRWRnZXMobWF0Y2hpbmdOb2RlcywgZGVsZXRhYmxlRWRnZXMpO1xuICAgIGNvbnN0IG1hdGNoaW5nRWRnZXMgPSBjb25uZWN0ZWRFZGdlcztcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZGVsZXRhYmxlRWRnZXMpIHtcbiAgICAgICAgY29uc3QgaXNJbmNsdWRlZCA9IGVkZ2VJZHMuaGFzKGVkZ2UuaWQpO1xuICAgICAgICBpZiAoaXNJbmNsdWRlZCAmJiAhbWF0Y2hpbmdFZGdlcy5maW5kKChlKSA9PiBlLmlkID09PSBlZGdlLmlkKSkge1xuICAgICAgICAgICAgbWF0Y2hpbmdFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb25CZWZvcmVEZWxldGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzLFxuICAgICAgICAgICAgbm9kZXM6IG1hdGNoaW5nTm9kZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9uQmVmb3JlRGVsZXRlUmVzdWx0ID0gYXdhaXQgb25CZWZvcmVEZWxldGUoe1xuICAgICAgICBub2RlczogbWF0Y2hpbmdOb2RlcyxcbiAgICAgICAgZWRnZXM6IG1hdGNoaW5nRWRnZXMsXG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvbkJlZm9yZURlbGV0ZVJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBvbkJlZm9yZURlbGV0ZVJlc3VsdCA/IHsgZWRnZXM6IG1hdGNoaW5nRWRnZXMsIG5vZGVzOiBtYXRjaGluZ05vZGVzIH0gOiB7IGVkZ2VzOiBbXSwgbm9kZXM6IFtdIH07XG4gICAgfVxuICAgIHJldHVybiBvbkJlZm9yZURlbGV0ZVJlc3VsdDtcbn1cblxuY29uc3QgY2xhbXAgPSAodmFsLCBtaW4gPSAwLCBtYXggPSAxKSA9PiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIG1pbiksIG1heCk7XG5jb25zdCBjbGFtcFBvc2l0aW9uID0gKHBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH0sIGV4dGVudCwgZGltZW5zaW9ucykgPT4gKHtcbiAgICB4OiBjbGFtcChwb3NpdGlvbi54LCBleHRlbnRbMF1bMF0sIGV4dGVudFsxXVswXSAtIChkaW1lbnNpb25zPy53aWR0aCA/PyAwKSksXG4gICAgeTogY2xhbXAocG9zaXRpb24ueSwgZXh0ZW50WzBdWzFdLCBleHRlbnRbMV1bMV0gLSAoZGltZW5zaW9ucz8uaGVpZ2h0ID8/IDApKSxcbn0pO1xuZnVuY3Rpb24gY2xhbXBQb3NpdGlvblRvUGFyZW50KGNoaWxkUG9zaXRpb24sIGNoaWxkRGltZW5zaW9ucywgcGFyZW50KSB7XG4gICAgY29uc3QgeyB3aWR0aDogcGFyZW50V2lkdGgsIGhlaWdodDogcGFyZW50SGVpZ2h0IH0gPSBnZXROb2RlRGltZW5zaW9ucyhwYXJlbnQpO1xuICAgIGNvbnN0IHsgeDogcGFyZW50WCwgeTogcGFyZW50WSB9ID0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgIHJldHVybiBjbGFtcFBvc2l0aW9uKGNoaWxkUG9zaXRpb24sIFtcbiAgICAgICAgW3BhcmVudFgsIHBhcmVudFldLFxuICAgICAgICBbcGFyZW50WCArIHBhcmVudFdpZHRoLCBwYXJlbnRZICsgcGFyZW50SGVpZ2h0XSxcbiAgICBdLCBjaGlsZERpbWVuc2lvbnMpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB2ZWxvY2l0eSBvZiBwYW5uaW5nIHdoZW4gdGhlIG1vdXNlIGlzIGNsb3NlIHRvIHRoZSBlZGdlIG9mIHRoZSBjYW52YXNcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHZhbHVlIC0gT25lIGRpbWVuc2lvbmFsIHBvaXRpb24gb2YgdGhlIG1vdXNlICh4IG9yIHkpXG4gKiBAcGFyYW0gbWluIC0gTWluaW1hbCBwb3NpdGlvbiBvbiBjYW52YXMgYmVmb3JlIHBhbm5pbmcgc3RhcnRzXG4gKiBAcGFyYW0gbWF4IC0gTWF4aW1hbCBwb3NpdGlvbiBvbiBjYW52YXMgYmVmb3JlIHBhbm5pbmcgc3RhcnRzXG4gKiBAcmV0dXJucyAtIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSB0aGF0IHJlcHJlc2VudHMgdGhlIHZlbG9jaXR5IG9mIHBhbm5pbmdcbiAqL1xuY29uc3QgY2FsY0F1dG9QYW5WZWxvY2l0eSA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IHtcbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIGNsYW1wKE1hdGguYWJzKHZhbHVlIC0gbWluKSwgMSwgbWluKSAvIG1pbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIC1jbGFtcChNYXRoLmFicyh2YWx1ZSAtIG1heCksIDEsIG1pbikgLyBtaW47XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcbmNvbnN0IGNhbGNBdXRvUGFuID0gKHBvcywgYm91bmRzLCBzcGVlZCA9IDE1LCBkaXN0YW5jZSA9IDQwKSA9PiB7XG4gICAgY29uc3QgeE1vdmVtZW50ID0gY2FsY0F1dG9QYW5WZWxvY2l0eShwb3MueCwgZGlzdGFuY2UsIGJvdW5kcy53aWR0aCAtIGRpc3RhbmNlKSAqIHNwZWVkO1xuICAgIGNvbnN0IHlNb3ZlbWVudCA9IGNhbGNBdXRvUGFuVmVsb2NpdHkocG9zLnksIGRpc3RhbmNlLCBib3VuZHMuaGVpZ2h0IC0gZGlzdGFuY2UpICogc3BlZWQ7XG4gICAgcmV0dXJuIFt4TW92ZW1lbnQsIHlNb3ZlbWVudF07XG59O1xuY29uc3QgZ2V0Qm91bmRzT2ZCb3hlcyA9IChib3gxLCBib3gyKSA9PiAoe1xuICAgIHg6IE1hdGgubWluKGJveDEueCwgYm94Mi54KSxcbiAgICB5OiBNYXRoLm1pbihib3gxLnksIGJveDIueSksXG4gICAgeDI6IE1hdGgubWF4KGJveDEueDIsIGJveDIueDIpLFxuICAgIHkyOiBNYXRoLm1heChib3gxLnkyLCBib3gyLnkyKSxcbn0pO1xuY29uc3QgcmVjdFRvQm94ID0gKHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9KSA9PiAoe1xuICAgIHgsXG4gICAgeSxcbiAgICB4MjogeCArIHdpZHRoLFxuICAgIHkyOiB5ICsgaGVpZ2h0LFxufSk7XG5jb25zdCBib3hUb1JlY3QgPSAoeyB4LCB5LCB4MiwgeTIgfSkgPT4gKHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHgyIC0geCxcbiAgICBoZWlnaHQ6IHkyIC0geSxcbn0pO1xuY29uc3Qgbm9kZVRvUmVjdCA9IChub2RlLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBpc0ludGVybmFsTm9kZUJhc2Uobm9kZSlcbiAgICAgICAgPyBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlXG4gICAgICAgIDogZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBub2RlT3JpZ2luKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB3aWR0aDogbm9kZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyAwLFxuICAgICAgICBoZWlnaHQ6IG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gMCxcbiAgICB9O1xufTtcbmNvbnN0IG5vZGVUb0JveCA9IChub2RlLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBpc0ludGVybmFsTm9kZUJhc2Uobm9kZSlcbiAgICAgICAgPyBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlXG4gICAgICAgIDogZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBub2RlT3JpZ2luKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB4MjogeCArIChub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IDApLFxuICAgICAgICB5MjogeSArIChub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IDApLFxuICAgIH07XG59O1xuY29uc3QgZ2V0Qm91bmRzT2ZSZWN0cyA9IChyZWN0MSwgcmVjdDIpID0+IGJveFRvUmVjdChnZXRCb3VuZHNPZkJveGVzKHJlY3RUb0JveChyZWN0MSksIHJlY3RUb0JveChyZWN0MikpKTtcbmNvbnN0IGdldE92ZXJsYXBwaW5nQXJlYSA9IChyZWN0QSwgcmVjdEIpID0+IHtcbiAgICBjb25zdCB4T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3RBLnggKyByZWN0QS53aWR0aCwgcmVjdEIueCArIHJlY3RCLndpZHRoKSAtIE1hdGgubWF4KHJlY3RBLngsIHJlY3RCLngpKTtcbiAgICBjb25zdCB5T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3RBLnkgKyByZWN0QS5oZWlnaHQsIHJlY3RCLnkgKyByZWN0Qi5oZWlnaHQpIC0gTWF0aC5tYXgocmVjdEEueSwgcmVjdEIueSkpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoeE92ZXJsYXAgKiB5T3ZlcmxhcCk7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGlzUmVjdE9iamVjdCA9IChvYmopID0+IGlzTnVtZXJpYyhvYmoud2lkdGgpICYmIGlzTnVtZXJpYyhvYmouaGVpZ2h0KSAmJiBpc051bWVyaWMob2JqLngpICYmIGlzTnVtZXJpYyhvYmoueSk7XG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3QgaXNOdW1lcmljID0gKG4pID0+ICFpc05hTihuKSAmJiBpc0Zpbml0ZShuKTtcbi8vIHVzZWQgZm9yIGExMXkga2V5IGJvYXJkIGNvbnRyb2xzIGZvciBub2RlcyBhbmQgZWRnZXNcbmNvbnN0IGRldldhcm4gPSAoaWQsIG1lc3NhZ2UpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbUmVhY3QgRmxvd106ICR7bWVzc2FnZX0gSGVscDogaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2Vycm9yIyR7aWR9YCk7XG4gICAgfVxufTtcbmNvbnN0IHNuYXBQb3NpdGlvbiA9IChwb3NpdGlvbiwgc25hcEdyaWQgPSBbMSwgMV0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBzbmFwR3JpZFswXSAqIE1hdGgucm91bmQocG9zaXRpb24ueCAvIHNuYXBHcmlkWzBdKSxcbiAgICAgICAgeTogc25hcEdyaWRbMV0gKiBNYXRoLnJvdW5kKHBvc2l0aW9uLnkgLyBzbmFwR3JpZFsxXSksXG4gICAgfTtcbn07XG5jb25zdCBwb2ludFRvUmVuZGVyZXJQb2ludCA9ICh7IHgsIHkgfSwgW3R4LCB0eSwgdFNjYWxlXSwgc25hcFRvR3JpZCA9IGZhbHNlLCBzbmFwR3JpZCA9IFsxLCAxXSkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICB4OiAoeCAtIHR4KSAvIHRTY2FsZSxcbiAgICAgICAgeTogKHkgLSB0eSkgLyB0U2NhbGUsXG4gICAgfTtcbiAgICByZXR1cm4gc25hcFRvR3JpZCA/IHNuYXBQb3NpdGlvbihwb3NpdGlvbiwgc25hcEdyaWQpIDogcG9zaXRpb247XG59O1xuY29uc3QgcmVuZGVyZXJQb2ludFRvUG9pbnQgPSAoeyB4LCB5IH0sIFt0eCwgdHksIHRTY2FsZV0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICogdFNjYWxlICsgdHgsXG4gICAgICAgIHk6IHkgKiB0U2NhbGUgKyB0eSxcbiAgICB9O1xufTtcbi8qKlxuICogUGFyc2VzIGEgc2luZ2xlIHBhZGRpbmcgdmFsdWUgdG8gYSBudW1iZXJcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBhZGRpbmcgLSBQYWRkaW5nIHRvIHBhcnNlXG4gKiBAcGFyYW0gdmlld3BvcnQgLSBXaWR0aCBvciBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gKiBAcmV0dXJucyBUaGUgcGFkZGluZyBpbiBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VQYWRkaW5nKHBhZGRpbmcsIHZpZXdwb3J0KSB7XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigodmlld3BvcnQgLSB2aWV3cG9ydCAvICgxICsgcGFkZGluZykpICogMC41KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnc3RyaW5nJyAmJiBwYWRkaW5nLmVuZHNXaXRoKCdweCcpKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdWYWx1ZSA9IHBhcnNlRmxvYXQocGFkZGluZyk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHBhZGRpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHBhZGRpbmdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnc3RyaW5nJyAmJiBwYWRkaW5nLmVuZHNXaXRoKCclJykpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZ1ZhbHVlID0gcGFyc2VGbG9hdChwYWRkaW5nKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFkZGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iodmlld3BvcnQgKiBwYWRkaW5nVmFsdWUgKiAwLjAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKGBbUmVhY3QgRmxvd10gVGhlIHBhZGRpbmcgdmFsdWUgXCIke3BhZGRpbmd9XCIgaXMgaW52YWxpZC4gUGxlYXNlIHByb3ZpZGUgYSBudW1iZXIgb3IgYSBzdHJpbmcgd2l0aCBhIHZhbGlkIHVuaXQgKHB4IG9yICUpLmApO1xuICAgIHJldHVybiAwO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIHBhZGRpbmdzIHRvIGFuIG9iamVjdCB3aXRoIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgeCBhbmQgeSBwYWRkaW5nc1xuICogQGludGVybmFsXG4gKiBAcGFyYW0gcGFkZGluZyAtIFBhZGRpbmcgdG8gcGFyc2VcbiAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIGhlaWdodCAtIEhlaWdodCBvZiB0aGUgdmlld3BvcnRcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBwYWRkaW5ncyBpbiBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VQYWRkaW5ncyhwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZ1kgPSBwYXJzZVBhZGRpbmcocGFkZGluZywgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcGFkZGluZ1ggPSBwYXJzZVBhZGRpbmcocGFkZGluZywgd2lkdGgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBwYWRkaW5nWSxcbiAgICAgICAgICAgIHJpZ2h0OiBwYWRkaW5nWCxcbiAgICAgICAgICAgIGJvdHRvbTogcGFkZGluZ1ksXG4gICAgICAgICAgICBsZWZ0OiBwYWRkaW5nWCxcbiAgICAgICAgICAgIHg6IHBhZGRpbmdYICogMixcbiAgICAgICAgICAgIHk6IHBhZGRpbmdZICogMixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCB0b3AgPSBwYXJzZVBhZGRpbmcocGFkZGluZy50b3AgPz8gcGFkZGluZy55ID8/IDAsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLmJvdHRvbSA/PyBwYWRkaW5nLnkgPz8gMCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgbGVmdCA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLmxlZnQgPz8gcGFkZGluZy54ID8/IDAsIHdpZHRoKTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBwYXJzZVBhZGRpbmcocGFkZGluZy5yaWdodCA/PyBwYWRkaW5nLnggPz8gMCwgd2lkdGgpO1xuICAgICAgICByZXR1cm4geyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHg6IGxlZnQgKyByaWdodCwgeTogdG9wICsgYm90dG9tIH07XG4gICAgfVxuICAgIHJldHVybiB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgeDogMCwgeTogMCB9O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSByZXN1bHRpbmcgcGFkZGluZ3MgaWYgdGhlIG5ldyB2aWV3cG9ydCBpcyBhcHBsaWVkXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBib3VuZHMgLSBCb3VuZHMgdG8gZml0IGluc2lkZSB2aWV3cG9ydFxuICogQHBhcmFtIHggLSBYIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIHkgLSBZIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIHpvb20gLSBab29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIG1pbmltdW0gcGFkZGluZyByZXF1aXJlZCB0byBmaXQgdGhlIGJvdW5kcyBpbnNpZGUgdGhlIHZpZXdwb3J0XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFwcGxpZWRQYWRkaW5ncyhib3VuZHMsIHgsIHksIHpvb20sIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB7IHg6IGxlZnQsIHk6IHRvcCB9ID0gcmVuZGVyZXJQb2ludFRvUG9pbnQoYm91bmRzLCBbeCwgeSwgem9vbV0pO1xuICAgIGNvbnN0IHsgeDogYm91bmRSaWdodCwgeTogYm91bmRCb3R0b20gfSA9IHJlbmRlcmVyUG9pbnRUb1BvaW50KHsgeDogYm91bmRzLnggKyBib3VuZHMud2lkdGgsIHk6IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCB9LCBbeCwgeSwgem9vbV0pO1xuICAgIGNvbnN0IHJpZ2h0ID0gd2lkdGggLSBib3VuZFJpZ2h0O1xuICAgIGNvbnN0IGJvdHRvbSA9IGhlaWdodCAtIGJvdW5kQm90dG9tO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IE1hdGguZmxvb3IobGVmdCksXG4gICAgICAgIHRvcDogTWF0aC5mbG9vcih0b3ApLFxuICAgICAgICByaWdodDogTWF0aC5mbG9vcihyaWdodCksXG4gICAgICAgIGJvdHRvbTogTWF0aC5mbG9vcihib3R0b20pLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgYSB2aWV3cG9ydCB0aGF0IGVuY2xvc2VzIHRoZSBnaXZlbiBib3VuZHMgd2l0aCBwYWRkaW5nLlxuICogQHB1YmxpY1xuICogQHJlbWFya3MgWW91IGNhbiBkZXRlcm1pbmUgYm91bmRzIG9mIG5vZGVzIHdpdGgge0BsaW5rIGdldE5vZGVzQm91bmRzfSBhbmQge0BsaW5rIGdldEJvdW5kc09mUmVjdHN9XG4gKiBAcGFyYW0gYm91bmRzIC0gQm91bmRzIHRvIGZpdCBpbnNpZGUgdmlld3BvcnQuXG4gKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiB0aGUgdmlld3BvcnQuXG4gKiBAcGFyYW0gaGVpZ2h0ICAtIEhlaWdodCBvZiB0aGUgdmlld3BvcnQuXG4gKiBAcGFyYW0gbWluWm9vbSAtIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgcmVzdWx0aW5nIHZpZXdwb3J0LlxuICogQHBhcmFtIG1heFpvb20gLSBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIHJlc3VsdGluZyB2aWV3cG9ydC5cbiAqIEBwYXJhbSBwYWRkaW5nIC0gUGFkZGluZyBhcm91bmQgdGhlIGJvdW5kcy5cbiAqIEByZXR1cm5zIEEgdHJhbnNmb3JtZWQge0BsaW5rIFZpZXdwb3J0fSB0aGF0IGVuY2xvc2VzIHRoZSBnaXZlbiBib3VuZHMgd2hpY2ggeW91IGNhbiBwYXNzIHRvIGUuZy4ge0BsaW5rIHNldFZpZXdwb3J0fS5cbiAqIEBleGFtcGxlXG4gKiBjb25zdCB7IHgsIHksIHpvb20gfSA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKFxuICogeyB4OiAwLCB5OiAwLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMH0sXG4gKiAxMjAwLCA4MDAsIDAuNSwgMik7XG4gKi9cbmNvbnN0IGdldFZpZXdwb3J0Rm9yQm91bmRzID0gKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgcGFkZGluZykgPT4ge1xuICAgIC8vIEZpcnN0IHdlIHJlc29sdmUgYWxsIHRoZSBwYWRkaW5ncyB0byBhY3R1YWwgcGl4ZWwgdmFsdWVzXG4gICAgY29uc3QgcCA9IHBhcnNlUGFkZGluZ3MocGFkZGluZywgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgeFpvb20gPSAod2lkdGggLSBwLngpIC8gYm91bmRzLndpZHRoO1xuICAgIGNvbnN0IHlab29tID0gKGhlaWdodCAtIHAueSkgLyBib3VuZHMuaGVpZ2h0O1xuICAgIC8vIFdlIGNhbGN1bGF0ZSB0aGUgbmV3IHgsIHksIHpvb20gZm9yIGEgY2VudGVyZWQgdmlld1xuICAgIGNvbnN0IHpvb20gPSBNYXRoLm1pbih4Wm9vbSwgeVpvb20pO1xuICAgIGNvbnN0IGNsYW1wZWRab29tID0gY2xhbXAoem9vbSwgbWluWm9vbSwgbWF4Wm9vbSk7XG4gICAgY29uc3QgYm91bmRzQ2VudGVyWCA9IGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC8gMjtcbiAgICBjb25zdCBib3VuZHNDZW50ZXJZID0gYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IC8gMjtcbiAgICBjb25zdCB4ID0gd2lkdGggLyAyIC0gYm91bmRzQ2VudGVyWCAqIGNsYW1wZWRab29tO1xuICAgIGNvbnN0IHkgPSBoZWlnaHQgLyAyIC0gYm91bmRzQ2VudGVyWSAqIGNsYW1wZWRab29tO1xuICAgIC8vIFRoZW4gd2UgY2FsY3VsYXRlIHRoZSBtaW5pbXVtIHBhZGRpbmcsIHRvIHJlc3BlY3QgYXN5bW1ldHJpYyBwYWRkaW5nc1xuICAgIGNvbnN0IG5ld1BhZGRpbmcgPSBjYWxjdWxhdGVBcHBsaWVkUGFkZGluZ3MoYm91bmRzLCB4LCB5LCBjbGFtcGVkWm9vbSwgd2lkdGgsIGhlaWdodCk7XG4gICAgLy8gV2Ugb25seSB3YW50IHRvIGhhdmUgYW4gb2Zmc2V0IGlmIHRoZSBuZXdQYWRkaW5nIGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVxdWlyZWQgcGFkZGluZ1xuICAgIGNvbnN0IG9mZnNldCA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5taW4obmV3UGFkZGluZy5sZWZ0IC0gcC5sZWZ0LCAwKSxcbiAgICAgICAgdG9wOiBNYXRoLm1pbihuZXdQYWRkaW5nLnRvcCAtIHAudG9wLCAwKSxcbiAgICAgICAgcmlnaHQ6IE1hdGgubWluKG5ld1BhZGRpbmcucmlnaHQgLSBwLnJpZ2h0LCAwKSxcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihuZXdQYWRkaW5nLmJvdHRvbSAtIHAuYm90dG9tLCAwKSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLSBvZmZzZXQubGVmdCArIG9mZnNldC5yaWdodCxcbiAgICAgICAgeTogeSAtIG9mZnNldC50b3AgKyBvZmZzZXQuYm90dG9tLFxuICAgICAgICB6b29tOiBjbGFtcGVkWm9vbSxcbiAgICB9O1xufTtcbmNvbnN0IGlzTWFjT3MgPSAoKSA9PiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3I/LnVzZXJBZ2VudD8uaW5kZXhPZignTWFjJykgPj0gMDtcbmZ1bmN0aW9uIGlzQ29vcmRpbmF0ZUV4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gZXh0ZW50ICE9PSB1bmRlZmluZWQgJiYgZXh0ZW50ICE9PSBudWxsICYmIGV4dGVudCAhPT0gJ3BhcmVudCc7XG59XG5mdW5jdGlvbiBnZXROb2RlRGltZW5zaW9ucyhub2RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gMCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IDAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vZGVIYXNEaW1lbnNpb25zKG5vZGUpIHtcbiAgICByZXR1cm4gKChub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0KSAhPT0gdW5kZWZpbmVkKTtcbn1cbi8qKlxuICogQ29udmVydCBjaGlsZCBwb3NpdGlvbiB0byBhYm9zbHV0ZSBwb3NpdGlvblxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBvc2l0aW9uXG4gKiBAcGFyYW0gcGFyZW50SWRcbiAqIEBwYXJhbSBub2RlTG9va3VwXG4gKiBAcGFyYW0gbm9kZU9yaWdpblxuICogQHJldHVybnMgYW4gaW50ZXJuYWwgbm9kZSB3aXRoIGFuIGFic29sdXRlIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbihwb3NpdGlvbiwgZGltZW5zaW9ucyA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LCBwYXJlbnRJZCwgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbikge1xuICAgIGNvbnN0IHBvc2l0aW9uQWJzb2x1dGUgPSB7IC4uLnBvc2l0aW9uIH07XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZUxvb2t1cC5nZXQocGFyZW50SWQpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gcGFyZW50Lm9yaWdpbiB8fCBub2RlT3JpZ2luO1xuICAgICAgICBwb3NpdGlvbkFic29sdXRlLnggKz0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggLSAoZGltZW5zaW9ucy53aWR0aCA/PyAwKSAqIG9yaWdpblswXTtcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZS55ICs9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55IC0gKGRpbWVuc2lvbnMuaGVpZ2h0ID8/IDApICogb3JpZ2luWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb25BYnNvbHV0ZTtcbn1cbmZ1bmN0aW9uIGFyZVNldHNFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgUHJvbWlzZS53aXRoUmVzb2x2ZXJzIHVudGlsIHdlIGNhbiB1c2UgaXQgaW4gYWxsIGJyb3dzZXJzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gd2l0aFJlc29sdmVycygpIHtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBsZXQgcmVqZWN0O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuZnVuY3Rpb24gbWVyZ2VBcmlhTGFiZWxDb25maWcocGFydGlhbCkge1xuICAgIHJldHVybiB7IC4uLmRlZmF1bHRBcmlhTGFiZWxDb25maWcsIC4uLihwYXJ0aWFsIHx8IHt9KSB9O1xufVxuXG5mdW5jdGlvbiBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQsIHsgc25hcEdyaWQgPSBbMCwgMF0sIHNuYXBUb0dyaWQgPSBmYWxzZSwgdHJhbnNmb3JtLCBjb250YWluZXJCb3VuZHMgfSkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgcG9pbnRlclBvcyA9IHBvaW50VG9SZW5kZXJlclBvaW50KHsgeDogeCAtIChjb250YWluZXJCb3VuZHM/LmxlZnQgPz8gMCksIHk6IHkgLSAoY29udGFpbmVyQm91bmRzPy50b3AgPz8gMCkgfSwgdHJhbnNmb3JtKTtcbiAgICBjb25zdCB7IHg6IHhTbmFwcGVkLCB5OiB5U25hcHBlZCB9ID0gc25hcFRvR3JpZCA/IHNuYXBQb3NpdGlvbihwb2ludGVyUG9zLCBzbmFwR3JpZCkgOiBwb2ludGVyUG9zO1xuICAgIC8vIHdlIG5lZWQgdGhlIHNuYXBwZWQgcG9zaXRpb24gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBza2lwIHVubmVjZXNzYXJ5IGRyYWcgZXZlbnRzXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeFNuYXBwZWQsXG4gICAgICAgIHlTbmFwcGVkLFxuICAgICAgICAuLi5wb2ludGVyUG9zLFxuICAgIH07XG59XG5jb25zdCBnZXREaW1lbnNpb25zID0gKG5vZGUpID0+ICh7XG4gICAgd2lkdGg6IG5vZGUub2Zmc2V0V2lkdGgsXG4gICAgaGVpZ2h0OiBub2RlLm9mZnNldEhlaWdodCxcbn0pO1xuY29uc3QgZ2V0SG9zdEZvckVsZW1lbnQgPSAoZWxlbWVudCkgPT4gZWxlbWVudD8uZ2V0Um9vdE5vZGU/LigpIHx8IHdpbmRvdz8uZG9jdW1lbnQ7XG5jb25zdCBpbnB1dFRhZ3MgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQSddO1xuZnVuY3Rpb24gaXNJbnB1dERPTU5vZGUoZXZlbnQpIHtcbiAgICAvLyB1c2luZyBjb21wb3NlZCBwYXRoIGZvciBoYW5kbGluZyBzaGFkb3cgZG9tXG4gICAgY29uc3QgdGFyZ2V0ID0gKGV2ZW50LmNvbXBvc2VkUGF0aD8uKCk/LlswXSB8fCBldmVudC50YXJnZXQpO1xuICAgIGlmICh0YXJnZXQ/Lm5vZGVUeXBlICE9PSAxIC8qIE5vZGUuRUxFTUVOVF9OT0RFICovKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaXNJbnB1dCA9IGlucHV0VGFncy5pbmNsdWRlcyh0YXJnZXQubm9kZU5hbWUpIHx8IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgIC8vIHdoZW4gYW4gaW5wdXQgZmllbGQgaXMgZm9jdXNlZCB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgZGVsZXRpb24gb3IgbW92ZW1lbnQgb2Ygbm9kZXNcbiAgICByZXR1cm4gaXNJbnB1dCB8fCAhIXRhcmdldC5jbG9zZXN0KCcubm9rZXknKTtcbn1cbmNvbnN0IGlzTW91c2VFdmVudCA9IChldmVudCkgPT4gJ2NsaWVudFgnIGluIGV2ZW50O1xuY29uc3QgZ2V0RXZlbnRQb3NpdGlvbiA9IChldmVudCwgYm91bmRzKSA9PiB7XG4gICAgY29uc3QgaXNNb3VzZSA9IGlzTW91c2VFdmVudChldmVudCk7XG4gICAgY29uc3QgZXZ0WCA9IGlzTW91c2UgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFg7XG4gICAgY29uc3QgZXZ0WSA9IGlzTW91c2UgPyBldmVudC5jbGllbnRZIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZ0WCAtIChib3VuZHM/LmxlZnQgPz8gMCksXG4gICAgICAgIHk6IGV2dFkgLSAoYm91bmRzPy50b3AgPz8gMCksXG4gICAgfTtcbn07XG4vKlxuICogVGhlIGhhbmRsZSBib3VuZHMgYXJlIGNhbGN1bGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG5vZGUgZWxlbWVudC5cbiAqIFdlIHN0b3JlIHRoZW0gaW4gdGhlIGludGVybmFscyBvYmplY3Qgb2YgdGhlIG5vZGUgaW4gb3JkZXIgdG8gYXZvaWRcbiAqIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zLlxuICovXG5jb25zdCBnZXRIYW5kbGVCb3VuZHMgPSAodHlwZSwgbm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGVJZCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXMgPSBub2RlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0eXBlfWApO1xuICAgIGlmICghaGFuZGxlcyB8fCAhaGFuZGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGhhbmRsZXMpLm1hcCgoaGFuZGxlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUJvdW5kcyA9IGhhbmRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBoYW5kbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZWlkJyksXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgcG9zaXRpb246IGhhbmRsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlcG9zJyksXG4gICAgICAgICAgICB4OiAoaGFuZGxlQm91bmRzLmxlZnQgLSBub2RlQm91bmRzLmxlZnQpIC8gem9vbSxcbiAgICAgICAgICAgIHk6IChoYW5kbGVCb3VuZHMudG9wIC0gbm9kZUJvdW5kcy50b3ApIC8gem9vbSxcbiAgICAgICAgICAgIC4uLmdldERpbWVuc2lvbnMoaGFuZGxlKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGdldEJlemllckVkZ2VDZW50ZXIoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFksIHRhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWSwgfSkge1xuICAgIC8qXG4gICAgICogY3ViaWMgYmV6aWVyIHQ9MC41IG1pZCBwb2ludCwgbm90IHRoZSBhY3R1YWwgbWlkIHBvaW50LCBidXQgZWFzeSB0byBjYWxjdWxhdGVcbiAgICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NzUxNjEwMS9ob3ctdG8tZmluZC1kaXN0YW5jZS1taWQtcG9pbnQtb2YtYmV6aWVyLWN1cnZlXG4gICAgICovXG4gICAgY29uc3QgY2VudGVyWCA9IHNvdXJjZVggKiAwLjEyNSArIHNvdXJjZUNvbnRyb2xYICogMC4zNzUgKyB0YXJnZXRDb250cm9sWCAqIDAuMzc1ICsgdGFyZ2V0WCAqIDAuMTI1O1xuICAgIGNvbnN0IGNlbnRlclkgPSBzb3VyY2VZICogMC4xMjUgKyBzb3VyY2VDb250cm9sWSAqIDAuMzc1ICsgdGFyZ2V0Q29udHJvbFkgKiAwLjM3NSArIHRhcmdldFkgKiAwLjEyNTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5hYnMoY2VudGVyWCAtIHNvdXJjZVgpO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmFicyhjZW50ZXJZIC0gc291cmNlWSk7XG4gICAgcmV0dXJuIFtjZW50ZXJYLCBjZW50ZXJZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoZGlzdGFuY2UsIGN1cnZhdHVyZSkge1xuICAgIGlmIChkaXN0YW5jZSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAwLjUgKiBkaXN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZhdHVyZSAqIDI1ICogTWF0aC5zcXJ0KC1kaXN0YW5jZSk7XG59XG5mdW5jdGlvbiBnZXRDb250cm9sV2l0aEN1cnZhdHVyZSh7IHBvcywgeDEsIHkxLCB4MiwgeTIsIGMgfSkge1xuICAgIHN3aXRjaCAocG9zKSB7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uTGVmdDpcbiAgICAgICAgICAgIHJldHVybiBbeDEgLSBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHgxIC0geDIsIGMpLCB5MV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4gW3gxICsgY2FsY3VsYXRlQ29udHJvbE9mZnNldCh4MiAtIHgxLCBjKSwgeTFdO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlRvcDpcbiAgICAgICAgICAgIHJldHVybiBbeDEsIHkxIC0gY2FsY3VsYXRlQ29udHJvbE9mZnNldCh5MSAtIHkyLCBjKV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEgKyBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHkyIC0geTEsIGMpXTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBgZ2V0QmV6aWVyUGF0aGAgdXRpbCByZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8gcmVuZGVyIGEgYmV6aWVyIGVkZ2VcbiAqYmV0d2VlbiB0d28gbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBIHBhdGggc3RyaW5nIHlvdSBjYW4gdXNlIGluIGFuIFNWRywgdGhlIGBsYWJlbFhgIGFuZCBgbGFiZWxZYCBwb3NpdGlvbiAoY2VudGVyIG9mIHBhdGgpXG4gKiBhbmQgYG9mZnNldFhgLCBgb2Zmc2V0WWAgYmV0d2VlbiBzb3VyY2UgaGFuZGxlIGFuZCBsYWJlbC5cbiAqIC0gYHBhdGhgOiB0aGUgcGF0aCB0byB1c2UgaW4gYW4gU1ZHIGA8cGF0aD5gIGVsZW1lbnQuXG4gKiAtIGBsYWJlbFhgOiB0aGUgYHhgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBsYWJlbFlgOiB0aGUgYHlgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBvZmZzZXRYYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB4YCBwb3NpdGlvbiBhbmQgdGhlIGB4YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiAtIGBvZmZzZXRZYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB5YCBwb3NpdGlvbiBhbmQgdGhlIGB5YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqICBjb25zdCBzb3VyY2UgPSB7IHg6IDAsIHk6IDIwIH07XG4gKiAgY29uc3QgdGFyZ2V0ID0geyB4OiAxNTAsIHk6IDEwMCB9O1xuICpcbiAqICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyUGF0aCh7XG4gKiAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAqICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICogICAgc291cmNlUG9zaXRpb246IFBvc2l0aW9uLlJpZ2h0LFxuICogICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gKiAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAqICAgIHRhcmdldFBvc2l0aW9uOiBQb3NpdGlvbi5MZWZ0LFxuICp9KTtcbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHVwbGUgKGFrYSBhIGZpeGVkLXNpemUgYXJyYXkpIHRvIG1ha2UgaXQgZWFzaWVyIHRvXG4gKndvcmsgd2l0aCBtdWx0aXBsZSBlZGdlIHBhdGhzIGF0IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIGdldEJlemllclBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGN1cnZhdHVyZSA9IDAuMjUsIH0pIHtcbiAgICBjb25zdCBbc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZXSA9IGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgICAgIGM6IGN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCBbdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZXSA9IGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgICAgIGM6IGN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyRWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHNvdXJjZUNvbnRyb2xYLFxuICAgICAgICBzb3VyY2VDb250cm9sWSxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFgsXG4gICAgICAgIHRhcmdldENvbnRyb2xZLFxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGBNJHtzb3VyY2VYfSwke3NvdXJjZVl9IEMke3NvdXJjZUNvbnRyb2xYfSwke3NvdXJjZUNvbnRyb2xZfSAke3RhcmdldENvbnRyb2xYfSwke3RhcmdldENvbnRyb2xZfSAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLFxuICAgICAgICBsYWJlbFgsXG4gICAgICAgIGxhYmVsWSxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICBdO1xufVxuXG4vLyB0aGlzIGlzIHVzZWQgZm9yIHN0cmFpZ2h0IGVkZ2VzIGFuZCBzaW1wbGUgc21vb3Roc3RlcCBlZGdlcyAoTFRSLCBSVEwsIEJUVCwgVFRCKVxuZnVuY3Rpb24gZ2V0RWRnZUNlbnRlcih7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIH0pIHtcbiAgICBjb25zdCB4T2Zmc2V0ID0gTWF0aC5hYnModGFyZ2V0WCAtIHNvdXJjZVgpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJYID0gdGFyZ2V0WCA8IHNvdXJjZVggPyB0YXJnZXRYICsgeE9mZnNldCA6IHRhcmdldFggLSB4T2Zmc2V0O1xuICAgIGNvbnN0IHlPZmZzZXQgPSBNYXRoLmFicyh0YXJnZXRZIC0gc291cmNlWSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSB0YXJnZXRZIDwgc291cmNlWSA/IHRhcmdldFkgKyB5T2Zmc2V0IDogdGFyZ2V0WSAtIHlPZmZzZXQ7XG4gICAgcmV0dXJuIFtjZW50ZXJYLCBjZW50ZXJZLCB4T2Zmc2V0LCB5T2Zmc2V0XTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgei1pbmRleCBmb3IgYW4gZWRnZSBiYXNlZCBvbiB0aGUgbm9kZSBpdCBjb25uZWN0cyBhbmQgd2hldGhlciBpdCBpcyBzZWxlY3RlZC5cbiAqIEJ5IGRlZmF1bHQsIGVkZ2VzIGFyZSByZW5kZXJlZCBiZWxvdyBub2Rlcy4gVGhpcyBiZWhhdmlvdXIgaXMgZGlmZmVyZW50IGZvciBlZGdlcyB0aGF0IGFyZVxuICogY29ubmVjdGVkIHRvIG5vZGVzIHdpdGggYSBwYXJlbnQsIGFzIHRoZXkgYXJlIHJlbmRlcmVkIGFib3ZlIHRoZSBwYXJlbnQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RWxldmF0ZWRFZGdlWkluZGV4KHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSwgc2VsZWN0ZWQgPSBmYWxzZSwgekluZGV4LCBlbGV2YXRlT25TZWxlY3QgPSBmYWxzZSwgfSkge1xuICAgIGlmICh6SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gekluZGV4O1xuICAgIH1cbiAgICBjb25zdCBlZGdlWiA9IGVsZXZhdGVPblNlbGVjdCAmJiBzZWxlY3RlZCA/IDEwMDAgOiAwO1xuICAgIGNvbnN0IG5vZGVaID0gTWF0aC5tYXgoc291cmNlTm9kZS5wYXJlbnRJZCB8fCAoZWxldmF0ZU9uU2VsZWN0ICYmIHNvdXJjZU5vZGUuc2VsZWN0ZWQpID8gc291cmNlTm9kZS5pbnRlcm5hbHMueiA6IDAsIHRhcmdldE5vZGUucGFyZW50SWQgfHwgKGVsZXZhdGVPblNlbGVjdCAmJiB0YXJnZXROb2RlLnNlbGVjdGVkKSA/IHRhcmdldE5vZGUuaW50ZXJuYWxzLnogOiAwKTtcbiAgICByZXR1cm4gZWRnZVogKyBub2RlWjtcbn1cbmZ1bmN0aW9uIGlzRWRnZVZpc2libGUoeyBzb3VyY2VOb2RlLCB0YXJnZXROb2RlLCB3aWR0aCwgaGVpZ2h0LCB0cmFuc2Zvcm0gfSkge1xuICAgIGNvbnN0IGVkZ2VCb3ggPSBnZXRCb3VuZHNPZkJveGVzKG5vZGVUb0JveChzb3VyY2VOb2RlKSwgbm9kZVRvQm94KHRhcmdldE5vZGUpKTtcbiAgICBpZiAoZWRnZUJveC54ID09PSBlZGdlQm94LngyKSB7XG4gICAgICAgIGVkZ2VCb3gueDIgKz0gMTtcbiAgICB9XG4gICAgaWYgKGVkZ2VCb3gueSA9PT0gZWRnZUJveC55Mikge1xuICAgICAgICBlZGdlQm94LnkyICs9IDE7XG4gICAgfVxuICAgIGNvbnN0IHZpZXdSZWN0ID0ge1xuICAgICAgICB4OiAtdHJhbnNmb3JtWzBdIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICB5OiAtdHJhbnNmb3JtWzFdIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICB3aWR0aDogd2lkdGggLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIGhlaWdodDogaGVpZ2h0IC8gdHJhbnNmb3JtWzJdLFxuICAgIH07XG4gICAgcmV0dXJuIGdldE92ZXJsYXBwaW5nQXJlYSh2aWV3UmVjdCwgYm94VG9SZWN0KGVkZ2VCb3gpKSA+IDA7XG59XG5jb25zdCBnZXRFZGdlSWQgPSAoeyBzb3VyY2UsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0LCB0YXJnZXRIYW5kbGUgfSkgPT4gYHh5LWVkZ2VfXyR7c291cmNlfSR7c291cmNlSGFuZGxlIHx8ICcnfS0ke3RhcmdldH0ke3RhcmdldEhhbmRsZSB8fCAnJ31gO1xuY29uc3QgY29ubmVjdGlvbkV4aXN0cyA9IChlZGdlLCBlZGdlcykgPT4ge1xuICAgIHJldHVybiBlZGdlcy5zb21lKChlbCkgPT4gZWwuc291cmNlID09PSBlZGdlLnNvdXJjZSAmJlxuICAgICAgICBlbC50YXJnZXQgPT09IGVkZ2UudGFyZ2V0ICYmXG4gICAgICAgIChlbC5zb3VyY2VIYW5kbGUgPT09IGVkZ2Uuc291cmNlSGFuZGxlIHx8ICghZWwuc291cmNlSGFuZGxlICYmICFlZGdlLnNvdXJjZUhhbmRsZSkpICYmXG4gICAgICAgIChlbC50YXJnZXRIYW5kbGUgPT09IGVkZ2UudGFyZ2V0SGFuZGxlIHx8ICghZWwudGFyZ2V0SGFuZGxlICYmICFlZGdlLnRhcmdldEhhbmRsZSkpKTtcbn07XG4vKipcbiAqIFRoaXMgdXRpbCBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFkZCBhIG5ldyBFZGdlIHRvIGFuIGFycmF5IG9mIGVkZ2VzLiBJdCBhbHNvIHBlcmZvcm1zIHNvbWUgdmFsaWRhdGlvbiB0byBtYWtlIHN1cmUgeW91IGRvbid0IGFkZCBhbiBpbnZhbGlkIGVkZ2Ugb3IgZHVwbGljYXRlIGFuIGV4aXN0aW5nIG9uZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBlZGdlUGFyYW1zIC0gRWl0aGVyIGFuIGBFZGdlYCBvciBhIGBDb25uZWN0aW9uYCB5b3Ugd2FudCB0byBhZGQuXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGN1cnJlbnQgZWRnZXMuXG4gKiBAcmV0dXJucyBBIG5ldyBhcnJheSBvZiBlZGdlcyB3aXRoIHRoZSBuZXcgZWRnZSBhZGRlZC5cbiAqXG4gKiBAcmVtYXJrcyBJZiBhbiBlZGdlIHdpdGggdGhlIHNhbWUgYHRhcmdldGAgYW5kIGBzb3VyY2VgIGFscmVhZHkgZXhpc3RzIChhbmQgdGhlIHNhbWVcbiAqYHRhcmdldEhhbmRsZWAgYW5kIGBzb3VyY2VIYW5kbGVgIGlmIHRob3NlIGFyZSBzZXQpLCB0aGVuIHRoaXMgdXRpbCB3b24ndCBhZGRcbiAqYSBuZXcgZWRnZSBldmVuIGlmIHRoZSBgaWRgIHByb3BlcnR5IGlzIGRpZmZlcmVudC5cbiAqXG4gKi9cbmNvbnN0IGFkZEVkZ2UgPSAoZWRnZVBhcmFtcywgZWRnZXMpID0+IHtcbiAgICBpZiAoIWVkZ2VQYXJhbXMuc291cmNlIHx8ICFlZGdlUGFyYW1zLnRhcmdldCkge1xuICAgICAgICBkZXZXYXJuKCcwMDYnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNiddKCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGxldCBlZGdlO1xuICAgIGlmIChpc0VkZ2VCYXNlKGVkZ2VQYXJhbXMpKSB7XG4gICAgICAgIGVkZ2UgPSB7IC4uLmVkZ2VQYXJhbXMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVkZ2UgPSB7XG4gICAgICAgICAgICAuLi5lZGdlUGFyYW1zLFxuICAgICAgICAgICAgaWQ6IGdldEVkZ2VJZChlZGdlUGFyYW1zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25FeGlzdHMoZWRnZSwgZWRnZXMpKSB7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgaWYgKGVkZ2Uuc291cmNlSGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBlZGdlLnNvdXJjZUhhbmRsZTtcbiAgICB9XG4gICAgaWYgKGVkZ2UudGFyZ2V0SGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBlZGdlLnRhcmdldEhhbmRsZTtcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2VzLmNvbmNhdChlZGdlKTtcbn07XG4vKipcbiAqIEEgaGFuZHkgdXRpbGl0eSB0byB1cGRhdGUgYW4gZXhpc3RpbmcgW2BFZGdlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZSkgd2l0aCBuZXcgcHJvcGVydGllcy5cbiAqVGhpcyBzZWFyY2hlcyB5b3VyIGVkZ2UgYXJyYXkgZm9yIGFuIGVkZ2Ugd2l0aCBhIG1hdGNoaW5nIGBpZGAgYW5kIHVwZGF0ZXMgaXRzXG4gKnByb3BlcnRpZXMgd2l0aCB0aGUgY29ubmVjdGlvbiB5b3UgcHJvdmlkZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBvbGRFZGdlIC0gVGhlIGVkZ2UgeW91IHdhbnQgdG8gdXBkYXRlLlxuICogQHBhcmFtIG5ld0Nvbm5lY3Rpb24gLSBUaGUgbmV3IGNvbm5lY3Rpb24geW91IHdhbnQgdG8gdXBkYXRlIHRoZSBlZGdlIHdpdGguXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGN1cnJlbnQgZWRnZXMuXG4gKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBlZGdlcyBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqY29uc3Qgb25SZWNvbm5lY3QgPSB1c2VDYWxsYmFjayhcbiAqICAob2xkRWRnZTogRWRnZSwgbmV3Q29ubmVjdGlvbjogQ29ubmVjdGlvbikgPT4gc2V0RWRnZXMoKGVscykgPT4gcmVjb25uZWN0RWRnZShvbGRFZGdlLCBuZXdDb25uZWN0aW9uLCBlbHMpKSxbXSk7XG4gKmBgYFxuICovXG5jb25zdCByZWNvbm5lY3RFZGdlID0gKG9sZEVkZ2UsIG5ld0Nvbm5lY3Rpb24sIGVkZ2VzLCBvcHRpb25zID0geyBzaG91bGRSZXBsYWNlSWQ6IHRydWUgfSkgPT4ge1xuICAgIGNvbnN0IHsgaWQ6IG9sZEVkZ2VJZCwgLi4ucmVzdCB9ID0gb2xkRWRnZTtcbiAgICBpZiAoIW5ld0Nvbm5lY3Rpb24uc291cmNlIHx8ICFuZXdDb25uZWN0aW9uLnRhcmdldCkge1xuICAgICAgICBkZXZXYXJuKCcwMDYnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNiddKCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGNvbnN0IGZvdW5kRWRnZSA9IGVkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IG9sZEVkZ2UuaWQpO1xuICAgIGlmICghZm91bmRFZGdlKSB7XG4gICAgICAgIGRldldhcm4oJzAwNycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA3J10ob2xkRWRnZUlkKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgLy8gUmVtb3ZlIG9sZCBlZGdlIGFuZCBjcmVhdGUgdGhlIG5ldyBlZGdlIHdpdGggcGFyYW1ldGVycyBvZiBvbGQgZWRnZS5cbiAgICBjb25zdCBlZGdlID0ge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICBpZDogb3B0aW9ucy5zaG91bGRSZXBsYWNlSWQgPyBnZXRFZGdlSWQobmV3Q29ubmVjdGlvbikgOiBvbGRFZGdlSWQsXG4gICAgICAgIHNvdXJjZTogbmV3Q29ubmVjdGlvbi5zb3VyY2UsXG4gICAgICAgIHRhcmdldDogbmV3Q29ubmVjdGlvbi50YXJnZXQsXG4gICAgICAgIHNvdXJjZUhhbmRsZTogbmV3Q29ubmVjdGlvbi5zb3VyY2VIYW5kbGUsXG4gICAgICAgIHRhcmdldEhhbmRsZTogbmV3Q29ubmVjdGlvbi50YXJnZXRIYW5kbGUsXG4gICAgfTtcbiAgICByZXR1cm4gZWRnZXMuZmlsdGVyKChlKSA9PiBlLmlkICE9PSBvbGRFZGdlSWQpLmNvbmNhdChlZGdlKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3RyYWlnaHQgbGluZSBwYXRoIGJldHdlZW4gdHdvIHBvaW50cy5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEEgcGF0aCBzdHJpbmcgeW91IGNhbiB1c2UgaW4gYW4gU1ZHLCB0aGUgYGxhYmVsWGAgYW5kIGBsYWJlbFlgIHBvc2l0aW9uIChjZW50ZXIgb2YgcGF0aClcbiAqIGFuZCBgb2Zmc2V0WGAsIGBvZmZzZXRZYCBiZXR3ZWVuIHNvdXJjZSBoYW5kbGUgYW5kIGxhYmVsLlxuICpcbiAqIC0gYHBhdGhgOiB0aGUgcGF0aCB0byB1c2UgaW4gYW4gU1ZHIGA8cGF0aD5gIGVsZW1lbnQuXG4gKiAtIGBsYWJlbFhgOiB0aGUgYHhgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBsYWJlbFlgOiB0aGUgYHlgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBvZmZzZXRYYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB4YCBwb3NpdGlvbiBhbmQgdGhlIGB4YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiAtIGBvZmZzZXRZYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB5YCBwb3NpdGlvbiBhbmQgdGhlIGB5YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqICBjb25zdCBzb3VyY2UgPSB7IHg6IDAsIHk6IDIwIH07XG4gKiAgY29uc3QgdGFyZ2V0ID0geyB4OiAxNTAsIHk6IDEwMCB9O1xuICpcbiAqICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0U3RyYWlnaHRQYXRoKHtcbiAqICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICogICAgc291cmNlWTogc291cmNlLnksXG4gKiAgICBzb3VyY2VQb3NpdGlvbjogUG9zaXRpb24uUmlnaHQsXG4gKiAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAqICAgIHRhcmdldFk6IHRhcmdldC55LFxuICogICAgdGFyZ2V0UG9zaXRpb246IFBvc2l0aW9uLkxlZnQsXG4gKiAgfSk7XG4gKiBgYGBcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHR1cGxlIChha2EgYSBmaXhlZC1zaXplIGFycmF5KSB0byBtYWtlIGl0IGVhc2llciB0byB3b3JrIHdpdGggbXVsdGlwbGUgZWRnZSBwYXRocyBhdCBvbmNlLlxuICovXG5mdW5jdGlvbiBnZXRTdHJhaWdodFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCB9KSB7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgIH0pO1xuICAgIHJldHVybiBbYE0gJHtzb3VyY2VYfSwke3NvdXJjZVl9TCAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV07XG59XG5cbmNvbnN0IGhhbmRsZURpcmVjdGlvbnMgPSB7XG4gICAgW1Bvc2l0aW9uLkxlZnRdOiB7IHg6IC0xLCB5OiAwIH0sXG4gICAgW1Bvc2l0aW9uLlJpZ2h0XTogeyB4OiAxLCB5OiAwIH0sXG4gICAgW1Bvc2l0aW9uLlRvcF06IHsgeDogMCwgeTogLTEgfSxcbiAgICBbUG9zaXRpb24uQm90dG9tXTogeyB4OiAwLCB5OiAxIH0sXG59O1xuY29uc3QgZ2V0RGlyZWN0aW9uID0gKHsgc291cmNlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0LCB9KSA9PiB7XG4gICAgaWYgKHNvdXJjZVBvc2l0aW9uID09PSBQb3NpdGlvbi5MZWZ0IHx8IHNvdXJjZVBvc2l0aW9uID09PSBQb3NpdGlvbi5SaWdodCkge1xuICAgICAgICByZXR1cm4gc291cmNlLnggPCB0YXJnZXQueCA/IHsgeDogMSwgeTogMCB9IDogeyB4OiAtMSwgeTogMCB9O1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlLnkgPCB0YXJnZXQueSA/IHsgeDogMCwgeTogMSB9IDogeyB4OiAwLCB5OiAtMSB9O1xufTtcbmNvbnN0IGRpc3RhbmNlID0gKGEsIGIpID0+IE1hdGguc3FydChNYXRoLnBvdyhiLnggLSBhLngsIDIpICsgTWF0aC5wb3coYi55IC0gYS55LCAyKSk7XG4vKlxuICogV2l0aCB0aGlzIGZ1bmN0aW9uIHdlIHRyeSB0byBtaW1pYyBhbiBvcnRob2dvbmFsIGVkZ2Ugcm91dGluZyBiZWhhdmlvdXJcbiAqIEl0J3Mgbm90IGFzIGdvb2QgYXMgYSByZWFsIG9ydGhvZ29uYWwgZWRnZSByb3V0aW5nLCBidXQgaXQncyBmYXN0ZXIgYW5kIGdvb2QgZW5vdWdoIGFzIGEgZGVmYXVsdCBmb3Igc3RlcCBhbmQgc21vb3RoIHN0ZXAgZWRnZXNcbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRzKHsgc291cmNlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0LCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgY2VudGVyLCBvZmZzZXQsIHN0ZXBQb3NpdGlvbiwgfSkge1xuICAgIGNvbnN0IHNvdXJjZURpciA9IGhhbmRsZURpcmVjdGlvbnNbc291cmNlUG9zaXRpb25dO1xuICAgIGNvbnN0IHRhcmdldERpciA9IGhhbmRsZURpcmVjdGlvbnNbdGFyZ2V0UG9zaXRpb25dO1xuICAgIGNvbnN0IHNvdXJjZUdhcHBlZCA9IHsgeDogc291cmNlLnggKyBzb3VyY2VEaXIueCAqIG9mZnNldCwgeTogc291cmNlLnkgKyBzb3VyY2VEaXIueSAqIG9mZnNldCB9O1xuICAgIGNvbnN0IHRhcmdldEdhcHBlZCA9IHsgeDogdGFyZ2V0LnggKyB0YXJnZXREaXIueCAqIG9mZnNldCwgeTogdGFyZ2V0LnkgKyB0YXJnZXREaXIueSAqIG9mZnNldCB9O1xuICAgIGNvbnN0IGRpciA9IGdldERpcmVjdGlvbih7XG4gICAgICAgIHNvdXJjZTogc291cmNlR2FwcGVkLFxuICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRHYXBwZWQsXG4gICAgfSk7XG4gICAgY29uc3QgZGlyQWNjZXNzb3IgPSBkaXIueCAhPT0gMCA/ICd4JyA6ICd5JztcbiAgICBjb25zdCBjdXJyRGlyID0gZGlyW2RpckFjY2Vzc29yXTtcbiAgICBsZXQgcG9pbnRzID0gW107XG4gICAgbGV0IGNlbnRlclgsIGNlbnRlclk7XG4gICAgY29uc3Qgc291cmNlR2FwT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gICAgY29uc3QgdGFyZ2V0R2FwT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gICAgY29uc3QgWywgLCBkZWZhdWx0T2Zmc2V0WCwgZGVmYXVsdE9mZnNldFldID0gZ2V0RWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICAgICAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAgICAgICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gICAgICAgIHRhcmdldFk6IHRhcmdldC55LFxuICAgIH0pO1xuICAgIC8vIG9wcG9zaXRlIGhhbmRsZSBwb3NpdGlvbnMsIGRlZmF1bHQgY2FzZVxuICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdICogdGFyZ2V0RGlyW2RpckFjY2Vzc29yXSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGRpckFjY2Vzc29yID09PSAneCcpIHtcbiAgICAgICAgICAgIC8vIFByaW1hcnkgZGlyZWN0aW9uIGlzIGhvcml6b250YWwsIHNvIHN0ZXBQb3NpdGlvbiBhZmZlY3RzIFggY29vcmRpbmF0ZVxuICAgICAgICAgICAgY2VudGVyWCA9IGNlbnRlci54ID8/IChzb3VyY2VHYXBwZWQueCArICh0YXJnZXRHYXBwZWQueCAtIHNvdXJjZUdhcHBlZC54KSAqIHN0ZXBQb3NpdGlvbik7XG4gICAgICAgICAgICBjZW50ZXJZID0gY2VudGVyLnkgPz8gKHNvdXJjZUdhcHBlZC55ICsgdGFyZ2V0R2FwcGVkLnkpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFByaW1hcnkgZGlyZWN0aW9uIGlzIHZlcnRpY2FsLCBzbyBzdGVwUG9zaXRpb24gYWZmZWN0cyBZIGNvb3JkaW5hdGUgIFxuICAgICAgICAgICAgY2VudGVyWCA9IGNlbnRlci54ID8/IChzb3VyY2VHYXBwZWQueCArIHRhcmdldEdhcHBlZC54KSAvIDI7XG4gICAgICAgICAgICBjZW50ZXJZID0gY2VudGVyLnkgPz8gKHNvdXJjZUdhcHBlZC55ICsgKHRhcmdldEdhcHBlZC55IC0gc291cmNlR2FwcGVkLnkpICogc3RlcFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiAgICAtLS0+XG4gICAgICAgICAqICAgIHxcbiAgICAgICAgICogPi0tLVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdmVydGljYWxTcGxpdCA9IFtcbiAgICAgICAgICAgIHsgeDogY2VudGVyWCwgeTogc291cmNlR2FwcGVkLnkgfSxcbiAgICAgICAgICAgIHsgeDogY2VudGVyWCwgeTogdGFyZ2V0R2FwcGVkLnkgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLypcbiAgICAgICAgICogICAgfFxuICAgICAgICAgKiAgLS0tXG4gICAgICAgICAqICB8XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBob3Jpem9udGFsU3BsaXQgPSBbXG4gICAgICAgICAgICB7IHg6IHNvdXJjZUdhcHBlZC54LCB5OiBjZW50ZXJZIH0sXG4gICAgICAgICAgICB7IHg6IHRhcmdldEdhcHBlZC54LCB5OiBjZW50ZXJZIH0sXG4gICAgICAgIF07XG4gICAgICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSBjdXJyRGlyKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gdmVydGljYWxTcGxpdCA6IGhvcml6b250YWxTcGxpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyBob3Jpem9udGFsU3BsaXQgOiB2ZXJ0aWNhbFNwbGl0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzb3VyY2VUYXJnZXQgbWVhbnMgd2UgdGFrZSB4IGZyb20gc291cmNlIGFuZCB5IGZyb20gdGFyZ2V0LCB0YXJnZXRTb3VyY2UgaXMgdGhlIG9wcG9zaXRlXG4gICAgICAgIGNvbnN0IHNvdXJjZVRhcmdldCA9IFt7IHg6IHNvdXJjZUdhcHBlZC54LCB5OiB0YXJnZXRHYXBwZWQueSB9XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0U291cmNlID0gW3sgeDogdGFyZ2V0R2FwcGVkLngsIHk6IHNvdXJjZUdhcHBlZC55IH1dO1xuICAgICAgICAvLyB0aGlzIGhhbmRsZXMgZWRnZXMgd2l0aCBzYW1lIGhhbmRsZSBwb3NpdGlvbnNcbiAgICAgICAgaWYgKGRpckFjY2Vzc29yID09PSAneCcpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHNvdXJjZURpci54ID09PSBjdXJyRGlyID8gdGFyZ2V0U291cmNlIDogc291cmNlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gc291cmNlRGlyLnkgPT09IGN1cnJEaXIgPyBzb3VyY2VUYXJnZXQgOiB0YXJnZXRTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVBvc2l0aW9uID09PSB0YXJnZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKHNvdXJjZVtkaXJBY2Nlc3Nvcl0gLSB0YXJnZXRbZGlyQWNjZXNzb3JdKTtcbiAgICAgICAgICAgIC8vIGlmIGFuIGVkZ2UgZ29lcyBmcm9tIHJpZ2h0IHRvIHJpZ2h0IGZvciBleGFtcGxlIChzb3VyY2VQb3NpdGlvbiA9PT0gdGFyZ2V0UG9zaXRpb24pIGFuZCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBzb3VyY2UueCBhbmQgdGFyZ2V0LnggaXMgbGVzcyB0aGFuIHRoZSBvZmZzZXQsIHRoZSBhZGRlZCBwb2ludCBhbmQgdGhlIGdhcHBlZCBzb3VyY2UvdGFyZ2V0IHdpbGwgb3ZlcmxhcC4gVGhpcyBsZWFkcyB0byBhIHdlaXJkIGVkZ2UgcGF0aC4gVG8gYXZvaWQgdGhpcyB3ZSBhZGQgYSBnYXBPZmZzZXQgdG8gdGhlIHNvdXJjZS90YXJnZXRcbiAgICAgICAgICAgIGlmIChkaWZmIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhcE9mZnNldCA9IE1hdGgubWluKG9mZnNldCAtIDEsIG9mZnNldCAtIGRpZmYpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSBjdXJyRGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUdhcE9mZnNldFtkaXJBY2Nlc3Nvcl0gPSAoc291cmNlR2FwcGVkW2RpckFjY2Vzc29yXSA+IHNvdXJjZVtkaXJBY2Nlc3Nvcl0gPyAtMSA6IDEpICogZ2FwT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0R2FwT2Zmc2V0W2RpckFjY2Vzc29yXSA9ICh0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JdID4gdGFyZ2V0W2RpckFjY2Vzc29yXSA/IC0xIDogMSkgKiBnYXBPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZXNlIGFyZSBjb25kaXRpb25zIGZvciBoYW5kbGluZyBtaXhlZCBoYW5kbGUgcG9zaXRpb25zIGxpa2UgUmlnaHQgLT4gQm90dG9tIGZvciBleGFtcGxlXG4gICAgICAgIGlmIChzb3VyY2VQb3NpdGlvbiAhPT0gdGFyZ2V0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpckFjY2Vzc29yT3Bwb3NpdGUgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICAgICAgICAgICAgY29uc3QgaXNTYW1lRGlyID0gc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gdGFyZ2V0RGlyW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlR3RUYXJnZXRPcHBvID0gc291cmNlR2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdID4gdGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlTHRUYXJnZXRPcHBvID0gc291cmNlR2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdIDwgdGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3QgZmxpcFNvdXJjZVRhcmdldCA9IChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSAxICYmICgoIWlzU2FtZURpciAmJiBzb3VyY2VHdFRhcmdldE9wcG8pIHx8IChpc1NhbWVEaXIgJiYgc291cmNlTHRUYXJnZXRPcHBvKSkpIHx8XG4gICAgICAgICAgICAgICAgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gIT09IDEgJiYgKCghaXNTYW1lRGlyICYmIHNvdXJjZUx0VGFyZ2V0T3BwbykgfHwgKGlzU2FtZURpciAmJiBzb3VyY2VHdFRhcmdldE9wcG8pKSk7XG4gICAgICAgICAgICBpZiAoZmxpcFNvdXJjZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyBzb3VyY2VUYXJnZXQgOiB0YXJnZXRTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlR2FwUG9pbnQgPSB7IHg6IHNvdXJjZUdhcHBlZC54ICsgc291cmNlR2FwT2Zmc2V0LngsIHk6IHNvdXJjZUdhcHBlZC55ICsgc291cmNlR2FwT2Zmc2V0LnkgfTtcbiAgICAgICAgY29uc3QgdGFyZ2V0R2FwUG9pbnQgPSB7IHg6IHRhcmdldEdhcHBlZC54ICsgdGFyZ2V0R2FwT2Zmc2V0LngsIHk6IHRhcmdldEdhcHBlZC55ICsgdGFyZ2V0R2FwT2Zmc2V0LnkgfTtcbiAgICAgICAgY29uc3QgbWF4WERpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5hYnMoc291cmNlR2FwUG9pbnQueCAtIHBvaW50c1swXS54KSwgTWF0aC5hYnModGFyZ2V0R2FwUG9pbnQueCAtIHBvaW50c1swXS54KSk7XG4gICAgICAgIGNvbnN0IG1heFlEaXN0YW5jZSA9IE1hdGgubWF4KE1hdGguYWJzKHNvdXJjZUdhcFBvaW50LnkgLSBwb2ludHNbMF0ueSksIE1hdGguYWJzKHRhcmdldEdhcFBvaW50LnkgLSBwb2ludHNbMF0ueSkpO1xuICAgICAgICAvLyB3ZSB3YW50IHRvIHBsYWNlIHRoZSBsYWJlbCBvbiB0aGUgbG9uZ2VzdCBzZWdtZW50IG9mIHRoZSBlZGdlXG4gICAgICAgIGlmIChtYXhYRGlzdGFuY2UgPj0gbWF4WURpc3RhbmNlKSB7XG4gICAgICAgICAgICBjZW50ZXJYID0gKHNvdXJjZUdhcFBvaW50LnggKyB0YXJnZXRHYXBQb2ludC54KSAvIDI7XG4gICAgICAgICAgICBjZW50ZXJZID0gcG9pbnRzWzBdLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjZW50ZXJYID0gcG9pbnRzWzBdLng7XG4gICAgICAgICAgICBjZW50ZXJZID0gKHNvdXJjZUdhcFBvaW50LnkgKyB0YXJnZXRHYXBQb2ludC55KSAvIDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGF0aFBvaW50cyA9IFtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB7IHg6IHNvdXJjZUdhcHBlZC54ICsgc291cmNlR2FwT2Zmc2V0LngsIHk6IHNvdXJjZUdhcHBlZC55ICsgc291cmNlR2FwT2Zmc2V0LnkgfSxcbiAgICAgICAgLi4ucG9pbnRzLFxuICAgICAgICB7IHg6IHRhcmdldEdhcHBlZC54ICsgdGFyZ2V0R2FwT2Zmc2V0LngsIHk6IHRhcmdldEdhcHBlZC55ICsgdGFyZ2V0R2FwT2Zmc2V0LnkgfSxcbiAgICAgICAgdGFyZ2V0LFxuICAgIF07XG4gICAgcmV0dXJuIFtwYXRoUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCBkZWZhdWx0T2Zmc2V0WCwgZGVmYXVsdE9mZnNldFldO1xufVxuZnVuY3Rpb24gZ2V0QmVuZChhLCBiLCBjLCBzaXplKSB7XG4gICAgY29uc3QgYmVuZFNpemUgPSBNYXRoLm1pbihkaXN0YW5jZShhLCBiKSAvIDIsIGRpc3RhbmNlKGIsIGMpIC8gMiwgc2l6ZSk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBiO1xuICAgIC8vIG5vIGJlbmRcbiAgICBpZiAoKGEueCA9PT0geCAmJiB4ID09PSBjLngpIHx8IChhLnkgPT09IHkgJiYgeSA9PT0gYy55KSkge1xuICAgICAgICByZXR1cm4gYEwke3h9ICR7eX1gO1xuICAgIH1cbiAgICAvLyBmaXJzdCBzZWdtZW50IGlzIGhvcml6b250YWxcbiAgICBpZiAoYS55ID09PSB5KSB7XG4gICAgICAgIGNvbnN0IHhEaXIgPSBhLnggPCBjLnggPyAtMSA6IDE7XG4gICAgICAgIGNvbnN0IHlEaXIgPSBhLnkgPCBjLnkgPyAxIDogLTE7XG4gICAgICAgIHJldHVybiBgTCAke3ggKyBiZW5kU2l6ZSAqIHhEaXJ9LCR7eX1RICR7eH0sJHt5fSAke3h9LCR7eSArIGJlbmRTaXplICogeURpcn1gO1xuICAgIH1cbiAgICBjb25zdCB4RGlyID0gYS54IDwgYy54ID8gMSA6IC0xO1xuICAgIGNvbnN0IHlEaXIgPSBhLnkgPCBjLnkgPyAtMSA6IDE7XG4gICAgcmV0dXJuIGBMICR7eH0sJHt5ICsgYmVuZFNpemUgKiB5RGlyfVEgJHt4fSwke3l9ICR7eCArIGJlbmRTaXplICogeERpcn0sJHt5fWA7XG59XG4vKipcbiAqIFRoZSBgZ2V0U21vb3RoU3RlcFBhdGhgIHV0aWwgcmV0dXJucyBldmVyeXRoaW5nIHlvdSBuZWVkIHRvIHJlbmRlciBhIHN0ZXBwZWQgcGF0aFxuICogYmV0d2VlbiB0d28gbm9kZXMuIFRoZSBgYm9yZGVyUmFkaXVzYCBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBjaG9vc2UgaG93IHJvdW5kZWRcbiAqIHRoZSBjb3JuZXJzIG9mIHRob3NlIHN0ZXBzIGFyZS5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEEgcGF0aCBzdHJpbmcgeW91IGNhbiB1c2UgaW4gYW4gU1ZHLCB0aGUgYGxhYmVsWGAgYW5kIGBsYWJlbFlgIHBvc2l0aW9uIChjZW50ZXIgb2YgcGF0aClcbiAqIGFuZCBgb2Zmc2V0WGAsIGBvZmZzZXRZYCBiZXR3ZWVuIHNvdXJjZSBoYW5kbGUgYW5kIGxhYmVsLlxuICpcbiAqIC0gYHBhdGhgOiB0aGUgcGF0aCB0byB1c2UgaW4gYW4gU1ZHIGA8cGF0aD5gIGVsZW1lbnQuXG4gKiAtIGBsYWJlbFhgOiB0aGUgYHhgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBsYWJlbFlgOiB0aGUgYHlgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBvZmZzZXRYYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB4YCBwb3NpdGlvbiBhbmQgdGhlIGB4YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiAtIGBvZmZzZXRZYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB5YCBwb3NpdGlvbiBhbmQgdGhlIGB5YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqICBjb25zdCBzb3VyY2UgPSB7IHg6IDAsIHk6IDIwIH07XG4gKiAgY29uc3QgdGFyZ2V0ID0geyB4OiAxNTAsIHk6IDEwMCB9O1xuICpcbiAqICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0U21vb3RoU3RlcFBhdGgoe1xuICogICAgc291cmNlWDogc291cmNlLngsXG4gKiAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAqICAgIHNvdXJjZVBvc2l0aW9uOiBQb3NpdGlvbi5SaWdodCxcbiAqICAgIHRhcmdldFg6IHRhcmdldC54LFxuICogICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gKiAgICB0YXJnZXRQb3NpdGlvbjogUG9zaXRpb24uTGVmdCxcbiAqICB9KTtcbiAqIGBgYFxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHVwbGUgKGFrYSBhIGZpeGVkLXNpemUgYXJyYXkpIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHdvcmsgd2l0aCBtdWx0aXBsZSBlZGdlIHBhdGhzIGF0IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFNtb290aFN0ZXBQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBib3JkZXJSYWRpdXMgPSA1LCBjZW50ZXJYLCBjZW50ZXJZLCBvZmZzZXQgPSAyMCwgc3RlcFBvc2l0aW9uID0gMC41LCB9KSB7XG4gICAgY29uc3QgW3BvaW50cywgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0UG9pbnRzKHtcbiAgICAgICAgc291cmNlOiB7IHg6IHNvdXJjZVgsIHk6IHNvdXJjZVkgfSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldDogeyB4OiB0YXJnZXRYLCB5OiB0YXJnZXRZIH0sXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICBjZW50ZXI6IHsgeDogY2VudGVyWCwgeTogY2VudGVyWSB9LFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHN0ZXBQb3NpdGlvbixcbiAgICB9KTtcbiAgICBjb25zdCBwYXRoID0gcG9pbnRzLnJlZHVjZSgocmVzLCBwLCBpKSA9PiB7XG4gICAgICAgIGxldCBzZWdtZW50ID0gJyc7XG4gICAgICAgIGlmIChpID4gMCAmJiBpIDwgcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBnZXRCZW5kKHBvaW50c1tpIC0gMV0sIHAsIHBvaW50c1tpICsgMV0sIGJvcmRlclJhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gYCR7aSA9PT0gMCA/ICdNJyA6ICdMJ30ke3AueH0gJHtwLnl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXMgKz0gc2VnbWVudDtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCAnJyk7XG4gICAgcmV0dXJuIFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV07XG59XG5cbmZ1bmN0aW9uIGlzTm9kZUluaXRpYWxpemVkKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgJiZcbiAgICAgICAgISEobm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzIHx8IG5vZGUuaGFuZGxlcz8ubGVuZ3RoKSAmJlxuICAgICAgICAhIShub2RlLm1lYXN1cmVkLndpZHRoIHx8IG5vZGUud2lkdGggfHwgbm9kZS5pbml0aWFsV2lkdGgpKTtcbn1cbmZ1bmN0aW9uIGdldEVkZ2VQb3NpdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCB7IHNvdXJjZU5vZGUsIHRhcmdldE5vZGUgfSA9IHBhcmFtcztcbiAgICBpZiAoIWlzTm9kZUluaXRpYWxpemVkKHNvdXJjZU5vZGUpIHx8ICFpc05vZGVJbml0aWFsaXplZCh0YXJnZXROb2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlSGFuZGxlQm91bmRzID0gc291cmNlTm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzIHx8IHRvSGFuZGxlQm91bmRzKHNvdXJjZU5vZGUuaGFuZGxlcyk7XG4gICAgY29uc3QgdGFyZ2V0SGFuZGxlQm91bmRzID0gdGFyZ2V0Tm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzIHx8IHRvSGFuZGxlQm91bmRzKHRhcmdldE5vZGUuaGFuZGxlcyk7XG4gICAgY29uc3Qgc291cmNlSGFuZGxlID0gZ2V0SGFuZGxlJDEoc291cmNlSGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10sIHBhcmFtcy5zb3VyY2VIYW5kbGUpO1xuICAgIGNvbnN0IHRhcmdldEhhbmRsZSA9IGdldEhhbmRsZSQxKFxuICAgIC8vIHdoZW4gY29ubmVjdGlvbiB0eXBlIGlzIGxvb3NlIHdlIGNhbiBkZWZpbmUgYWxsIGhhbmRsZXMgYXMgc291cmNlcyBhbmQgY29ubmVjdCBzb3VyY2UgLT4gc291cmNlXG4gICAgcGFyYW1zLmNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5TdHJpY3RcbiAgICAgICAgPyB0YXJnZXRIYW5kbGVCb3VuZHM/LnRhcmdldCA/PyBbXVxuICAgICAgICA6ICh0YXJnZXRIYW5kbGVCb3VuZHM/LnRhcmdldCA/PyBbXSkuY29uY2F0KHRhcmdldEhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdKSwgcGFyYW1zLnRhcmdldEhhbmRsZSk7XG4gICAgaWYgKCFzb3VyY2VIYW5kbGUgfHwgIXRhcmdldEhhbmRsZSkge1xuICAgICAgICBwYXJhbXMub25FcnJvcj8uKCcwMDgnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwOCddKCFzb3VyY2VIYW5kbGUgPyAnc291cmNlJyA6ICd0YXJnZXQnLCB7XG4gICAgICAgICAgICBpZDogcGFyYW1zLmlkLFxuICAgICAgICAgICAgc291cmNlSGFuZGxlOiBwYXJhbXMuc291cmNlSGFuZGxlLFxuICAgICAgICAgICAgdGFyZ2V0SGFuZGxlOiBwYXJhbXMudGFyZ2V0SGFuZGxlLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IHNvdXJjZUhhbmRsZT8ucG9zaXRpb24gfHwgUG9zaXRpb24uQm90dG9tO1xuICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gdGFyZ2V0SGFuZGxlPy5wb3NpdGlvbiB8fCBQb3NpdGlvbi5Ub3A7XG4gICAgY29uc3Qgc291cmNlID0gZ2V0SGFuZGxlUG9zaXRpb24oc291cmNlTm9kZSwgc291cmNlSGFuZGxlLCBzb3VyY2VQb3NpdGlvbik7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0SGFuZGxlUG9zaXRpb24odGFyZ2V0Tm9kZSwgdGFyZ2V0SGFuZGxlLCB0YXJnZXRQb3NpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICAgICAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAgICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9IYW5kbGVCb3VuZHMoaGFuZGxlcykge1xuICAgIGlmICghaGFuZGxlcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gW107XG4gICAgY29uc3QgdGFyZ2V0ID0gW107XG4gICAgZm9yIChjb25zdCBoYW5kbGUgb2YgaGFuZGxlcykge1xuICAgICAgICBoYW5kbGUud2lkdGggPSBoYW5kbGUud2lkdGggPz8gMTtcbiAgICAgICAgaGFuZGxlLmhlaWdodCA9IGhhbmRsZS5oZWlnaHQgPz8gMTtcbiAgICAgICAgaWYgKGhhbmRsZS50eXBlID09PSAnc291cmNlJykge1xuICAgICAgICAgICAgc291cmNlLnB1c2goaGFuZGxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYW5kbGUudHlwZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZVBvc2l0aW9uKG5vZGUsIGhhbmRsZSwgZmFsbGJhY2tQb3NpdGlvbiA9IFBvc2l0aW9uLkxlZnQsIGNlbnRlciA9IGZhbHNlKSB7XG4gICAgY29uc3QgeCA9IChoYW5kbGU/LnggPz8gMCkgKyBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLng7XG4gICAgY29uc3QgeSA9IChoYW5kbGU/LnkgPz8gMCkgKyBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBoYW5kbGUgPz8gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgaWYgKGNlbnRlcikge1xuICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGggLyAyLCB5OiB5ICsgaGVpZ2h0IC8gMiB9O1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbiA9IGhhbmRsZT8ucG9zaXRpb24gPz8gZmFsbGJhY2tQb3NpdGlvbjtcbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uVG9wOlxuICAgICAgICAgICAgcmV0dXJuIHsgeDogeCArIHdpZHRoIC8gMiwgeSB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgcmV0dXJuIHsgeDogeCArIHdpZHRoLCB5OiB5ICsgaGVpZ2h0IC8gMiB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkJvdHRvbTpcbiAgICAgICAgICAgIHJldHVybiB7IHg6IHggKyB3aWR0aCAvIDIsIHk6IHkgKyBoZWlnaHQgfTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeTogeSArIGhlaWdodCAvIDIgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRIYW5kbGUkMShib3VuZHMsIGhhbmRsZUlkKSB7XG4gICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGlmIG5vIGhhbmRsZUlkIGlzIGdpdmVuLCB3ZSB1c2UgdGhlIGZpcnN0IGhhbmRsZSwgb3RoZXJ3aXNlIHdlIGNoZWNrIGZvciB0aGUgaWRcbiAgICByZXR1cm4gKCFoYW5kbGVJZCA/IGJvdW5kc1swXSA6IGJvdW5kcy5maW5kKChkKSA9PiBkLmlkID09PSBoYW5kbGVJZCkpIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmtlcklkKG1hcmtlciwgaWQpIHtcbiAgICBpZiAoIW1hcmtlcikge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWFya2VyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgIH1cbiAgICBjb25zdCBpZFByZWZpeCA9IGlkID8gYCR7aWR9X19gIDogJyc7XG4gICAgcmV0dXJuIGAke2lkUHJlZml4fSR7T2JqZWN0LmtleXMobWFya2VyKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5tYXAoKGtleSkgPT4gYCR7a2V5fT0ke21hcmtlcltrZXldfWApXG4gICAgICAgIC5qb2luKCcmJyl9YDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1hcmtlcklkcyhlZGdlcywgeyBpZCwgZGVmYXVsdENvbG9yLCBkZWZhdWx0TWFya2VyU3RhcnQsIGRlZmF1bHRNYXJrZXJFbmQsIH0pIHtcbiAgICBjb25zdCBpZHMgPSBuZXcgU2V0KCk7XG4gICAgcmV0dXJuIGVkZ2VzXG4gICAgICAgIC5yZWR1Y2UoKG1hcmtlcnMsIGVkZ2UpID0+IHtcbiAgICAgICAgW2VkZ2UubWFya2VyU3RhcnQgfHwgZGVmYXVsdE1hcmtlclN0YXJ0LCBlZGdlLm1hcmtlckVuZCB8fCBkZWZhdWx0TWFya2VyRW5kXS5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXJrZXIgJiYgdHlwZW9mIG1hcmtlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXJJZCA9IGdldE1hcmtlcklkKG1hcmtlciwgaWQpO1xuICAgICAgICAgICAgICAgIGlmICghaWRzLmhhcyhtYXJrZXJJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHsgaWQ6IG1hcmtlcklkLCBjb2xvcjogbWFya2VyLmNvbG9yIHx8IGRlZmF1bHRDb2xvciwgLi4ubWFya2VyIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZHMuYWRkKG1hcmtlcklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFya2VycztcbiAgICB9LCBbXSlcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuaWQubG9jYWxlQ29tcGFyZShiLmlkKSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVUb29sYmFyVHJhbnNmb3JtKG5vZGVSZWN0LCB2aWV3cG9ydCwgcG9zaXRpb24sIG9mZnNldCwgYWxpZ24pIHtcbiAgICBsZXQgYWxpZ25tZW50T2Zmc2V0ID0gMC41O1xuICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBhbGlnbm1lbnRPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgYWxpZ25tZW50T2Zmc2V0ID0gMTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBwb3NpdGlvbiA9PT0gUG9zaXRpb24uVG9wXG4gICAgICogd2Ugc2V0IHRoZSB4IGFueSB5IHBvc2l0aW9uIG9mIHRoZSB0b29sYmFyIGJhc2VkIG9uIHRoZSBub2RlcyBwb3NpdGlvblxuICAgICAqL1xuICAgIGxldCBwb3MgPSBbXG4gICAgICAgIChub2RlUmVjdC54ICsgbm9kZVJlY3Qud2lkdGggKiBhbGlnbm1lbnRPZmZzZXQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LngsXG4gICAgICAgIG5vZGVSZWN0LnkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSAtIG9mZnNldCxcbiAgICBdO1xuICAgIC8vIGFuZCB0aGFuIHNoaWZ0IGl0IGJhc2VkIG9uIHRoZSBhbGlnbm1lbnQuIFRoZSBzaGlmdCB2YWx1ZXMgYXJlIGluICUuXG4gICAgbGV0IHNoaWZ0ID0gWy0xMDAgKiBhbGlnbm1lbnRPZmZzZXQsIC0xMDBdO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5SaWdodDpcbiAgICAgICAgICAgIHBvcyA9IFtcbiAgICAgICAgICAgICAgICAobm9kZVJlY3QueCArIG5vZGVSZWN0LndpZHRoKSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC54ICsgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIChub2RlUmVjdC55ICsgbm9kZVJlY3QuaGVpZ2h0ICogYWxpZ25tZW50T2Zmc2V0KSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHNoaWZ0ID0gWzAsIC0xMDAgKiBhbGlnbm1lbnRPZmZzZXRdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcG9zWzFdID0gKG5vZGVSZWN0LnkgKyBub2RlUmVjdC5oZWlnaHQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnkgKyBvZmZzZXQ7XG4gICAgICAgICAgICBzaGlmdFsxXSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcG9zID0gW1xuICAgICAgICAgICAgICAgIG5vZGVSZWN0LnggKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueCAtIG9mZnNldCxcbiAgICAgICAgICAgICAgICAobm9kZVJlY3QueSArIG5vZGVSZWN0LmhlaWdodCAqIGFsaWdubWVudE9mZnNldCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBzaGlmdCA9IFstMTAwLCAtMTAwICogYWxpZ25tZW50T2Zmc2V0XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3Bvc1swXX1weCwgJHtwb3NbMV19cHgpIHRyYW5zbGF0ZSgke3NoaWZ0WzBdfSUsICR7c2hpZnRbMV19JSlgO1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBub2RlT3JpZ2luOiBbMCwgMF0sXG4gICAgbm9kZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IHRydWUsXG4gICAgZGVmYXVsdHM6IHt9LFxufTtcbmNvbnN0IGFkb3B0VXNlck5vZGVzRGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgY2hlY2tFcXVhbGl0eTogdHJ1ZSxcbn07XG5mdW5jdGlvbiBtZXJnZU9iamVjdHMoYmFzZSwgaW5jb21pbmcpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLmJhc2UgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmNvbWluZykge1xuICAgICAgICBpZiAoaW5jb21pbmdba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0eXBlY2FzdCBpcyBzYWZlIGhlcmUsIGJlY2F1c2Ugd2UgY2hlY2sgZm9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpbmNvbWluZ1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucyhub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMb29rdXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkTm9kZShub2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIF9vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uV2l0aE9yaWdpbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgX29wdGlvbnMubm9kZU9yaWdpbik7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpID8gbm9kZS5leHRlbnQgOiBfb3B0aW9ucy5ub2RlRXh0ZW50O1xuICAgICAgICAgICAgY29uc3QgY2xhbXBlZFBvc2l0aW9uID0gY2xhbXBQb3NpdGlvbihwb3NpdGlvbldpdGhPcmlnaW4sIGV4dGVudCwgZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSkpO1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wZWRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSGFuZGxlcyh1c2VyTm9kZSwgaW50ZXJuYWxOb2RlKSB7XG4gICAgaWYgKCF1c2VyTm9kZS5oYW5kbGVzKSB7XG4gICAgICAgIHJldHVybiAhdXNlck5vZGUubWVhc3VyZWQgPyB1bmRlZmluZWQgOiBpbnRlcm5hbE5vZGU/LmludGVybmFscy5oYW5kbGVCb3VuZHM7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IFtdO1xuICAgIGNvbnN0IHRhcmdldCA9IFtdO1xuICAgIGZvciAoY29uc3QgaGFuZGxlIG9mIHVzZXJOb2RlLmhhbmRsZXMpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlQm91bmRzID0ge1xuICAgICAgICAgICAgd2lkdGg6IGhhbmRsZS53aWR0aCA/PyAxLFxuICAgICAgICAgICAgaGVpZ2h0OiBoYW5kbGUuaGVpZ2h0ID8/IDEsXG4gICAgICAgICAgICBub2RlSWQ6IHVzZXJOb2RlLmlkLFxuICAgICAgICAgICAgeDogaGFuZGxlLngsXG4gICAgICAgICAgICB5OiBoYW5kbGUueSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBoYW5kbGUucG9zaXRpb24sXG4gICAgICAgICAgICB0eXBlOiBoYW5kbGUudHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhhbmRsZS50eXBlID09PSAnc291cmNlJykge1xuICAgICAgICAgICAgc291cmNlLnB1c2goaGFuZGxlQm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYW5kbGUudHlwZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGhhbmRsZUJvdW5kcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhhZG9wdFVzZXJOb2Rlc0RlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBsZXQgbm9kZXNJbml0aWFsaXplZCA9IG5vZGVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgdG1wTG9va3VwID0gbmV3IE1hcChub2RlTG9va3VwKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVaID0gX29wdGlvbnM/LmVsZXZhdGVOb2Rlc09uU2VsZWN0ID8gMTAwMCA6IDA7XG4gICAgbm9kZUxvb2t1cC5jbGVhcigpO1xuICAgIHBhcmVudExvb2t1cC5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgdXNlck5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgbGV0IGludGVybmFsTm9kZSA9IHRtcExvb2t1cC5nZXQodXNlck5vZGUuaWQpO1xuICAgICAgICBpZiAoX29wdGlvbnMuY2hlY2tFcXVhbGl0eSAmJiB1c2VyTm9kZSA9PT0gaW50ZXJuYWxOb2RlPy5pbnRlcm5hbHMudXNlck5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVMb29rdXAuc2V0KHVzZXJOb2RlLmlkLCBpbnRlcm5hbE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25XaXRoT3JpZ2luID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbih1c2VyTm9kZSwgX29wdGlvbnMubm9kZU9yaWdpbik7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBpc0Nvb3JkaW5hdGVFeHRlbnQodXNlck5vZGUuZXh0ZW50KSA/IHVzZXJOb2RlLmV4dGVudCA6IF9vcHRpb25zLm5vZGVFeHRlbnQ7XG4gICAgICAgICAgICBjb25zdCBjbGFtcGVkUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uV2l0aE9yaWdpbiwgZXh0ZW50LCBnZXROb2RlRGltZW5zaW9ucyh1c2VyTm9kZSkpO1xuICAgICAgICAgICAgaW50ZXJuYWxOb2RlID0ge1xuICAgICAgICAgICAgICAgIC4uLl9vcHRpb25zLmRlZmF1bHRzLFxuICAgICAgICAgICAgICAgIC4uLnVzZXJOb2RlLFxuICAgICAgICAgICAgICAgIG1lYXN1cmVkOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB1c2VyTm9kZS5tZWFzdXJlZD8ud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdXNlck5vZGUubWVhc3VyZWQ/LmhlaWdodCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBjbGFtcGVkUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgcmUtaW5pdGlhbGl6ZXMgdGhlIG5vZGUgb3IgcmVtb3ZlcyBgbWVhc3VyZWRgIGZvciB3aGF0ZXZlciByZWFzb24sIHdlIHJlc2V0IHRoZSBoYW5kbGVCb3VuZHMgc28gdGhhdCB0aGUgbm9kZSBnZXRzIHJlLW1lYXN1cmVkXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUJvdW5kczogcGFyc2VIYW5kbGVzKHVzZXJOb2RlLCBpbnRlcm5hbE5vZGUpLFxuICAgICAgICAgICAgICAgICAgICB6OiBjYWxjdWxhdGVaKHVzZXJOb2RlLCBzZWxlY3RlZE5vZGVaKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlck5vZGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldCh1c2VyTm9kZS5pZCwgaW50ZXJuYWxOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGludGVybmFsTm9kZS5tZWFzdXJlZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBpbnRlcm5hbE5vZGUubWVhc3VyZWQud2lkdGggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgaW50ZXJuYWxOb2RlLm1lYXN1cmVkLmhlaWdodCA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgIWludGVybmFsTm9kZS5oaWRkZW4pIHtcbiAgICAgICAgICAgIG5vZGVzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlck5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkTm9kZShpbnRlcm5hbE5vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzSW5pdGlhbGl6ZWQ7XG59XG5mdW5jdGlvbiB1cGRhdGVQYXJlbnRMb29rdXAobm9kZSwgcGFyZW50TG9va3VwKSB7XG4gICAgaWYgKCFub2RlLnBhcmVudElkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHBhcmVudExvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCk7XG4gICAgaWYgKGNoaWxkTm9kZXMpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJlbnRMb29rdXAuc2V0KG5vZGUucGFyZW50SWQsIG5ldyBNYXAoW1tub2RlLmlkLCBub2RlXV0pKTtcbiAgICB9XG59XG4vKipcbiAqIFVwZGF0ZXMgcG9zaXRpb25BYnNvbHV0ZSBhbmQgekluZGV4IG9mIGEgY2hpbGQgbm9kZSBhbmQgdGhlIHBhcmVudExvb2t1cC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlQ2hpbGROb2RlKG5vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgZWxldmF0ZU5vZGVzT25TZWxlY3QsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQgfSA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChwYXJlbnRJZCk7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUGFyZW50IG5vZGUgJHtwYXJlbnRJZH0gbm90IGZvdW5kLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgcGFyZW50IG5vZGVzIGFyZSBpbiBmcm9udCBvZiB0aGVpciBjaGlsZCBub2RlcyBpbiB0aGUgbm9kZXMgYXJyYXkuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlUGFyZW50TG9va3VwKG5vZGUsIHBhcmVudExvb2t1cCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlWiA9IGVsZXZhdGVOb2Rlc09uU2VsZWN0ID8gMTAwMCA6IDA7XG4gICAgY29uc3QgeyB4LCB5LCB6IH0gPSBjYWxjdWxhdGVDaGlsZFhZWihub2RlLCBwYXJlbnROb2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBzZWxlY3RlZE5vZGVaKTtcbiAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IG5vZGUuaW50ZXJuYWxzO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHggIT09IHBvc2l0aW9uQWJzb2x1dGUueCB8fCB5ICE9PSBwb3NpdGlvbkFic29sdXRlLnk7XG4gICAgaWYgKHBvc2l0aW9uQ2hhbmdlZCB8fCB6ICE9PSBub2RlLmludGVybmFscy56KSB7XG4gICAgICAgIC8vIHdlIGNyZWF0ZSBhIG5ldyBvYmplY3QgdG8gbWFyayB0aGUgbm9kZSBhcyB1cGRhdGVkXG4gICAgICAgIG5vZGVMb29rdXAuc2V0KG5vZGUuaWQsIHtcbiAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLmludGVybmFscyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBwb3NpdGlvbkNoYW5nZWQgPyB7IHgsIHkgfSA6IHBvc2l0aW9uQWJzb2x1dGUsXG4gICAgICAgICAgICAgICAgeixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVoobm9kZSwgc2VsZWN0ZWROb2RlWikge1xuICAgIHJldHVybiAoaXNOdW1lcmljKG5vZGUuekluZGV4KSA/IG5vZGUuekluZGV4IDogMCkgKyAobm9kZS5zZWxlY3RlZCA/IHNlbGVjdGVkTm9kZVogOiAwKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNoaWxkWFlaKGNoaWxkTm9kZSwgcGFyZW50Tm9kZSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgc2VsZWN0ZWROb2RlWikge1xuICAgIGNvbnN0IHsgeDogcGFyZW50WCwgeTogcGFyZW50WSB9ID0gcGFyZW50Tm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAgICBjb25zdCBjaGlsZERpbWVuc2lvbnMgPSBnZXROb2RlRGltZW5zaW9ucyhjaGlsZE5vZGUpO1xuICAgIGNvbnN0IHBvc2l0aW9uV2l0aE9yaWdpbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4oY2hpbGROb2RlLCBub2RlT3JpZ2luKTtcbiAgICBjb25zdCBjbGFtcGVkUG9zaXRpb24gPSBpc0Nvb3JkaW5hdGVFeHRlbnQoY2hpbGROb2RlLmV4dGVudClcbiAgICAgICAgPyBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uV2l0aE9yaWdpbiwgY2hpbGROb2RlLmV4dGVudCwgY2hpbGREaW1lbnNpb25zKVxuICAgICAgICA6IHBvc2l0aW9uV2l0aE9yaWdpbjtcbiAgICBsZXQgYWJzb2x1dGVQb3NpdGlvbiA9IGNsYW1wUG9zaXRpb24oeyB4OiBwYXJlbnRYICsgY2xhbXBlZFBvc2l0aW9uLngsIHk6IHBhcmVudFkgKyBjbGFtcGVkUG9zaXRpb24ueSB9LCBub2RlRXh0ZW50LCBjaGlsZERpbWVuc2lvbnMpO1xuICAgIGlmIChjaGlsZE5vZGUuZXh0ZW50ID09PSAncGFyZW50Jykge1xuICAgICAgICBhYnNvbHV0ZVBvc2l0aW9uID0gY2xhbXBQb3NpdGlvblRvUGFyZW50KGFic29sdXRlUG9zaXRpb24sIGNoaWxkRGltZW5zaW9ucywgcGFyZW50Tm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkWiA9IGNhbGN1bGF0ZVooY2hpbGROb2RlLCBzZWxlY3RlZE5vZGVaKTtcbiAgICBjb25zdCBwYXJlbnRaID0gcGFyZW50Tm9kZS5pbnRlcm5hbHMueiA/PyAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGFic29sdXRlUG9zaXRpb24ueCxcbiAgICAgICAgeTogYWJzb2x1dGVQb3NpdGlvbi55LFxuICAgICAgICB6OiBwYXJlbnRaID49IGNoaWxkWiA/IHBhcmVudFogKyAxIDogY2hpbGRaLFxuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVFeHBhbmRQYXJlbnQoY2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiA9IFswLCAwXSkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBwYXJlbnRFeHBhbnNpb25zID0gbmV3IE1hcCgpO1xuICAgIC8vIGRldGVybWluZSB0aGUgZXhwYW5kZWQgcmVjdGFuZ2xlIHRoZSBjaGlsZCBub2RlcyB3b3VsZCB0YWtlIGZvciBlYWNoIHBhcmVudFxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZUxvb2t1cC5nZXQoY2hpbGQucGFyZW50SWQpO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50UmVjdCA9IHBhcmVudEV4cGFuc2lvbnMuZ2V0KGNoaWxkLnBhcmVudElkKT8uZXhwYW5kZWRSZWN0ID8/IG5vZGVUb1JlY3QocGFyZW50KTtcbiAgICAgICAgY29uc3QgZXhwYW5kZWRSZWN0ID0gZ2V0Qm91bmRzT2ZSZWN0cyhwYXJlbnRSZWN0LCBjaGlsZC5yZWN0KTtcbiAgICAgICAgcGFyZW50RXhwYW5zaW9ucy5zZXQoY2hpbGQucGFyZW50SWQsIHsgZXhwYW5kZWRSZWN0LCBwYXJlbnQgfSk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRFeHBhbnNpb25zLnNpemUgPiAwKSB7XG4gICAgICAgIHBhcmVudEV4cGFuc2lvbnMuZm9yRWFjaCgoeyBleHBhbmRlZFJlY3QsIHBhcmVudCB9LCBwYXJlbnRJZCkgPT4ge1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiAmIGRpbWVuc2lvbnMgb2YgdGhlIHBhcmVudFxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25BYnNvbHV0ZSA9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBnZXROb2RlRGltZW5zaW9ucyhwYXJlbnQpO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gcGFyZW50Lm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZSBwYXJlbnQgZXhwYW5kcyBpbiB3aWR0aCBhbmQgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IHhDaGFuZ2UgPSBleHBhbmRlZFJlY3QueCA8IHBvc2l0aW9uQWJzb2x1dGUueCA/IE1hdGgucm91bmQoTWF0aC5hYnMocG9zaXRpb25BYnNvbHV0ZS54IC0gZXhwYW5kZWRSZWN0LngpKSA6IDA7XG4gICAgICAgICAgICBjb25zdCB5Q2hhbmdlID0gZXhwYW5kZWRSZWN0LnkgPCBwb3NpdGlvbkFic29sdXRlLnkgPyBNYXRoLnJvdW5kKE1hdGguYWJzKHBvc2l0aW9uQWJzb2x1dGUueSAtIGV4cGFuZGVkUmVjdC55KSkgOiAwO1xuICAgICAgICAgICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heChkaW1lbnNpb25zLndpZHRoLCBNYXRoLnJvdW5kKGV4cGFuZGVkUmVjdC53aWR0aCkpO1xuICAgICAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoZGltZW5zaW9ucy5oZWlnaHQsIE1hdGgucm91bmQoZXhwYW5kZWRSZWN0LmhlaWdodCkpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGhDaGFuZ2UgPSAobmV3V2lkdGggLSBkaW1lbnNpb25zLndpZHRoKSAqIG9yaWdpblswXTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodENoYW5nZSA9IChuZXdIZWlnaHQgLSBkaW1lbnNpb25zLmhlaWdodCkgKiBvcmlnaW5bMV07XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNvcnJlY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGUgb3JpZ2luIGlzIG5vdCBbMCwwXVxuICAgICAgICAgICAgaWYgKHhDaGFuZ2UgPiAwIHx8IHlDaGFuZ2UgPiAwIHx8IHdpZHRoQ2hhbmdlIHx8IGhlaWdodENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBhcmVudC5wb3NpdGlvbi54IC0geENoYW5nZSArIHdpZHRoQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcGFyZW50LnBvc2l0aW9uLnkgLSB5Q2hhbmdlICsgaGVpZ2h0Q2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogV2UgbW92ZSBhbGwgY2hpbGQgbm9kZXMgaW4gdGhlIG9wcHNpdGUgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgICogc28gdGhlIHgseSBjaGFuZ2VzIG9mIHRoZSBwYXJlbnQgZG8gbm90IG1vdmUgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcGFyZW50TG9va3VwLmdldChwYXJlbnRJZCk/LmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuLnNvbWUoKGNoaWxkKSA9PiBjaGlsZC5pZCA9PT0gY2hpbGROb2RlLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogY2hpbGROb2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2hpbGROb2RlLnBvc2l0aW9uLnggKyB4Q2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBjaGlsZE5vZGUucG9zaXRpb24ueSArIHlDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNvcnJlY3QgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHBhcmVudCBub2RlIGlmIHRoZSBvcmlnaW4gaXMgbm90IFswLDBdXG4gICAgICAgICAgICBpZiAoZGltZW5zaW9ucy53aWR0aCA8IGV4cGFuZGVkUmVjdC53aWR0aCB8fCBkaW1lbnNpb25zLmhlaWdodCA8IGV4cGFuZGVkUmVjdC5oZWlnaHQgfHwgeENoYW5nZSB8fCB5Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBuZXdXaWR0aCArICh4Q2hhbmdlID8gb3JpZ2luWzBdICogeENoYW5nZSAtIHdpZHRoQ2hhbmdlIDogMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodCArICh5Q2hhbmdlID8gb3JpZ2luWzFdICogeUNoYW5nZSAtIGhlaWdodENoYW5nZSA6IDApLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZXM7XG59XG5mdW5jdGlvbiB1cGRhdGVOb2RlSW50ZXJuYWxzKHVwZGF0ZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgZG9tTm9kZSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCkge1xuICAgIGNvbnN0IHZpZXdwb3J0Tm9kZSA9IGRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy54eWZsb3dfX3ZpZXdwb3J0Jyk7XG4gICAgbGV0IHVwZGF0ZWRJbnRlcm5hbHMgPSBmYWxzZTtcbiAgICBpZiAoIXZpZXdwb3J0Tm9kZSkge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbXSwgdXBkYXRlZEludGVybmFscyB9O1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh2aWV3cG9ydE5vZGUpO1xuICAgIGNvbnN0IHsgbTIyOiB6b29tIH0gPSBuZXcgd2luZG93LkRPTU1hdHJpeFJlYWRPbmx5KHN0eWxlLnRyYW5zZm9ybSk7XG4gICAgLy8gaW4gdGhpcyBhcnJheSB3ZSBjb2xsZWN0IG5vZGVzLCB0aGF0IG1pZ2h0IHRyaWdnZXIgY2hhbmdlcyAobGlrZSBleHBhbmRpbmcgcGFyZW50KVxuICAgIGNvbnN0IHBhcmVudEV4cGFuZENoaWxkcmVuID0gW107XG4gICAgZm9yIChjb25zdCB1cGRhdGUgb2YgdXBkYXRlcy52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQodXBkYXRlLmlkKTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5oaWRkZW4pIHtcbiAgICAgICAgICAgIG5vZGVMb29rdXAuc2V0KG5vZGUuaWQsIHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5ub2RlLmludGVybmFscyxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQm91bmRzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXBkYXRlZEludGVybmFscyA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyh1cGRhdGUubm9kZUVsZW1lbnQpO1xuICAgICAgICBjb25zdCBkaW1lbnNpb25DaGFuZ2VkID0gbm9kZS5tZWFzdXJlZC53aWR0aCAhPT0gZGltZW5zaW9ucy53aWR0aCB8fCBub2RlLm1lYXN1cmVkLmhlaWdodCAhPT0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGRvVXBkYXRlID0gISEoZGltZW5zaW9ucy53aWR0aCAmJlxuICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgJiZcbiAgICAgICAgICAgIChkaW1lbnNpb25DaGFuZ2VkIHx8ICFub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdXBkYXRlLmZvcmNlKSk7XG4gICAgICAgIGlmIChkb1VwZGF0ZSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUJvdW5kcyA9IHVwZGF0ZS5ub2RlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IGlzQ29vcmRpbmF0ZUV4dGVudChub2RlLmV4dGVudCkgPyBub2RlLmV4dGVudCA6IG5vZGVFeHRlbnQ7XG4gICAgICAgICAgICBsZXQgeyBwb3NpdGlvbkFic29sdXRlIH0gPSBub2RlLmludGVybmFscztcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudElkICYmIG5vZGUuZXh0ZW50ID09PSAncGFyZW50Jykge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGUgPSBjbGFtcFBvc2l0aW9uVG9QYXJlbnQocG9zaXRpb25BYnNvbHV0ZSwgZGltZW5zaW9ucywgbm9kZUxvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wUG9zaXRpb24ocG9zaXRpb25BYnNvbHV0ZSwgZXh0ZW50LCBkaW1lbnNpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBtZWFzdXJlZDogZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGUsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUJvdW5kczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBnZXRIYW5kbGVCb3VuZHMoJ3NvdXJjZScsIHVwZGF0ZS5ub2RlRWxlbWVudCwgbm9kZUJvdW5kcywgem9vbSwgbm9kZS5pZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGdldEhhbmRsZUJvdW5kcygndGFyZ2V0JywgdXBkYXRlLm5vZGVFbGVtZW50LCBub2RlQm91bmRzLCB6b29tLCBub2RlLmlkKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGVMb29rdXAuc2V0KG5vZGUuaWQsIG5ld05vZGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZE5vZGUobmV3Tm9kZSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7IG5vZGVPcmlnaW4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVkSW50ZXJuYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5leHBhbmRQYXJlbnQgJiYgbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRFeHBhbmRDaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0OiBub2RlVG9SZWN0KG5ld05vZGUsIG5vZGVPcmlnaW4pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmVudEV4cGFuZENoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcGFyZW50RXhwYW5kQ2hhbmdlcyA9IGhhbmRsZUV4cGFuZFBhcmVudChwYXJlbnRFeHBhbmRDaGlsZHJlbiwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luKTtcbiAgICAgICAgY2hhbmdlcy5wdXNoKC4uLnBhcmVudEV4cGFuZENoYW5nZXMpO1xuICAgIH1cbiAgICByZXR1cm4geyBjaGFuZ2VzLCB1cGRhdGVkSW50ZXJuYWxzIH07XG59XG5hc3luYyBmdW5jdGlvbiBwYW5CeSh7IGRlbHRhLCBwYW5ab29tLCB0cmFuc2Zvcm0sIHRyYW5zbGF0ZUV4dGVudCwgd2lkdGgsIGhlaWdodCwgfSkge1xuICAgIGlmICghcGFuWm9vbSB8fCAoIWRlbHRhLnggJiYgIWRlbHRhLnkpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBjb25zdCBuZXh0Vmlld3BvcnQgPSBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0Q29uc3RyYWluZWQoe1xuICAgICAgICB4OiB0cmFuc2Zvcm1bMF0gKyBkZWx0YS54LFxuICAgICAgICB5OiB0cmFuc2Zvcm1bMV0gKyBkZWx0YS55LFxuICAgICAgICB6b29tOiB0cmFuc2Zvcm1bMl0sXG4gICAgfSwgW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcbiAgICBdLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIGNvbnN0IHRyYW5zZm9ybUNoYW5nZWQgPSAhIW5leHRWaWV3cG9ydCAmJlxuICAgICAgICAobmV4dFZpZXdwb3J0LnggIT09IHRyYW5zZm9ybVswXSB8fCBuZXh0Vmlld3BvcnQueSAhPT0gdHJhbnNmb3JtWzFdIHx8IG5leHRWaWV3cG9ydC5rICE9PSB0cmFuc2Zvcm1bMl0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJhbnNmb3JtQ2hhbmdlZCk7XG59XG4vKipcbiAqIHRoaXMgZnVuY3Rpb24gYWRkcyB0aGUgY29ubmVjdGlvbiB0byB0aGUgY29ubmVjdGlvbkxvb2t1cFxuICogYXQgdGhlIGZvbGxvd2luZyBrZXlzOiBub2RlSWQtdHlwZS1oYW5kbGVJZCwgbm9kZUlkLXR5cGUgYW5kIG5vZGVJZFxuICogQHBhcmFtIHR5cGUgdHlwZSBvZiB0aGUgY29ubmVjdGlvblxuICogQHBhcmFtIGNvbm5lY3Rpb24gY29ubmVjdGlvbiB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbG9va3VwXG4gKiBAcGFyYW0gY29ubmVjdGlvbktleSBhdCB3aGljaCBrZXkgdGhlIGNvbm5lY3Rpb24gc2hvdWxkIGJlIGFkZGVkXG4gKiBAcGFyYW0gY29ubmVjdGlvbkxvb2t1cCByZWZlcmVuY2UgdG8gdGhlIGNvbm5lY3Rpb24gbG9va3VwXG4gKiBAcGFyYW0gbm9kZUlkIG5vZGVJZCBvZiB0aGUgY29ubmVjdGlvblxuICogQHBhcmFtIGhhbmRsZUlkIGhhbmRsZUlkIG9mIHRoZSBjb25uZWNpdG9uXG4gKi9cbmZ1bmN0aW9uIGFkZENvbm5lY3Rpb25Ub0xvb2t1cCh0eXBlLCBjb25uZWN0aW9uLCBjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uTG9va3VwLCBub2RlSWQsIGhhbmRsZUlkKSB7XG4gICAgLypcbiAgICAgKiBXZSBhZGQgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIGNvbm5lY3Rpb25Mb29rdXAgYXQgdGhlIGZvbGxvd2luZyBrZXlzXG4gICAgICogMS4gbm9kZUlkLCAyLiBub2RlSWQtdHlwZSwgMy4gbm9kZUlkLXR5cGUtaGFuZGxlSWRcbiAgICAgKiBJZiB0aGUga2V5IGFscmVhZHkgZXhpc3RzLCB3ZSBhZGQgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIGV4aXN0aW5nIG1hcFxuICAgICAqL1xuICAgIGxldCBrZXkgPSBub2RlSWQ7XG4gICAgY29uc3Qgbm9kZU1hcCA9IGNvbm5lY3Rpb25Mb29rdXAuZ2V0KGtleSkgfHwgbmV3IE1hcCgpO1xuICAgIGNvbm5lY3Rpb25Mb29rdXAuc2V0KGtleSwgbm9kZU1hcC5zZXQoY29ubmVjdGlvbktleSwgY29ubmVjdGlvbikpO1xuICAgIGtleSA9IGAke25vZGVJZH0tJHt0eXBlfWA7XG4gICAgY29uc3QgdHlwZU1hcCA9IGNvbm5lY3Rpb25Mb29rdXAuZ2V0KGtleSkgfHwgbmV3IE1hcCgpO1xuICAgIGNvbm5lY3Rpb25Mb29rdXAuc2V0KGtleSwgdHlwZU1hcC5zZXQoY29ubmVjdGlvbktleSwgY29ubmVjdGlvbikpO1xuICAgIGlmIChoYW5kbGVJZCkge1xuICAgICAgICBrZXkgPSBgJHtub2RlSWR9LSR7dHlwZX0tJHtoYW5kbGVJZH1gO1xuICAgICAgICBjb25zdCBoYW5kbGVNYXAgPSBjb25uZWN0aW9uTG9va3VwLmdldChrZXkpIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgY29ubmVjdGlvbkxvb2t1cC5zZXQoa2V5LCBoYW5kbGVNYXAuc2V0KGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb24pKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVDb25uZWN0aW9uTG9va3VwKGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAsIGVkZ2VzKSB7XG4gICAgY29ubmVjdGlvbkxvb2t1cC5jbGVhcigpO1xuICAgIGVkZ2VMb29rdXAuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgY29uc3QgeyBzb3VyY2U6IHNvdXJjZU5vZGUsIHRhcmdldDogdGFyZ2V0Tm9kZSwgc291cmNlSGFuZGxlID0gbnVsbCwgdGFyZ2V0SGFuZGxlID0gbnVsbCB9ID0gZWRnZTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHsgZWRnZUlkOiBlZGdlLmlkLCBzb3VyY2U6IHNvdXJjZU5vZGUsIHRhcmdldDogdGFyZ2V0Tm9kZSwgc291cmNlSGFuZGxlLCB0YXJnZXRIYW5kbGUgfTtcbiAgICAgICAgY29uc3Qgc291cmNlS2V5ID0gYCR7c291cmNlTm9kZX0tJHtzb3VyY2VIYW5kbGV9LS0ke3RhcmdldE5vZGV9LSR7dGFyZ2V0SGFuZGxlfWA7XG4gICAgICAgIGNvbnN0IHRhcmdldEtleSA9IGAke3RhcmdldE5vZGV9LSR7dGFyZ2V0SGFuZGxlfS0tJHtzb3VyY2VOb2RlfS0ke3NvdXJjZUhhbmRsZX1gO1xuICAgICAgICBhZGRDb25uZWN0aW9uVG9Mb29rdXAoJ3NvdXJjZScsIGNvbm5lY3Rpb24sIHRhcmdldEtleSwgY29ubmVjdGlvbkxvb2t1cCwgc291cmNlTm9kZSwgc291cmNlSGFuZGxlKTtcbiAgICAgICAgYWRkQ29ubmVjdGlvblRvTG9va3VwKCd0YXJnZXQnLCBjb25uZWN0aW9uLCBzb3VyY2VLZXksIGNvbm5lY3Rpb25Mb29rdXAsIHRhcmdldE5vZGUsIHRhcmdldEhhbmRsZSk7XG4gICAgICAgIGVkZ2VMb29rdXAuc2V0KGVkZ2UuaWQsIGVkZ2UpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2hhbGxvd05vZGVEYXRhKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgX2EgPSBBcnJheS5pc0FycmF5KGEpID8gYSA6IFthXTtcbiAgICBjb25zdCBfYiA9IEFycmF5LmlzQXJyYXkoYikgPyBiIDogW2JdO1xuICAgIGlmIChfYS5sZW5ndGggIT09IF9iLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX2EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKF9hW2ldLmlkICE9PSBfYltpXS5pZCB8fCBfYVtpXS50eXBlICE9PSBfYltpXS50eXBlIHx8ICFPYmplY3QuaXMoX2FbaV0uZGF0YSwgX2JbaV0uZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNQYXJlbnRTZWxlY3RlZChub2RlLCBub2RlTG9va3VwKSB7XG4gICAgaWYgKCFub2RlLnBhcmVudElkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpO1xuICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwYXJlbnROb2RlLnNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaXNQYXJlbnRTZWxlY3RlZChwYXJlbnROb2RlLCBub2RlTG9va3VwKTtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdG9yKHRhcmdldCwgc2VsZWN0b3IsIGRvbU5vZGUpIHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChjdXJyZW50Py5tYXRjaGVzPy4oc2VsZWN0b3IpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBkb21Ob2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudD8ucGFyZW50RWxlbWVudDtcbiAgICB9IHdoaWxlIChjdXJyZW50KTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBsb29rcyBmb3IgYWxsIHNlbGVjdGVkIG5vZGVzIGFuZCBjcmVhdGVkIGEgTm9kZURyYWdJdGVtIGZvciBlYWNoIG9mIHRoZW1cbmZ1bmN0aW9uIGdldERyYWdJdGVtcyhub2RlTG9va3VwLCBub2Rlc0RyYWdnYWJsZSwgbW91c2VQb3MsIG5vZGVJZCkge1xuICAgIGNvbnN0IGRyYWdJdGVtcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgbm9kZV0gb2Ygbm9kZUxvb2t1cCkge1xuICAgICAgICBpZiAoKG5vZGUuc2VsZWN0ZWQgfHwgbm9kZS5pZCA9PT0gbm9kZUlkKSAmJlxuICAgICAgICAgICAgKCFub2RlLnBhcmVudElkIHx8ICFpc1BhcmVudFNlbGVjdGVkKG5vZGUsIG5vZGVMb29rdXApKSAmJlxuICAgICAgICAgICAgKG5vZGUuZHJhZ2dhYmxlIHx8IChub2Rlc0RyYWdnYWJsZSAmJiB0eXBlb2Ygbm9kZS5kcmFnZ2FibGUgPT09ICd1bmRlZmluZWQnKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsTm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUpIHtcbiAgICAgICAgICAgICAgICBkcmFnSXRlbXMuc2V0KGlkLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaW50ZXJuYWxOb2RlLnBvc2l0aW9uIHx8IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogbW91c2VQb3MueCAtIGludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogbW91c2VQb3MueSAtIGludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBleHRlbnQ6IGludGVybmFsTm9kZS5leHRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBpbnRlcm5hbE5vZGUucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogaW50ZXJuYWxOb2RlLm9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kUGFyZW50OiBpbnRlcm5hbE5vZGUuZXhwYW5kUGFyZW50LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGU6IGludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSB8fCB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWVhc3VyZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbnRlcm5hbE5vZGUubWVhc3VyZWQud2lkdGggPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaW50ZXJuYWxOb2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkcmFnSXRlbXM7XG59XG4vKlxuICogcmV0dXJucyB0d28gcGFyYW1zOlxuICogMS4gdGhlIGRyYWdnZWQgbm9kZSAob3IgdGhlIGZpcnN0IG9mIHRoZSBsaXN0LCBpZiB3ZSBhcmUgZHJhZ2dpbmcgYSBub2RlIHNlbGVjdGlvbilcbiAqIDIuIGFycmF5IG9mIHNlbGVjdGVkIG5vZGVzIChmb3IgbXVsdGkgc2VsZWN0aW9ucylcbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHsgbm9kZUlkLCBkcmFnSXRlbXMsIG5vZGVMb29rdXAsIGRyYWdnaW5nID0gdHJ1ZSwgfSkge1xuICAgIGNvbnN0IG5vZGVzRnJvbURyYWdJdGVtcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2lkLCBkcmFnSXRlbV0gb2YgZHJhZ0l0ZW1zKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChpZCk/LmludGVybmFscy51c2VyTm9kZTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVzRnJvbURyYWdJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBkcmFnSXRlbS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgIHJldHVybiBbbm9kZXNGcm9tRHJhZ0l0ZW1zWzBdLCBub2Rlc0Zyb21EcmFnSXRlbXNdO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKT8uaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgIHJldHVybiBbXG4gICAgICAgICFub2RlXG4gICAgICAgICAgICA/IG5vZGVzRnJvbURyYWdJdGVtc1swXVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZHJhZ0l0ZW1zLmdldChub2RlSWQpPy5wb3NpdGlvbiB8fCBub2RlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgbm9kZXNGcm9tRHJhZ0l0ZW1zLFxuICAgIF07XG59XG4vKipcbiAqIElmIGEgc2VsZWN0aW9uIGlzIGJlaW5nIGRyYWdnZWQgd2Ugd2FudCB0byBhcHBseSB0aGUgc2FtZSBzbmFwIG9mZnNldCB0byBhbGwgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc25hcCBvZmZzZXQgYmFzZWQgb24gdGhlIGZpcnN0IG5vZGUgaW4gdGhlIHNlbGVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU25hcE9mZnNldCh7IGRyYWdJdGVtcywgc25hcEdyaWQsIHgsIHksIH0pIHtcbiAgICBjb25zdCByZWZEcmFnSXRlbSA9IGRyYWdJdGVtcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgaWYgKCFyZWZEcmFnSXRlbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVmUG9zID0ge1xuICAgICAgICB4OiB4IC0gcmVmRHJhZ0l0ZW0uZGlzdGFuY2UueCxcbiAgICAgICAgeTogeSAtIHJlZkRyYWdJdGVtLmRpc3RhbmNlLnksXG4gICAgfTtcbiAgICBjb25zdCByZWZQb3NTbmFwcGVkID0gc25hcFBvc2l0aW9uKHJlZlBvcywgc25hcEdyaWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJlZlBvc1NuYXBwZWQueCAtIHJlZlBvcy54LFxuICAgICAgICB5OiByZWZQb3NTbmFwcGVkLnkgLSByZWZQb3MueSxcbiAgICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gWFlEcmFnKHsgb25Ob2RlTW91c2VEb3duLCBnZXRTdG9yZUl0ZW1zLCBvbkRyYWdTdGFydCwgb25EcmFnLCBvbkRyYWdTdG9wLCB9KSB7XG4gICAgbGV0IGxhc3RQb3MgPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcbiAgICBsZXQgYXV0b1BhbklkID0gMDtcbiAgICBsZXQgZHJhZ0l0ZW1zID0gbmV3IE1hcCgpO1xuICAgIGxldCBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBtb3VzZVBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgbGV0IGNvbnRhaW5lckJvdW5kcyA9IG51bGw7XG4gICAgbGV0IGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IGQzU2VsZWN0aW9uID0gbnVsbDtcbiAgICBsZXQgYWJvcnREcmFnID0gZmFsc2U7IC8vIHByZXZlbnRzIHVuaW50ZW50aW9uYWwgZHJhZ2dpbmcgb24gbXVsdGl0b3VjaFxuICAgIGxldCBub2RlUG9zaXRpb25zQ2hhbmdlZCA9IGZhbHNlO1xuICAgIC8vIHdlIHN0b3JlIHRoZSBsYXN0IGRyYWcgZXZlbnQgdG8gYmUgYWJsZSB0byB1c2UgaXQgaW4gdGhlIHVwZGF0ZSBmdW5jdGlvblxuICAgIGxldCBkcmFnRXZlbnQgPSBudWxsO1xuICAgIC8vIHB1YmxpYyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyBub0RyYWdDbGFzc05hbWUsIGhhbmRsZVNlbGVjdG9yLCBkb21Ob2RlLCBpc1NlbGVjdGFibGUsIG5vZGVJZCwgbm9kZUNsaWNrRGlzdGFuY2UgPSAwLCB9KSB7XG4gICAgICAgIGQzU2VsZWN0aW9uID0gc2VsZWN0KGRvbU5vZGUpO1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVOb2Rlcyh7IHgsIHkgfSkge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlRXh0ZW50LCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgb25Ob2RlRHJhZywgb25TZWxlY3Rpb25EcmFnLCBvbkVycm9yLCB1cGRhdGVOb2RlUG9zaXRpb25zLCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHsgeCwgeSB9O1xuICAgICAgICAgICAgbGV0IGhhc0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgaXNNdWx0aURyYWcgPSBkcmFnSXRlbXMuc2l6ZSA+IDE7XG4gICAgICAgICAgICBjb25zdCBub2Rlc0JveCA9IGlzTXVsdGlEcmFnICYmIG5vZGVFeHRlbnQgPyByZWN0VG9Cb3goZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhkcmFnSXRlbXMpKSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBtdWx0aURyYWdTbmFwT2Zmc2V0ID0gaXNNdWx0aURyYWcgJiYgc25hcFRvR3JpZFxuICAgICAgICAgICAgICAgID8gY2FsY3VsYXRlU25hcE9mZnNldCh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgc25hcEdyaWQsXG4gICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgZHJhZ0l0ZW1dIG9mIGRyYWdJdGVtcykge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogaWYgdGhlIG5vZGUgaXMgbm90IGluIHRoZSBub2RlTG9va3VwIGFueW1vcmUsIGl0IHdhcyBwcm9iYWJseSBkZWxldGVkIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlTG9va3VwLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBuZXh0UG9zaXRpb24gPSB7IHg6IHggLSBkcmFnSXRlbS5kaXN0YW5jZS54LCB5OiB5IC0gZHJhZ0l0ZW0uZGlzdGFuY2UueSB9O1xuICAgICAgICAgICAgICAgIGlmIChzbmFwVG9HcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IG11bHRpRHJhZ1NuYXBPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQobmV4dFBvc2l0aW9uLnggKyBtdWx0aURyYWdTbmFwT2Zmc2V0LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IE1hdGgucm91bmQobmV4dFBvc2l0aW9uLnkgKyBtdWx0aURyYWdTbmFwT2Zmc2V0LnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzbmFwUG9zaXRpb24obmV4dFBvc2l0aW9uLCBzbmFwR3JpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBhZGp1c3RlZE5vZGVFeHRlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc011bHRpRHJhZyAmJiBub2RlRXh0ZW50ICYmICFkcmFnSXRlbS5leHRlbnQgJiYgbm9kZXNCb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwb3NpdGlvbkFic29sdXRlIH0gPSBkcmFnSXRlbS5pbnRlcm5hbHM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHgxID0gcG9zaXRpb25BYnNvbHV0ZS54IC0gbm9kZXNCb3gueCArIG5vZGVFeHRlbnRbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHgyID0gcG9zaXRpb25BYnNvbHV0ZS54ICsgZHJhZ0l0ZW0ubWVhc3VyZWQud2lkdGggLSBub2Rlc0JveC54MiArIG5vZGVFeHRlbnRbMV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkxID0gcG9zaXRpb25BYnNvbHV0ZS55IC0gbm9kZXNCb3gueSArIG5vZGVFeHRlbnRbMF1bMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gcG9zaXRpb25BYnNvbHV0ZS55ICsgZHJhZ0l0ZW0ubWVhc3VyZWQuaGVpZ2h0IC0gbm9kZXNCb3gueTIgKyBub2RlRXh0ZW50WzFdWzFdO1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZE5vZGVFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBbeDEsIHkxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4MiwgeTJdLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCBwb3NpdGlvbkFic29sdXRlIH0gPSBjYWxjdWxhdGVOb2RlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQ6IGFkanVzdGVkTm9kZUV4dGVudCA/IGFkanVzdGVkTm9kZUV4dGVudCA6IG5vZGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBvbmx5IGZpcmUgYSBjaGFuZ2UgZXZlbnQgd2hlbiB0aGVyZSBpcyBhIGNoYW5nZVxuICAgICAgICAgICAgICAgIGhhc0NoYW5nZSA9IGhhc0NoYW5nZSB8fCBkcmFnSXRlbS5wb3NpdGlvbi54ICE9PSBwb3NpdGlvbi54IHx8IGRyYWdJdGVtLnBvc2l0aW9uLnkgIT09IHBvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW0ucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBkcmFnSXRlbS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA9IHBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlUG9zaXRpb25zQ2hhbmdlZCA9IG5vZGVQb3NpdGlvbnNDaGFuZ2VkIHx8IGhhc0NoYW5nZTtcbiAgICAgICAgICAgIGlmICghaGFzQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhkcmFnSXRlbXMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGRyYWdFdmVudCAmJiAob25EcmFnIHx8IG9uTm9kZURyYWcgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbkRyYWc/LihkcmFnRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgb25Ob2RlRHJhZz8uKGRyYWdFdmVudCwgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25EcmFnPy4oZHJhZ0V2ZW50LCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBhdXRvUGFuKCkge1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXJCb3VuZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgcGFuQnksIGF1dG9QYW5TcGVlZCwgYXV0b1Bhbk9uTm9kZURyYWcgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGlmICghYXV0b1Bhbk9uTm9kZURyYWcpIHtcbiAgICAgICAgICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGF1dG9QYW5JZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3hNb3ZlbWVudCwgeU1vdmVtZW50XSA9IGNhbGNBdXRvUGFuKG1vdXNlUG9zaXRpb24sIGNvbnRhaW5lckJvdW5kcywgYXV0b1BhblNwZWVkKTtcbiAgICAgICAgICAgIGlmICh4TW92ZW1lbnQgIT09IDAgfHwgeU1vdmVtZW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdFBvcy54ID0gKGxhc3RQb3MueCA/PyAwKSAtIHhNb3ZlbWVudCAvIHRyYW5zZm9ybVsyXTtcbiAgICAgICAgICAgICAgICBsYXN0UG9zLnkgPSAobGFzdFBvcy55ID8/IDApIC0geU1vdmVtZW50IC8gdHJhbnNmb3JtWzJdO1xuICAgICAgICAgICAgICAgIGlmIChhd2FpdCBwYW5CeSh7IHg6IHhNb3ZlbWVudCwgeTogeU1vdmVtZW50IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzKGxhc3RQb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9QYW5JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhdXRvUGFuKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFydERyYWcoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIG5vZGVzRHJhZ2dhYmxlLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBzZWxlY3ROb2Rlc09uRHJhZywgb25Ob2RlRHJhZ1N0YXJ0LCBvblNlbGVjdGlvbkRyYWdTdGFydCwgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCghc2VsZWN0Tm9kZXNPbkRyYWcgfHwgIWlzU2VsZWN0YWJsZSkgJiYgIW11bHRpU2VsZWN0aW9uQWN0aXZlICYmIG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUxvb2t1cC5nZXQobm9kZUlkKT8uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXNldCBzZWxlY3RlZCBub2RlcyB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPWZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGFibGUgJiYgc2VsZWN0Tm9kZXNPbkRyYWcgJiYgbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgb25Ob2RlTW91c2VEb3duPy4obm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgY29udGFpbmVyQm91bmRzIH0pO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHBvaW50ZXJQb3M7XG4gICAgICAgICAgICBkcmFnSXRlbXMgPSBnZXREcmFnSXRlbXMobm9kZUxvb2t1cCwgbm9kZXNEcmFnZ2FibGUsIHBvaW50ZXJQb3MsIG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLnNpemUgPiAwICYmIChvbkRyYWdTdGFydCB8fCBvbk5vZGVEcmFnU3RhcnQgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnU3RhcnQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzXSA9IGdldEV2ZW50SGFuZGxlclBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgb25Ob2RlRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGQzRHJhZ0luc3RhbmNlID0gZHJhZygpXG4gICAgICAgICAgICAuY2xpY2tEaXN0YW5jZShub2RlQ2xpY2tEaXN0YW5jZSlcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgbm9kZURyYWdUaHJlc2hvbGQsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHx8IG51bGw7XG4gICAgICAgICAgICBhYm9ydERyYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIG5vZGVQb3NpdGlvbnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBkcmFnRXZlbnQgPSBldmVudC5zb3VyY2VFdmVudDtcbiAgICAgICAgICAgIGlmIChub2RlRHJhZ1RocmVzaG9sZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RHJhZyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIGNvbnRhaW5lckJvdW5kcyB9KTtcbiAgICAgICAgICAgIGxhc3RQb3MgPSBwb2ludGVyUG9zO1xuICAgICAgICAgICAgbW91c2VQb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2RyYWcnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0b1Bhbk9uTm9kZURyYWcsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVEcmFnVGhyZXNob2xkLCBub2RlTG9va3VwIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIGNvbnRhaW5lckJvdW5kcyB9KTtcbiAgICAgICAgICAgIGRyYWdFdmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50O1xuICAgICAgICAgICAgaWYgKChldmVudC5zb3VyY2VFdmVudC50eXBlID09PSAndG91Y2htb3ZlJyAmJiBldmVudC5zb3VyY2VFdmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHx8XG4gICAgICAgICAgICAgICAgLy8gaWYgdXNlciBkZWxldGVzIGEgbm9kZSB3aGlsZSBkcmFnZ2luZywgd2UgbmVlZCB0byBhYm9ydCB0aGUgZHJhZyB0byBwcmV2ZW50IGVycm9yc1xuICAgICAgICAgICAgICAgIChub2RlSWQgJiYgIW5vZGVMb29rdXAuaGFzKG5vZGVJZCkpKSB7XG4gICAgICAgICAgICAgICAgYWJvcnREcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydERyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWF1dG9QYW5TdGFydGVkICYmIGF1dG9QYW5Pbk5vZGVEcmFnICYmIGRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF1dG9QYW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgaW4gY2xpZW50IGNvb3JkaW5hdGVzIGZvciBjb25zaXN0ZW50IGRyYWcgdGhyZXNob2xkIGJlaGF2aW9yIGFjcm9zcyB6b29tIGxldmVsc1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNb3VzZVBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gY3VycmVudE1vdXNlUG9zaXRpb24ueCAtIG1vdXNlUG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gY3VycmVudE1vdXNlUG9zaXRpb24ueSAtIG1vdXNlUG9zaXRpb24ueTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBub2RlRHJhZ1RocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydERyYWcoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgZXZlbnRzIHdpdGhvdXQgbW92ZW1lbnRcbiAgICAgICAgICAgIGlmICgobGFzdFBvcy54ICE9PSBwb2ludGVyUG9zLnhTbmFwcGVkIHx8IGxhc3RQb3MueSAhPT0gcG9pbnRlclBvcy55U25hcHBlZCkgJiYgZHJhZ0l0ZW1zICYmIGRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgbW91c2VQb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlTm9kZXMocG9pbnRlclBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2VuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRlZCB8fCBhYm9ydERyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGF1dG9QYW5JZCk7XG4gICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB1cGRhdGVOb2RlUG9zaXRpb25zLCBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnU3RvcCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlUG9zaXRpb25zQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVOb2RlUG9zaXRpb25zKGRyYWdJdGVtcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBub2RlUG9zaXRpb25zQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob25EcmFnU3RvcCB8fCBvbk5vZGVEcmFnU3RvcCB8fCAoIW5vZGVJZCAmJiBvblNlbGVjdGlvbkRyYWdTdG9wKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0b3A/LihldmVudC5zb3VyY2VFdmVudCwgZHJhZ0l0ZW1zLCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgb25Ob2RlRHJhZ1N0b3A/LihldmVudC5zb3VyY2VFdmVudCwgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGlvbkRyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhZXZlbnQuYnV0dG9uICYmXG4gICAgICAgICAgICAgICAgKCFub0RyYWdDbGFzc05hbWUgfHwgIWhhc1NlbGVjdG9yKHRhcmdldCwgYC4ke25vRHJhZ0NsYXNzTmFtZX1gLCBkb21Ob2RlKSkgJiZcbiAgICAgICAgICAgICAgICAoIWhhbmRsZVNlbGVjdG9yIHx8IGhhc1NlbGVjdG9yKHRhcmdldCwgaGFuZGxlU2VsZWN0b3IsIGRvbU5vZGUpKTtcbiAgICAgICAgICAgIHJldHVybiBpc0RyYWdnYWJsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGQzU2VsZWN0aW9uLmNhbGwoZDNEcmFnSW5zdGFuY2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBkM1NlbGVjdGlvbj8ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXROb2Rlc1dpdGhpbkRpc3RhbmNlKHBvc2l0aW9uLCBub2RlTG9va3VwLCBkaXN0YW5jZSkge1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgcmVjdCA9IHtcbiAgICAgICAgeDogcG9zaXRpb24ueCAtIGRpc3RhbmNlLFxuICAgICAgICB5OiBwb3NpdGlvbi55IC0gZGlzdGFuY2UsXG4gICAgICAgIHdpZHRoOiBkaXN0YW5jZSAqIDIsXG4gICAgICAgIGhlaWdodDogZGlzdGFuY2UgKiAyLFxuICAgIH07XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMb29rdXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKGdldE92ZXJsYXBwaW5nQXJlYShyZWN0LCBub2RlVG9SZWN0KG5vZGUpKSA+IDApIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuLypcbiAqIHRoaXMgZGlzdGFuY2UgaXMgdXNlZCBmb3IgdGhlIGFyZWEgYXJvdW5kIHRoZSB1c2VyIHBvaW50ZXJcbiAqIHdoaWxlIGRvaW5nIGEgY29ubmVjdGlvbiBmb3IgZmluZGluZyB0aGUgY2xvc2VzdCBub2Rlc1xuICovXG5jb25zdCBBRERJVElPTkFMX0RJU1RBTkNFID0gMjUwO1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZShwb3NpdGlvbiwgY29ubmVjdGlvblJhZGl1cywgbm9kZUxvb2t1cCwgZnJvbUhhbmRsZSkge1xuICAgIGxldCBjbG9zZXN0SGFuZGxlcyA9IFtdO1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGNvbnN0IGNsb3NlTm9kZXMgPSBnZXROb2Rlc1dpdGhpbkRpc3RhbmNlKHBvc2l0aW9uLCBub2RlTG9va3VwLCBjb25uZWN0aW9uUmFkaXVzICsgQURESVRJT05BTF9ESVNUQU5DRSk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGNsb3NlTm9kZXMpIHtcbiAgICAgICAgY29uc3QgYWxsSGFuZGxlcyA9IFsuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCAuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy50YXJnZXQgPz8gW10pXTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGUgb2YgYWxsSGFuZGxlcykge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGhhbmRsZSBpcyB0aGUgc2FtZSBhcyB0aGUgZnJvbUhhbmRsZSB3ZSBza2lwIGl0XG4gICAgICAgICAgICBpZiAoZnJvbUhhbmRsZS5ub2RlSWQgPT09IGhhbmRsZS5ub2RlSWQgJiYgZnJvbUhhbmRsZS50eXBlID09PSBoYW5kbGUudHlwZSAmJiBmcm9tSGFuZGxlLmlkID09PSBoYW5kbGUuaWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRldGVybWluZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgaGFuZGxlXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldEhhbmRsZVBvc2l0aW9uKG5vZGUsIGhhbmRsZSwgaGFuZGxlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHggLSBwb3NpdGlvbi54LCAyKSArIE1hdGgucG93KHkgLSBwb3NpdGlvbi55LCAyKSk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBjb25uZWN0aW9uUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RIYW5kbGVzID0gW3sgLi4uaGFuZGxlLCB4LCB5IH1dO1xuICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIG11bHRpcGxlIGhhbmRsZXMgYXJlIG9uIHRoZSBzYW1lIGRpc3RhbmNlIHdlIGNvbGxlY3QgYWxsIG9mIHRoZW1cbiAgICAgICAgICAgICAgICBjbG9zZXN0SGFuZGxlcy5wdXNoKHsgLi4uaGFuZGxlLCB4LCB5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2xvc2VzdEhhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyB3aGVuIG11bHRpcGxlIGhhbmRsZXMgb3ZlcmxheSBlYWNoIG90aGVyIHdlIHByZWZlciB0aGUgb3Bwb3NpdGUgaGFuZGxlXG4gICAgaWYgKGNsb3Nlc3RIYW5kbGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3Qgb3Bwb3NpdGVIYW5kbGVUeXBlID0gZnJvbUhhbmRsZS50eXBlID09PSAnc291cmNlJyA/ICd0YXJnZXQnIDogJ3NvdXJjZSc7XG4gICAgICAgIHJldHVybiBjbG9zZXN0SGFuZGxlcy5maW5kKChoYW5kbGUpID0+IGhhbmRsZS50eXBlID09PSBvcHBvc2l0ZUhhbmRsZVR5cGUpID8/IGNsb3Nlc3RIYW5kbGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdEhhbmRsZXNbMF07XG59XG5mdW5jdGlvbiBnZXRIYW5kbGUobm9kZUlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbk1vZGUsIHdpdGhBYnNvbHV0ZVBvc2l0aW9uID0gZmFsc2UpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXMgPSBjb25uZWN0aW9uTW9kZSA9PT0gJ3N0cmljdCdcbiAgICAgICAgPyBub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM/LltoYW5kbGVUeXBlXVxuICAgICAgICA6IFsuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCAuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy50YXJnZXQgPz8gW10pXTtcbiAgICBjb25zdCBoYW5kbGUgPSAoaGFuZGxlSWQgPyBoYW5kbGVzPy5maW5kKChoKSA9PiBoLmlkID09PSBoYW5kbGVJZCkgOiBoYW5kbGVzPy5bMF0pID8/IG51bGw7XG4gICAgcmV0dXJuIGhhbmRsZSAmJiB3aXRoQWJzb2x1dGVQb3NpdGlvblxuICAgICAgICA/IHsgLi4uaGFuZGxlLCAuLi5nZXRIYW5kbGVQb3NpdGlvbihub2RlLCBoYW5kbGUsIGhhbmRsZS5wb3NpdGlvbiwgdHJ1ZSkgfVxuICAgICAgICA6IGhhbmRsZTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZVR5cGUoZWRnZVVwZGF0ZXJUeXBlLCBoYW5kbGVEb21Ob2RlKSB7XG4gICAgaWYgKGVkZ2VVcGRhdGVyVHlwZSkge1xuICAgICAgICByZXR1cm4gZWRnZVVwZGF0ZXJUeXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYW5kbGVEb21Ob2RlPy5jbGFzc0xpc3QuY29udGFpbnMoJ3RhcmdldCcpKSB7XG4gICAgICAgIHJldHVybiAndGFyZ2V0JztcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlRG9tTm9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKCdzb3VyY2UnKSkge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZSc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNDb25uZWN0aW9uVmFsaWQoaXNJbnNpZGVDb25uZWN0aW9uUmFkaXVzLCBpc0hhbmRsZVZhbGlkKSB7XG4gICAgbGV0IGlzVmFsaWQgPSBudWxsO1xuICAgIGlmIChpc0hhbmRsZVZhbGlkKSB7XG4gICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0luc2lkZUNvbm5lY3Rpb25SYWRpdXMgJiYgIWlzSGFuZGxlVmFsaWQpIHtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNWYWxpZDtcbn1cblxuY29uc3QgYWx3YXlzVmFsaWQgPSAoKSA9PiB0cnVlO1xuZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCwgeyBjb25uZWN0aW9uTW9kZSwgY29ubmVjdGlvblJhZGl1cywgaGFuZGxlSWQsIG5vZGVJZCwgZWRnZVVwZGF0ZXJUeXBlLCBpc1RhcmdldCwgZG9tTm9kZSwgbm9kZUxvb2t1cCwgbGliLCBhdXRvUGFuT25Db25uZWN0LCBmbG93SWQsIHBhbkJ5LCBjYW5jZWxDb25uZWN0aW9uLCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0LCBvbkNvbm5lY3RFbmQsIGlzVmFsaWRDb25uZWN0aW9uID0gYWx3YXlzVmFsaWQsIG9uUmVjb25uZWN0RW5kLCB1cGRhdGVDb25uZWN0aW9uLCBnZXRUcmFuc2Zvcm0sIGdldEZyb21IYW5kbGUsIGF1dG9QYW5TcGVlZCwgZHJhZ1RocmVzaG9sZCA9IDEsIGhhbmRsZURvbU5vZGUsIH0pIHtcbiAgICAvLyB3aGVuIHh5ZmxvdyBpcyB1c2VkIGluc2lkZSBhIHNoYWRvdyByb290IHdlIGNhbid0IHVzZSBkb2N1bWVudFxuICAgIGNvbnN0IGRvYyA9IGdldEhvc3RGb3JFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgbGV0IGF1dG9QYW5JZCA9IDA7XG4gICAgbGV0IGNsb3Nlc3RIYW5kbGU7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgICBjb25zdCBoYW5kbGVUeXBlID0gZ2V0SGFuZGxlVHlwZShlZGdlVXBkYXRlclR5cGUsIGhhbmRsZURvbU5vZGUpO1xuICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBjb25uZWN0aW9uU3RhcnRlZCA9IGZhbHNlO1xuICAgIGlmICghY29udGFpbmVyQm91bmRzIHx8ICFoYW5kbGVUeXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZnJvbUhhbmRsZUludGVybmFsID0gZ2V0SGFuZGxlKG5vZGVJZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb25Nb2RlKTtcbiAgICBpZiAoIWZyb21IYW5kbGVJbnRlcm5hbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgbGV0IGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IGNvbm5lY3Rpb24gPSBudWxsO1xuICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG4gICAgbGV0IHJlc3VsdEhhbmRsZURvbU5vZGUgPSBudWxsO1xuICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgbW92aW5nIHRoZSBtb3VzZSBjbG9zZSB0byB0aGUgZWRnZSBvZiB0aGUgY2FudmFzIHdoaWxlIGNvbm5lY3Rpbmcgd2UgbW92ZSB0aGUgY2FudmFzXG4gICAgZnVuY3Rpb24gYXV0b1BhbigpIHtcbiAgICAgICAgaWYgKCFhdXRvUGFuT25Db25uZWN0IHx8ICFjb250YWluZXJCb3VuZHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbeCwgeV0gPSBjYWxjQXV0b1Bhbihwb3NpdGlvbiwgY29udGFpbmVyQm91bmRzLCBhdXRvUGFuU3BlZWQpO1xuICAgICAgICBwYW5CeSh7IHgsIHkgfSk7XG4gICAgICAgIGF1dG9QYW5JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhdXRvUGFuKTtcbiAgICB9XG4gICAgLy8gU3RheXMgdGhlIHNhbWUgZm9yIGFsbCBjb25zZWN1dGl2ZSBwb2ludGVybW92ZSBldmVudHNcbiAgICBjb25zdCBmcm9tSGFuZGxlID0ge1xuICAgICAgICAuLi5mcm9tSGFuZGxlSW50ZXJuYWwsXG4gICAgICAgIG5vZGVJZCxcbiAgICAgICAgdHlwZTogaGFuZGxlVHlwZSxcbiAgICAgICAgcG9zaXRpb246IGZyb21IYW5kbGVJbnRlcm5hbC5wb3NpdGlvbixcbiAgICB9O1xuICAgIGNvbnN0IGZyb21Ob2RlSW50ZXJuYWwgPSBub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgIGNvbnN0IGZyb20gPSBnZXRIYW5kbGVQb3NpdGlvbihmcm9tTm9kZUludGVybmFsLCBmcm9tSGFuZGxlLCBQb3NpdGlvbi5MZWZ0LCB0cnVlKTtcbiAgICBsZXQgcHJldmlvdXNDb25uZWN0aW9uID0ge1xuICAgICAgICBpblByb2dyZXNzOiB0cnVlLFxuICAgICAgICBpc1ZhbGlkOiBudWxsLFxuICAgICAgICBmcm9tLFxuICAgICAgICBmcm9tSGFuZGxlLFxuICAgICAgICBmcm9tUG9zaXRpb246IGZyb21IYW5kbGUucG9zaXRpb24sXG4gICAgICAgIGZyb21Ob2RlOiBmcm9tTm9kZUludGVybmFsLFxuICAgICAgICB0bzogcG9zaXRpb24sXG4gICAgICAgIHRvSGFuZGxlOiBudWxsLFxuICAgICAgICB0b1Bvc2l0aW9uOiBvcHBvc2l0ZVBvc2l0aW9uW2Zyb21IYW5kbGUucG9zaXRpb25dLFxuICAgICAgICB0b05vZGU6IG51bGwsXG4gICAgfTtcbiAgICBmdW5jdGlvbiBzdGFydENvbm5lY3Rpb24oKSB7XG4gICAgICAgIGNvbm5lY3Rpb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgdXBkYXRlQ29ubmVjdGlvbihwcmV2aW91c0Nvbm5lY3Rpb24pO1xuICAgICAgICBvbkNvbm5lY3RTdGFydD8uKGV2ZW50LCB7IG5vZGVJZCwgaGFuZGxlSWQsIGhhbmRsZVR5cGUgfSk7XG4gICAgfVxuICAgIGlmIChkcmFnVGhyZXNob2xkID09PSAwKSB7XG4gICAgICAgIHN0YXJ0Q29ubmVjdGlvbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmICghY29ubmVjdGlvblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeDogZXZ0WCwgeTogZXZ0WSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgICAgICAgICBjb25zdCBkeCA9IGV2dFggLSB4O1xuICAgICAgICAgICAgY29uc3QgZHkgPSBldnRZIC0geTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDb25uZWN0aW9uU3RhcnRlZCA9IGR4ICogZHggKyBkeSAqIGR5ID4gZHJhZ1RocmVzaG9sZCAqIGRyYWdUaHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAoIW5leHRDb25uZWN0aW9uU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0Q29ubmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ2V0RnJvbUhhbmRsZSgpIHx8ICFmcm9tSGFuZGxlKSB7XG4gICAgICAgICAgICBvblBvaW50ZXJVcChldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIHBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgY2xvc2VzdEhhbmRsZSA9IGdldENsb3Nlc3RIYW5kbGUocG9pbnRUb1JlbmRlcmVyUG9pbnQocG9zaXRpb24sIHRyYW5zZm9ybSwgZmFsc2UsIFsxLCAxXSksIGNvbm5lY3Rpb25SYWRpdXMsIG5vZGVMb29rdXAsIGZyb21IYW5kbGUpO1xuICAgICAgICBpZiAoIWF1dG9QYW5TdGFydGVkKSB7XG4gICAgICAgICAgICBhdXRvUGFuKCk7XG4gICAgICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaXNWYWxpZEhhbmRsZShldmVudCwge1xuICAgICAgICAgICAgaGFuZGxlOiBjbG9zZXN0SGFuZGxlLFxuICAgICAgICAgICAgY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBmcm9tTm9kZUlkOiBub2RlSWQsXG4gICAgICAgICAgICBmcm9tSGFuZGxlSWQ6IGhhbmRsZUlkLFxuICAgICAgICAgICAgZnJvbVR5cGU6IGlzVGFyZ2V0ID8gJ3RhcmdldCcgOiAnc291cmNlJyxcbiAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uLFxuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgZmxvd0lkLFxuICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdEhhbmRsZURvbU5vZGUgPSByZXN1bHQuaGFuZGxlRG9tTm9kZTtcbiAgICAgICAgY29ubmVjdGlvbiA9IHJlc3VsdC5jb25uZWN0aW9uO1xuICAgICAgICBpc1ZhbGlkID0gaXNDb25uZWN0aW9uVmFsaWQoISFjbG9zZXN0SGFuZGxlLCByZXN1bHQuaXNWYWxpZCk7XG4gICAgICAgIGNvbnN0IG5ld0Nvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICAvLyBmcm9tIHN0YXlzIHRoZSBzYW1lXG4gICAgICAgICAgICAuLi5wcmV2aW91c0Nvbm5lY3Rpb24sXG4gICAgICAgICAgICBpc1ZhbGlkLFxuICAgICAgICAgICAgdG86IHJlc3VsdC50b0hhbmRsZSAmJiBpc1ZhbGlkXG4gICAgICAgICAgICAgICAgPyByZW5kZXJlclBvaW50VG9Qb2ludCh7IHg6IHJlc3VsdC50b0hhbmRsZS54LCB5OiByZXN1bHQudG9IYW5kbGUueSB9LCB0cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgOiBwb3NpdGlvbixcbiAgICAgICAgICAgIHRvSGFuZGxlOiByZXN1bHQudG9IYW5kbGUsXG4gICAgICAgICAgICB0b1Bvc2l0aW9uOiBpc1ZhbGlkICYmIHJlc3VsdC50b0hhbmRsZSA/IHJlc3VsdC50b0hhbmRsZS5wb3NpdGlvbiA6IG9wcG9zaXRlUG9zaXRpb25bZnJvbUhhbmRsZS5wb3NpdGlvbl0sXG4gICAgICAgICAgICB0b05vZGU6IHJlc3VsdC50b0hhbmRsZSA/IG5vZGVMb29rdXAuZ2V0KHJlc3VsdC50b0hhbmRsZS5ub2RlSWQpIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgLypcbiAgICAgICAgICogd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGFuIHVwZGF0ZSB3aGVuIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAqIGlzIHNuYXBwZWQgdG8gdGhlIHNhbWUgaGFuZGxlIGFzIGJlZm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzVmFsaWQgJiZcbiAgICAgICAgICAgIGNsb3Nlc3RIYW5kbGUgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZSAmJlxuICAgICAgICAgICAgbmV3Q29ubmVjdGlvbi50b0hhbmRsZSAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlLnR5cGUgPT09IG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUudHlwZSAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlLm5vZGVJZCA9PT0gbmV3Q29ubmVjdGlvbi50b0hhbmRsZS5ub2RlSWQgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZS5pZCA9PT0gbmV3Q29ubmVjdGlvbi50b0hhbmRsZS5pZCAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvLnggPT09IG5ld0Nvbm5lY3Rpb24udG8ueCAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvLnkgPT09IG5ld0Nvbm5lY3Rpb24udG8ueSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24obmV3Q29ubmVjdGlvbik7XG4gICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgICAgIC8vIFByZXZlbnQgbXVsdGktdG91Y2ggYWJvcnRpbmcgY29ubmVjdGlvblxuICAgICAgICBpZiAoJ3RvdWNoZXMnIGluIGV2ZW50ICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uU3RhcnRlZCkge1xuICAgICAgICAgICAgaWYgKChjbG9zZXN0SGFuZGxlIHx8IHJlc3VsdEhhbmRsZURvbU5vZGUpICYmIGNvbm5lY3Rpb24gJiYgaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIG9uQ29ubmVjdD8uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGl0J3MgaW1wb3J0YW50IHRvIGdldCBhIGZyZXNoIHJlZmVyZW5jZSBmcm9tIHRoZSBzdG9yZSBoZXJlXG4gICAgICAgICAgICAgKiBpbiBvcmRlciB0byBnZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBvbkNvbm5lY3RFbmRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgY29uc3QgeyBpblByb2dyZXNzLCAuLi5jb25uZWN0aW9uU3RhdGUgfSA9IHByZXZpb3VzQ29ubmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQ29ubmVjdGlvblN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLmNvbm5lY3Rpb25TdGF0ZSxcbiAgICAgICAgICAgICAgICB0b1Bvc2l0aW9uOiBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUgPyBwcmV2aW91c0Nvbm5lY3Rpb24udG9Qb3NpdGlvbiA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb25Db25uZWN0RW5kPy4oZXZlbnQsIGZpbmFsQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgICAgIGlmIChlZGdlVXBkYXRlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBvblJlY29ubmVjdEVuZD8uKGV2ZW50LCBmaW5hbENvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FuY2VsQ29ubmVjdGlvbigpO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhdXRvUGFuSWQpO1xuICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIGNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICByZXN1bHRIYW5kbGVEb21Ob2RlID0gbnVsbDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uUG9pbnRlclVwKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uUG9pbnRlclVwKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Qb2ludGVyVXApO1xufVxuLy8gY2hlY2tzIGlmICBhbmQgcmV0dXJucyBjb25uZWN0aW9uIGluIGZvbSBvZiBhbiBvYmplY3QgeyBzb3VyY2U6IDEyMywgdGFyZ2V0OiAzMTIgfVxuZnVuY3Rpb24gaXNWYWxpZEhhbmRsZShldmVudCwgeyBoYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBmcm9tTm9kZUlkLCBmcm9tSGFuZGxlSWQsIGZyb21UeXBlLCBkb2MsIGxpYiwgZmxvd0lkLCBpc1ZhbGlkQ29ubmVjdGlvbiA9IGFsd2F5c1ZhbGlkLCBub2RlTG9va3VwLCB9KSB7XG4gICAgY29uc3QgaXNUYXJnZXQgPSBmcm9tVHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgY29uc3QgaGFuZGxlRG9tTm9kZSA9IGhhbmRsZVxuICAgICAgICA/IGRvYy5xdWVyeVNlbGVjdG9yKGAuJHtsaWJ9LWZsb3dfX2hhbmRsZVtkYXRhLWlkPVwiJHtmbG93SWR9LSR7aGFuZGxlPy5ub2RlSWR9LSR7aGFuZGxlPy5pZH0tJHtoYW5kbGU/LnR5cGV9XCJdYClcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgaGFuZGxlQmVsb3cgPSBkb2MuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAvKlxuICAgICAqIHdlIGFsd2F5cyB3YW50IHRvIHByaW9yaXRpemUgdGhlIGhhbmRsZSBiZWxvdyB0aGUgbW91c2UgY3Vyc29yIG92ZXIgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgaGFuZGxlLFxuICAgICAqIGJlY2F1c2UgaXQgY291bGQgYmUgdGhhdCB0aGUgY2VudGVyIG9mIGFub3RoZXIgaGFuZGxlIGlzIGNsb3NlciB0byB0aGUgbW91c2UgcG9pbnRlciB0aGFuIHRoZSBoYW5kbGUgYmVsb3cgdGhlIGN1cnNvclxuICAgICAqL1xuICAgIGNvbnN0IGhhbmRsZVRvQ2hlY2sgPSBoYW5kbGVCZWxvdz8uY2xhc3NMaXN0LmNvbnRhaW5zKGAke2xpYn0tZmxvd19faGFuZGxlYCkgPyBoYW5kbGVCZWxvdyA6IGhhbmRsZURvbU5vZGU7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBoYW5kbGVEb21Ob2RlOiBoYW5kbGVUb0NoZWNrLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgY29ubmVjdGlvbjogbnVsbCxcbiAgICAgICAgdG9IYW5kbGU6IG51bGwsXG4gICAgfTtcbiAgICBpZiAoaGFuZGxlVG9DaGVjaykge1xuICAgICAgICBjb25zdCBoYW5kbGVUeXBlID0gZ2V0SGFuZGxlVHlwZSh1bmRlZmluZWQsIGhhbmRsZVRvQ2hlY2spO1xuICAgICAgICBjb25zdCBoYW5kbGVOb2RlSWQgPSBoYW5kbGVUb0NoZWNrLmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKTtcbiAgICAgICAgY29uc3QgaGFuZGxlSWQgPSBoYW5kbGVUb0NoZWNrLmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVpZCcpO1xuICAgICAgICBjb25zdCBjb25uZWN0YWJsZSA9IGhhbmRsZVRvQ2hlY2suY2xhc3NMaXN0LmNvbnRhaW5zKCdjb25uZWN0YWJsZScpO1xuICAgICAgICBjb25zdCBjb25uZWN0YWJsZUVuZCA9IGhhbmRsZVRvQ2hlY2suY2xhc3NMaXN0LmNvbnRhaW5zKCdjb25uZWN0YWJsZWVuZCcpO1xuICAgICAgICBpZiAoIWhhbmRsZU5vZGVJZCB8fCAhaGFuZGxlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgc291cmNlOiBpc1RhcmdldCA/IGhhbmRsZU5vZGVJZCA6IGZyb21Ob2RlSWQsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IGlzVGFyZ2V0ID8gaGFuZGxlSWQgOiBmcm9tSGFuZGxlSWQsXG4gICAgICAgICAgICB0YXJnZXQ6IGlzVGFyZ2V0ID8gZnJvbU5vZGVJZCA6IGhhbmRsZU5vZGVJZCxcbiAgICAgICAgICAgIHRhcmdldEhhbmRsZTogaXNUYXJnZXQgPyBmcm9tSGFuZGxlSWQgOiBoYW5kbGVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVzdWx0LmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBpc0Nvbm5lY3RhYmxlID0gY29ubmVjdGFibGUgJiYgY29ubmVjdGFibGVFbmQ7XG4gICAgICAgIC8vIGluIHN0cmljdCBtb2RlIHdlIGRvbid0IGFsbG93IHRhcmdldCB0byB0YXJnZXQgb3Igc291cmNlIHRvIHNvdXJjZSBjb25uZWN0aW9uc1xuICAgICAgICBjb25zdCBpc1ZhbGlkID0gaXNDb25uZWN0YWJsZSAmJlxuICAgICAgICAgICAgKGNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5TdHJpY3RcbiAgICAgICAgICAgICAgICA/IChpc1RhcmdldCAmJiBoYW5kbGVUeXBlID09PSAnc291cmNlJykgfHwgKCFpc1RhcmdldCAmJiBoYW5kbGVUeXBlID09PSAndGFyZ2V0JylcbiAgICAgICAgICAgICAgICA6IGhhbmRsZU5vZGVJZCAhPT0gZnJvbU5vZGVJZCB8fCBoYW5kbGVJZCAhPT0gZnJvbUhhbmRsZUlkKTtcbiAgICAgICAgcmVzdWx0LmlzVmFsaWQgPSBpc1ZhbGlkICYmIGlzVmFsaWRDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICByZXN1bHQudG9IYW5kbGUgPSBnZXRIYW5kbGUoaGFuZGxlTm9kZUlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbk1vZGUsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgWFlIYW5kbGUgPSB7XG4gICAgb25Qb2ludGVyRG93bixcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkSGFuZGxlLFxufTtcblxuZnVuY3Rpb24gWFlNaW5pbWFwKHsgZG9tTm9kZSwgcGFuWm9vbSwgZ2V0VHJhbnNmb3JtLCBnZXRWaWV3U2NhbGUgfSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKTtcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQsIHpvb21TdGVwID0gMSwgcGFubmFibGUgPSB0cnVlLCB6b29tYWJsZSA9IHRydWUsIGludmVyc2VQYW4gPSBmYWxzZSwgfSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCB6b29tSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50LnR5cGUgIT09ICd3aGVlbCcgfHwgIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvciA9IGV2ZW50LnNvdXJjZUV2ZW50LmN0cmxLZXkgJiYgaXNNYWNPcygpID8gMTAgOiAxO1xuICAgICAgICAgICAgY29uc3QgcGluY2hEZWx0YSA9IC1ldmVudC5zb3VyY2VFdmVudC5kZWx0YVkgKlxuICAgICAgICAgICAgICAgIChldmVudC5zb3VyY2VFdmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuc291cmNlRXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqXG4gICAgICAgICAgICAgICAgem9vbVN0ZXA7XG4gICAgICAgICAgICBjb25zdCBuZXh0Wm9vbSA9IHRyYW5zZm9ybVsyXSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEgKiBmYWN0b3IpO1xuICAgICAgICAgICAgcGFuWm9vbS5zY2FsZVRvKG5leHRab29tKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBhblN0YXJ0ID0gWzAsIDBdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYW5TdGFydEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudC5zb3VyY2VFdmVudC50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBwYW5TdGFydCA9IFtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc291cmNlRXZlbnQuY2xpZW50WCA/PyBldmVudC5zb3VyY2VFdmVudC50b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFkgPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRZLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHBhbkhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgaWYgKChldmVudC5zb3VyY2VFdmVudC50eXBlICE9PSAnbW91c2Vtb3ZlJyAmJiBldmVudC5zb3VyY2VFdmVudC50eXBlICE9PSAndG91Y2htb3ZlJykgfHwgIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYW5DdXJyZW50ID0gW1xuICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFggPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFkgPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRZLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHBhbkRlbHRhID0gW3BhbkN1cnJlbnRbMF0gLSBwYW5TdGFydFswXSwgcGFuQ3VycmVudFsxXSAtIHBhblN0YXJ0WzFdXTtcbiAgICAgICAgICAgIHBhblN0YXJ0ID0gcGFuQ3VycmVudDtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVTY2FsZSA9IGdldFZpZXdTY2FsZSgpICogTWF0aC5tYXgodHJhbnNmb3JtWzJdLCBNYXRoLmxvZyh0cmFuc2Zvcm1bMl0pKSAqIChpbnZlcnNlUGFuID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IHRyYW5zZm9ybVswXSAtIHBhbkRlbHRhWzBdICogbW92ZVNjYWxlLFxuICAgICAgICAgICAgICAgIHk6IHRyYW5zZm9ybVsxXSAtIHBhbkRlbHRhWzFdICogbW92ZVNjYWxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHBhblpvb20uc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh7XG4gICAgICAgICAgICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgIHpvb206IHRyYW5zZm9ybVsyXSxcbiAgICAgICAgICAgIH0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgem9vbUFuZFBhbkhhbmRsZXIgPSB6b29tKClcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCBwYW5TdGFydEhhbmRsZXIpXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAub24oJ3pvb20nLCBwYW5uYWJsZSA/IHBhbkhhbmRsZXIgOiBudWxsKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgLm9uKCd6b29tLndoZWVsJywgem9vbWFibGUgPyB6b29tSGFuZGxlciA6IG51bGwpO1xuICAgICAgICBzZWxlY3Rpb24uY2FsbCh6b29tQW5kUGFuSGFuZGxlciwge30pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBzZWxlY3Rpb24ub24oJ3pvb20nLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkZXN0cm95LFxuICAgICAgICBwb2ludGVyLFxuICAgIH07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IHZpZXdDaGFuZ2VkID0gKHByZXZWaWV3cG9ydCwgZXZlbnRWaWV3cG9ydCkgPT4gcHJldlZpZXdwb3J0LnggIT09IGV2ZW50Vmlld3BvcnQueCB8fCBwcmV2Vmlld3BvcnQueSAhPT0gZXZlbnRWaWV3cG9ydC55IHx8IHByZXZWaWV3cG9ydC56b29tICE9PSBldmVudFZpZXdwb3J0Lms7XG5jb25zdCB0cmFuc2Zvcm1Ub1ZpZXdwb3J0ID0gKHRyYW5zZm9ybSkgPT4gKHtcbiAgICB4OiB0cmFuc2Zvcm0ueCxcbiAgICB5OiB0cmFuc2Zvcm0ueSxcbiAgICB6b29tOiB0cmFuc2Zvcm0uayxcbn0pO1xuY29uc3Qgdmlld3BvcnRUb1RyYW5zZm9ybSA9ICh7IHgsIHksIHpvb20gfSkgPT4gem9vbUlkZW50aXR5LnRyYW5zbGF0ZSh4LCB5KS5zY2FsZSh6b29tKTtcbmNvbnN0IGlzV3JhcHBlZFdpdGhDbGFzcyA9IChldmVudCwgY2xhc3NOYW1lKSA9PiBldmVudC50YXJnZXQuY2xvc2VzdChgLiR7Y2xhc3NOYW1lfWApO1xuY29uc3QgaXNSaWdodENsaWNrUGFuID0gKHBhbk9uRHJhZywgdXNlZEJ1dHRvbikgPT4gdXNlZEJ1dHRvbiA9PT0gMiAmJiBBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnLmluY2x1ZGVzKDIpO1xuLy8gdGFrZW4gZnJvbSBkMy1lYXNlOiBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtZWFzZS9ibG9iL21haW4vc3JjL2N1YmljLmpzXG5jb25zdCBkZWZhdWx0RWFzZSA9ICh0KSA9PiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG5jb25zdCBnZXREM1RyYW5zaXRpb24gPSAoc2VsZWN0aW9uLCBkdXJhdGlvbiA9IDAsIGVhc2UgPSBkZWZhdWx0RWFzZSwgb25FbmQgPSAoKSA9PiB7IH0pID0+IHtcbiAgICBjb25zdCBoYXNEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgZHVyYXRpb24gPiAwO1xuICAgIGlmICghaGFzRHVyYXRpb24pIHtcbiAgICAgICAgb25FbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0R1cmF0aW9uID8gc2VsZWN0aW9uLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuZWFzZShlYXNlKS5vbignZW5kJywgb25FbmQpIDogc2VsZWN0aW9uO1xufTtcbmNvbnN0IHdoZWVsRGVsdGEgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBmYWN0b3IgPSBldmVudC5jdHJsS2V5ICYmIGlzTWFjT3MoKSA/IDEwIDogMTtcbiAgICByZXR1cm4gLWV2ZW50LmRlbHRhWSAqIChldmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqIGZhY3Rvcjtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhbk9uU2Nyb2xsSGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIG5vV2hlZWxDbGFzc05hbWUsIGQzU2VsZWN0aW9uLCBkM1pvb20sIHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25TY3JvbGxTcGVlZCwgem9vbU9uUGluY2gsIG9uUGFuWm9vbVN0YXJ0LCBvblBhblpvb20sIG9uUGFuWm9vbUVuZCwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSBkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJykuayB8fCAxO1xuICAgICAgICAvLyBtYWNvcyBzZXRzIGN0cmxLZXk9dHJ1ZSBmb3IgcGluY2ggZ2VzdHVyZSBvbiBhIHRyYWNrcGFkXG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmIHpvb21PblBpbmNoKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50ZXIoZXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgcGluY2hEZWx0YSA9IHdoZWVsRGVsdGEoZXZlbnQpO1xuICAgICAgICAgICAgY29uc3Qgem9vbSA9IGN1cnJlbnRab29tICogTWF0aC5wb3coMiwgcGluY2hEZWx0YSk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBkM1pvb20uc2NhbGVUbyhkM1NlbGVjdGlvbiwgem9vbSwgcG9pbnQsIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBpbmNyZWFzZSBzY3JvbGwgc3BlZWQgaW4gZmlyZWZveFxuICAgICAgICAgKiBmaXJlZm94OiBkZWx0YU1vZGUgPT09IDE7IGNocm9tZTogZGVsdGFNb2RlID09PSAwXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBkZWx0YU5vcm1hbGl6ZSA9IGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDIwIDogMTtcbiAgICAgICAgbGV0IGRlbHRhWCA9IHBhbk9uU2Nyb2xsTW9kZSA9PT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsID8gMCA6IGV2ZW50LmRlbHRhWCAqIGRlbHRhTm9ybWFsaXplO1xuICAgICAgICBsZXQgZGVsdGFZID0gcGFuT25TY3JvbGxNb2RlID09PSBQYW5PblNjcm9sbE1vZGUuSG9yaXpvbnRhbCA/IDAgOiBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgLy8gdGhpcyBlbmFibGVzIHZlcnRpY2FsIHNjcm9sbGluZyB3aXRoIHNoaWZ0ICsgc2Nyb2xsIG9uIHdpbmRvd3NcbiAgICAgICAgaWYgKCFpc01hY09zKCkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgcGFuT25TY3JvbGxNb2RlICE9PSBQYW5PblNjcm9sbE1vZGUuVmVydGljYWwpIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IGV2ZW50LmRlbHRhWSAqIGRlbHRhTm9ybWFsaXplO1xuICAgICAgICAgICAgZGVsdGFZID0gMDtcbiAgICAgICAgfVxuICAgICAgICBkM1pvb20udHJhbnNsYXRlQnkoZDNTZWxlY3Rpb24sIC0oZGVsdGFYIC8gY3VycmVudFpvb20pICogcGFuT25TY3JvbGxTcGVlZCwgLShkZWx0YVkgLyBjdXJyZW50Wm9vbSkgKiBwYW5PblNjcm9sbFNwZWVkLCBcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB7IGludGVybmFsOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBuZXh0Vmlld3BvcnQgPSB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGQzU2VsZWN0aW9uLnByb3BlcnR5KCdfX3pvb20nKSk7XG4gICAgICAgIGNsZWFyVGltZW91dCh6b29tUGFuVmFsdWVzLnBhblNjcm9sbFRpbWVvdXQpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBmb3IgcGFuIG9uIHNjcm9sbCB3ZSBuZWVkIHRvIGhhbmRsZSB0aGUgZXZlbnQgY2FsbHMgb24gb3VyIG93blxuICAgICAgICAgKiB3ZSBjYW4ndCB1c2UgdGhlIHN0YXJ0LCB6b29tIGFuZCBlbmQgZXZlbnRzIGZyb20gZDMtem9vbVxuICAgICAgICAgKiBiZWNhdXNlIHN0YXJ0IGFuZCBtb3ZlIGdldHMgY2FsbGVkIG9uIGV2ZXJ5IHNjcm9sbCBldmVudCBhbmQgbm90IG9uY2UgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0Py4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHpvb21QYW5WYWx1ZXMuaXNQYW5TY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIG9uUGFuWm9vbT8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy5wYW5TY3JvbGxUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kPy4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVab29tT25TY3JvbGxIYW5kbGVyKHsgbm9XaGVlbENsYXNzTmFtZSwgcHJldmVudFNjcm9sbGluZywgZDNab29tSGFuZGxlciB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCwgZCkge1xuICAgICAgICBjb25zdCBpc1doZWVsID0gZXZlbnQudHlwZSA9PT0gJ3doZWVsJztcbiAgICAgICAgLy8gd2Ugc3RpbGwgd2FudCB0byBlbmFibGUgcGluY2ggem9vbWluZyBldmVuIGlmIHByZXZlbnRTY3JvbGxpbmcgaXMgc2V0IHRvIGZhbHNlXG4gICAgICAgIGNvbnN0IHByZXZlbnRab29tID0gIXByZXZlbnRTY3JvbGxpbmcgJiYgaXNXaGVlbCAmJiAhZXZlbnQuY3RybEtleTtcbiAgICAgICAgY29uc3QgaGFzTm9XaGVlbENsYXNzID0gaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKTtcbiAgICAgICAgLy8gaWYgdXNlciBpcyBwaW5jaCB6b29taW5nIGFib3ZlIGEgbm93aGVlbCBlbGVtZW50LCB3ZSBkb24ndCB3YW50IHRoZSBicm93c2VyIHRvIHpvb21cbiAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgaXNXaGVlbCAmJiBoYXNOb1doZWVsQ2xhc3MpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZlbnRab29tIHx8IGhhc05vV2hlZWxDbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZDNab29tSGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50LCBkKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGFuWm9vbVN0YXJ0SGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIG9uRHJhZ2dpbmdDaGFuZ2UsIG9uUGFuWm9vbVN0YXJ0IH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8uaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHRyYW5zZm9ybVRvVmlld3BvcnQoZXZlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZW1lbWJlciBpdCBoZXJlLCBiZWNhdXNlIGl0J3MgYWx3YXlzIDAgaW4gdGhlIFwiem9vbVwiIGV2ZW50XG4gICAgICAgIHpvb21QYW5WYWx1ZXMubW91c2VCdXR0b24gPSBldmVudC5zb3VyY2VFdmVudD8uYnV0dG9uIHx8IDA7XG4gICAgICAgIHpvb21QYW5WYWx1ZXMuaXNab29taW5nT3JQYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgem9vbVBhblZhbHVlcy5wcmV2Vmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50Py50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgb25EcmFnZ2luZ0NoYW5nZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25QYW5ab29tU3RhcnQpIHtcbiAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIHZpZXdwb3J0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYW5ab29tSGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIHBhbk9uRHJhZywgb25QYW5lQ29udGV4dE1lbnUsIG9uVHJhbnNmb3JtQ2hhbmdlLCBvblBhblpvb20sIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIHpvb21QYW5WYWx1ZXMudXNlZFJpZ2h0TW91c2VCdXR0b24gPSAhIShvblBhbmVDb250ZXh0TWVudSAmJiBpc1JpZ2h0Q2xpY2tQYW4ocGFuT25EcmFnLCB6b29tUGFuVmFsdWVzLm1vdXNlQnV0dG9uID8/IDApKTtcbiAgICAgICAgaWYgKCFldmVudC5zb3VyY2VFdmVudD8uc3luYykge1xuICAgICAgICAgICAgb25UcmFuc2Zvcm1DaGFuZ2UoW2V2ZW50LnRyYW5zZm9ybS54LCBldmVudC50cmFuc2Zvcm0ueSwgZXZlbnQudHJhbnNmb3JtLmtdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25QYW5ab29tICYmICFldmVudC5zb3VyY2VFdmVudD8uaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIG9uUGFuWm9vbT8uKGV2ZW50LnNvdXJjZUV2ZW50LCB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGV2ZW50LnRyYW5zZm9ybSkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhblpvb21FbmRIYW5kbGVyKHsgem9vbVBhblZhbHVlcywgcGFuT25EcmFnLCBwYW5PblNjcm9sbCwgb25EcmFnZ2luZ0NoYW5nZSwgb25QYW5ab29tRW5kLCBvblBhbmVDb250ZXh0TWVudSwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50Py5pbnRlcm5hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHpvb21QYW5WYWx1ZXMuaXNab29taW5nT3JQYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChvblBhbmVDb250ZXh0TWVudSAmJlxuICAgICAgICAgICAgaXNSaWdodENsaWNrUGFuKHBhbk9uRHJhZywgem9vbVBhblZhbHVlcy5tb3VzZUJ1dHRvbiA/PyAwKSAmJlxuICAgICAgICAgICAgIXpvb21QYW5WYWx1ZXMudXNlZFJpZ2h0TW91c2VCdXR0b24gJiZcbiAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudShldmVudC5zb3VyY2VFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgem9vbVBhblZhbHVlcy51c2VkUmlnaHRNb3VzZUJ1dHRvbiA9IGZhbHNlO1xuICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgaWYgKG9uUGFuWm9vbUVuZCAmJiB2aWV3Q2hhbmdlZCh6b29tUGFuVmFsdWVzLnByZXZWaWV3cG9ydCwgZXZlbnQudHJhbnNmb3JtKSkge1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLnByZXZWaWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHpvb21QYW5WYWx1ZXMudGltZXJJZCk7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLnRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQ/LihldmVudC5zb3VyY2VFdmVudCwgdmlld3BvcnQpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGEgc2V0VGltZW91dCBmb3IgcGFuT25TY3JvbGwgdG8gc3VwcmVzcyBtdWx0aXBsZSBlbmQgZXZlbnRzIGZpcmVkIGR1cmluZyBzY3JvbGxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsID8gMTUwIDogMCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXIoeyB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uRHJhZywgcGFuT25TY3JvbGwsIHpvb21PbkRvdWJsZUNsaWNrLCB1c2VyU2VsZWN0aW9uQWN0aXZlLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgbGliLCBjb25uZWN0aW9uSW5Qcm9ncmVzcywgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3Qgem9vbVNjcm9sbCA9IHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCB6b29tT25TY3JvbGw7XG4gICAgICAgIGNvbnN0IHBpbmNoWm9vbSA9IHpvb21PblBpbmNoICYmIGV2ZW50LmN0cmxLZXk7XG4gICAgICAgIGNvbnN0IGlzV2hlZWxFdmVudCA9IGV2ZW50LnR5cGUgPT09ICd3aGVlbCc7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT09IDEgJiZcbiAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nICYmXG4gICAgICAgICAgICAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBgJHtsaWJ9LWZsb3dfX25vZGVgKSB8fCBpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIGAke2xpYn0tZmxvd19fZWRnZWApKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYWxsIGludGVyYWN0aW9ucyBhcmUgZGlzYWJsZWQsIHdlIHByZXZlbnQgYWxsIHpvb20gZXZlbnRzXG4gICAgICAgIGlmICghcGFuT25EcmFnICYmICF6b29tU2Nyb2xsICYmICFwYW5PblNjcm9sbCAmJiAhem9vbU9uRG91YmxlQ2xpY2sgJiYgIXpvb21PblBpbmNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZHVyaW5nIGEgc2VsZWN0aW9uIHdlIHByZXZlbnQgYWxsIG90aGVyIGludGVyYWN0aW9uc1xuICAgICAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gZGlzYWJsZSBwaW5jaC16b29taW5nIHdoaWxlIG1ha2luZyBhIGNvbm5lY3Rpb25cbiAgICAgICAgaWYgKGNvbm5lY3Rpb25JblByb2dyZXNzICYmICFpc1doZWVsRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgaW5zaWRlIGFuIGVsZW1lbnQgd2l0aCB0aGUgbm93aGVlbCBjbGFzcywgd2UgcHJldmVudCB6b29taW5nXG4gICAgICAgIGlmIChpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIG5vV2hlZWxDbGFzc05hbWUpICYmIGlzV2hlZWxFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHRoZSBub3BhbiBjbGFzcywgd2UgcHJldmVudCBwYW5uaW5nXG4gICAgICAgIGlmIChpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIG5vUGFuQ2xhc3NOYW1lKSAmJlxuICAgICAgICAgICAgKCFpc1doZWVsRXZlbnQgfHwgKHBhbk9uU2Nyb2xsICYmIGlzV2hlZWxFdmVudCAmJiAhem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXpvb21PblBpbmNoICYmIGV2ZW50LmN0cmxLZXkgJiYgaXNXaGVlbEV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6b29tT25QaW5jaCAmJiBldmVudC50eXBlID09PSAndG91Y2hzdGFydCcgJiYgZXZlbnQudG91Y2hlcz8ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gaWYgeW91IG1hbmFnZSB0byBzdGFydCB3aXRoIDIgdG91Y2hlcywgd2UgcHJldmVudCBuYXRpdmUgem9vbVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdoZW4gdGhlcmUgaXMgbm8gc2Nyb2xsIGhhbmRsaW5nIGVuYWJsZWQsIHdlIHByZXZlbnQgYWxsIHdoZWVsIGV2ZW50c1xuICAgICAgICBpZiAoIXpvb21TY3JvbGwgJiYgIXBhbk9uU2Nyb2xsICYmICFwaW5jaFpvb20gJiYgaXNXaGVlbEV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHBhbmUgaXMgbm90IG1vdmFibGUsIHdlIHByZXZlbnQgZHJhZ2dpbmcgaXQgd2l0aCBtb3VzZXN0YXJ0IG9yIHRvdWNoc3RhcnRcbiAgICAgICAgaWYgKCFwYW5PbkRyYWcgJiYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgcGFuZSBpcyBvbmx5IG1vdmFibGUgdXNpbmcgYWxsb3dlZCBjbGlja3NcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiAhcGFuT25EcmFnLmluY2x1ZGVzKGV2ZW50LmJ1dHRvbikgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBvbmx5IGFsbG93IHJpZ2h0IGNsaWNrcyBpZiBwYW4gb24gZHJhZyBpcyBzZXQgdG8gcmlnaHQgY2xpY2tcbiAgICAgICAgY29uc3QgYnV0dG9uQWxsb3dlZCA9IChBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnLmluY2x1ZGVzKGV2ZW50LmJ1dHRvbikpIHx8ICFldmVudC5idXR0b24gfHwgZXZlbnQuYnV0dG9uIDw9IDE7XG4gICAgICAgIC8vIGRlZmF1bHQgZmlsdGVyIGZvciBkMy16b29tXG4gICAgICAgIHJldHVybiAoIWV2ZW50LmN0cmxLZXkgfHwgaXNXaGVlbEV2ZW50KSAmJiBidXR0b25BbGxvd2VkO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIFhZUGFuWm9vbSh7IGRvbU5vZGUsIG1pblpvb20sIG1heFpvb20sIHBhbmVDbGlja0Rpc3RhbmNlLCB0cmFuc2xhdGVFeHRlbnQsIHZpZXdwb3J0LCBvblBhblpvb20sIG9uUGFuWm9vbVN0YXJ0LCBvblBhblpvb21FbmQsIG9uRHJhZ2dpbmdDaGFuZ2UsIH0pIHtcbiAgICBjb25zdCB6b29tUGFuVmFsdWVzID0ge1xuICAgICAgICBpc1pvb21pbmdPclBhbm5pbmc6IGZhbHNlLFxuICAgICAgICB1c2VkUmlnaHRNb3VzZUJ1dHRvbjogZmFsc2UsXG4gICAgICAgIHByZXZWaWV3cG9ydDogeyB4OiAwLCB5OiAwLCB6b29tOiAwIH0sXG4gICAgICAgIG1vdXNlQnV0dG9uOiAwLFxuICAgICAgICB0aW1lcklkOiB1bmRlZmluZWQsXG4gICAgICAgIHBhblNjcm9sbFRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNQYW5TY3JvbGxpbmc6IGZhbHNlLFxuICAgIH07XG4gICAgY29uc3QgYmJveCA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZDNab29tSW5zdGFuY2UgPSB6b29tKClcbiAgICAgICAgLmNsaWNrRGlzdGFuY2UoIWlzTnVtZXJpYyhwYW5lQ2xpY2tEaXN0YW5jZSkgfHwgcGFuZUNsaWNrRGlzdGFuY2UgPCAwID8gMCA6IHBhbmVDbGlja0Rpc3RhbmNlKVxuICAgICAgICAuc2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKVxuICAgICAgICAudHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgY29uc3QgZDNTZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSkuY2FsbChkM1pvb21JbnN0YW5jZSk7XG4gICAgc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh7XG4gICAgICAgIHg6IHZpZXdwb3J0LngsXG4gICAgICAgIHk6IHZpZXdwb3J0LnksXG4gICAgICAgIHpvb206IGNsYW1wKHZpZXdwb3J0Lnpvb20sIG1pblpvb20sIG1heFpvb20pLFxuICAgIH0sIFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbYmJveC53aWR0aCwgYmJveC5oZWlnaHRdLFxuICAgIF0sIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgY29uc3QgZDNab29tSGFuZGxlciA9IGQzU2VsZWN0aW9uLm9uKCd3aGVlbC56b29tJyk7XG4gICAgY29uc3QgZDNEYmxDbGlja1pvb21IYW5kbGVyID0gZDNTZWxlY3Rpb24ub24oJ2RibGNsaWNrLnpvb20nKTtcbiAgICBkM1pvb21JbnN0YW5jZS53aGVlbERlbHRhKHdoZWVsRGVsdGEpO1xuICAgIGZ1bmN0aW9uIHNldFRyYW5zZm9ybSh0cmFuc2Zvcm0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8uaW50ZXJwb2xhdGUob3B0aW9ucz8uaW50ZXJwb2xhdGUgPT09ICdsaW5lYXInID8gaW50ZXJwb2xhdGUgOiBpbnRlcnBvbGF0ZVpvb20pLnRyYW5zZm9ybShnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uLCBvcHRpb25zPy5lYXNlLCAoKSA9PiByZXNvbHZlKHRydWUpKSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIG9uUGFuZUNvbnRleHRNZW51LCB1c2VyU2VsZWN0aW9uQWN0aXZlLCBwYW5PblNjcm9sbCwgcGFuT25EcmFnLCBwYW5PblNjcm9sbE1vZGUsIHBhbk9uU2Nyb2xsU3BlZWQsIHByZXZlbnRTY3JvbGxpbmcsIHpvb21PblBpbmNoLCB6b29tT25TY3JvbGwsIHpvb21PbkRvdWJsZUNsaWNrLCB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsIGxpYiwgb25UcmFuc2Zvcm1DaGFuZ2UsIGNvbm5lY3Rpb25JblByb2dyZXNzLCB9KSB7XG4gICAgICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlICYmICF6b29tUGFuVmFsdWVzLmlzWm9vbWluZ09yUGFubmluZykge1xuICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzUGFuT25TY3JvbGwgPSBwYW5PblNjcm9sbCAmJiAhem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkICYmICF1c2VyU2VsZWN0aW9uQWN0aXZlO1xuICAgICAgICBjb25zdCB3aGVlbEhhbmRsZXIgPSBpc1Bhbk9uU2Nyb2xsXG4gICAgICAgICAgICA/IGNyZWF0ZVBhbk9uU2Nyb2xsSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGQzU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGQzWm9vbTogZDNab29tSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICAgICAgICAgIHBhbk9uU2Nyb2xsU3BlZWQsXG4gICAgICAgICAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tU3RhcnQsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGNyZWF0ZVpvb21PblNjcm9sbEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbGluZyxcbiAgICAgICAgICAgICAgICBkM1pvb21IYW5kbGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGQzU2VsZWN0aW9uLm9uKCd3aGVlbC56b29tJywgd2hlZWxIYW5kbGVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICBpZiAoIXVzZXJTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIHBhbiB6b29tIHN0YXJ0XG4gICAgICAgICAgICBjb25zdCBzdGFydEhhbmRsZXIgPSBjcmVhdGVQYW5ab29tU3RhcnRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLFxuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tU3RhcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCdzdGFydCcsIHN0YXJ0SGFuZGxlcik7XG4gICAgICAgICAgICAvLyBwYW4gem9vbVxuICAgICAgICAgICAgY29uc3QgcGFuWm9vbUhhbmRsZXIgPSBjcmVhdGVQYW5ab29tSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnU6ICEhb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tLFxuICAgICAgICAgICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignem9vbScsIHBhblpvb21IYW5kbGVyKTtcbiAgICAgICAgICAgIC8vIHBhbiB6b29tIGVuZFxuICAgICAgICAgICAgY29uc3QgcGFuWm9vbUVuZEhhbmRsZXIgPSBjcmVhdGVQYW5ab29tRW5kSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kLFxuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCdlbmQnLCBwYW5ab29tRW5kSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyID0gY3JlYXRlRmlsdGVyKHtcbiAgICAgICAgICAgIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCxcbiAgICAgICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgICAgIHpvb21PblNjcm9sbCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBjb25uZWN0aW9uSW5Qcm9ncmVzcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlLmZpbHRlcihmaWx0ZXIpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBXZSBjYW5ub3QgYWRkIHpvb21PbkRvdWJsZUNsaWNrIHRvIHRoZSBmaWx0ZXIgYWJvdmUgYmVjYXVzZVxuICAgICAgICAgKiBkb3VibGUgdGFwcGluZyBvbiB0b3VjaCBzY3JlZW5zIGNpcmN1bXZlbnRzIHRoZSBmaWx0ZXIgYW5kXG4gICAgICAgICAqIGRibGNsaWNrLnpvb20gaXMgZmlyZWQgb24gdGhlIHNlbGVjdGlvbiBkaXJlY3RseVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHpvb21PbkRvdWJsZUNsaWNrKSB7XG4gICAgICAgICAgICBkM1NlbGVjdGlvbi5vbignZGJsY2xpY2suem9vbScsIGQzRGJsQ2xpY2tab29tSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkM1NlbGVjdGlvbi5vbignZGJsY2xpY2suem9vbScsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCd6b29tJywgbnVsbCk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNldFZpZXdwb3J0Q29uc3RyYWluZWQodmlld3BvcnQsIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSB7XG4gICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB2aWV3cG9ydFRvVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICAgICAgY29uc3QgY29udHJhaW5lZFRyYW5zZm9ybSA9IGQzWm9vbUluc3RhbmNlPy5jb25zdHJhaW4oKShuZXh0VHJhbnNmb3JtLCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIGlmIChjb250cmFpbmVkVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBhd2FpdCBzZXRUcmFuc2Zvcm0oY29udHJhaW5lZFRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlKGNvbnRyYWluZWRUcmFuc2Zvcm0pKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2V0Vmlld3BvcnQodmlld3BvcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbmV4dFRyYW5zZm9ybSA9IHZpZXdwb3J0VG9UcmFuc2Zvcm0odmlld3BvcnQpO1xuICAgICAgICBhd2FpdCBzZXRUcmFuc2Zvcm0obmV4dFRyYW5zZm9ybSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZShuZXh0VHJhbnNmb3JtKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN5bmNWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB2aWV3cG9ydFRvVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRyYW5zZm9ybS5rICE9PSB2aWV3cG9ydC56b29tIHx8XG4gICAgICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybS54ICE9PSB2aWV3cG9ydC54IHx8XG4gICAgICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybS55ICE9PSB2aWV3cG9ydC55KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8udHJhbnNmb3JtKGQzU2VsZWN0aW9uLCBuZXh0VHJhbnNmb3JtLCBudWxsLCB7IHN5bmM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Vmlld3BvcnQoKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGQzU2VsZWN0aW9uID8gem9vbVRyYW5zZm9ybShkM1NlbGVjdGlvbi5ub2RlKCkpIDogeyB4OiAwLCB5OiAwLCBrOiAxIH07XG4gICAgICAgIHJldHVybiB7IHg6IHRyYW5zZm9ybS54LCB5OiB0cmFuc2Zvcm0ueSwgem9vbTogdHJhbnNmb3JtLmsgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVUbyh6b29tLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LmludGVycG9sYXRlKG9wdGlvbnM/LmludGVycG9sYXRlID09PSAnbGluZWFyJyA/IGludGVycG9sYXRlIDogaW50ZXJwb2xhdGVab29tKS5zY2FsZVRvKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24sIG9wdGlvbnM/LmVhc2UsICgpID0+IHJlc29sdmUodHJ1ZSkpLCB6b29tKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZUJ5KGZhY3Rvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlPy5pbnRlcnBvbGF0ZShvcHRpb25zPy5pbnRlcnBvbGF0ZSA9PT0gJ2xpbmVhcicgPyBpbnRlcnBvbGF0ZSA6IGludGVycG9sYXRlWm9vbSkuc2NhbGVCeShnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uLCBvcHRpb25zPy5lYXNlLCAoKSA9PiByZXNvbHZlKHRydWUpKSwgZmFjdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRTY2FsZUV4dGVudChzY2FsZUV4dGVudCkge1xuICAgICAgICBkM1pvb21JbnN0YW5jZT8uc2NhbGVFeHRlbnQoc2NhbGVFeHRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KSB7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlPy50cmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0Q2xpY2tEaXN0YW5jZShkaXN0YW5jZSkge1xuICAgICAgICBjb25zdCB2YWxpZERpc3RhbmNlID0gIWlzTnVtZXJpYyhkaXN0YW5jZSkgfHwgZGlzdGFuY2UgPCAwID8gMCA6IGRpc3RhbmNlO1xuICAgICAgICBkM1pvb21JbnN0YW5jZT8uY2xpY2tEaXN0YW5jZSh2YWxpZERpc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkZXN0cm95LFxuICAgICAgICBzZXRWaWV3cG9ydCxcbiAgICAgICAgc2V0Vmlld3BvcnRDb25zdHJhaW5lZCxcbiAgICAgICAgZ2V0Vmlld3BvcnQsXG4gICAgICAgIHNjYWxlVG8sXG4gICAgICAgIHNjYWxlQnksXG4gICAgICAgIHNldFNjYWxlRXh0ZW50LFxuICAgICAgICBzZXRUcmFuc2xhdGVFeHRlbnQsXG4gICAgICAgIHN5bmNWaWV3cG9ydCxcbiAgICAgICAgc2V0Q2xpY2tEaXN0YW5jZSxcbiAgICB9O1xufVxuXG4vKipcbiAqIFVzZWQgdG8gZGV0ZXJtaW5lIHRoZSB2YXJpYW50IG9mIHRoZSByZXNpemUgY29udHJvbFxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlc2l6ZUNvbnRyb2xWYXJpYW50O1xuKGZ1bmN0aW9uIChSZXNpemVDb250cm9sVmFyaWFudCkge1xuICAgIFJlc2l6ZUNvbnRyb2xWYXJpYW50W1wiTGluZVwiXSA9IFwibGluZVwiO1xuICAgIFJlc2l6ZUNvbnRyb2xWYXJpYW50W1wiSGFuZGxlXCJdID0gXCJoYW5kbGVcIjtcbn0pKFJlc2l6ZUNvbnRyb2xWYXJpYW50IHx8IChSZXNpemVDb250cm9sVmFyaWFudCA9IHt9KSk7XG5jb25zdCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMgPSBbJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcsICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnXTtcbmNvbnN0IFhZX1JFU0laRVJfTElORV9QT1NJVElPTlMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuXG4vKipcbiAqIEdldCBhbGwgY29ubmVjdGluZyBlZGdlcyBmb3IgYSBnaXZlbiBzZXQgb2Ygbm9kZXNcbiAqIEBwYXJhbSB3aWR0aCAtIG5ldyB3aWR0aCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIHByZXZXaWR0aCAtIHByZXZpb3VzIHdpZHRoIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gaGVpZ2h0IC0gbmV3IGhlaWdodCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIHByZXZIZWlnaHQgLSBwcmV2aW91cyBoZWlnaHQgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBhZmZlY3RzWCAtIHdoZXRoZXIgdG8gaW52ZXJ0IHRoZSByZXNpemUgZGlyZWN0aW9uIGZvciB0aGUgeCBheGlzXG4gKiBAcGFyYW0gYWZmZWN0c1kgLSB3aGV0aGVyIHRvIGludmVydCB0aGUgcmVzaXplIGRpcmVjdGlvbiBmb3IgdGhlIHkgYXhpc1xuICogQHJldHVybnMgYXJyYXkgb2YgdHdvIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJlc2l6ZSBmb3IgZWFjaCBheGlzLCAwID0gbm8gY2hhbmdlLCAxID0gaW5jcmVhc2UsIC0xID0gZGVjcmVhc2VcbiAqL1xuZnVuY3Rpb24gZ2V0UmVzaXplRGlyZWN0aW9uKHsgd2lkdGgsIHByZXZXaWR0aCwgaGVpZ2h0LCBwcmV2SGVpZ2h0LCBhZmZlY3RzWCwgYWZmZWN0c1ksIH0pIHtcbiAgICBjb25zdCBkZWx0YVdpZHRoID0gd2lkdGggLSBwcmV2V2lkdGg7XG4gICAgY29uc3QgZGVsdGFIZWlnaHQgPSBoZWlnaHQgLSBwcmV2SGVpZ2h0O1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IFtkZWx0YVdpZHRoID4gMCA/IDEgOiBkZWx0YVdpZHRoIDwgMCA/IC0xIDogMCwgZGVsdGFIZWlnaHQgPiAwID8gMSA6IGRlbHRhSGVpZ2h0IDwgMCA/IC0xIDogMF07XG4gICAgaWYgKGRlbHRhV2lkdGggJiYgYWZmZWN0c1gpIHtcbiAgICAgICAgZGlyZWN0aW9uWzBdID0gZGlyZWN0aW9uWzBdICogLTE7XG4gICAgfVxuICAgIGlmIChkZWx0YUhlaWdodCAmJiBhZmZlY3RzWSkge1xuICAgICAgICBkaXJlY3Rpb25bMV0gPSBkaXJlY3Rpb25bMV0gKiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBjb250cm9sIHBvc2l0aW9uIHRoYXQgaXMgYmVpbmcgZHJhZ2dlZCB0byBkaW1lbnNpb25zIHRoYXQgYXJlIGJlaW5nIHJlc2l6ZWRcbiAqIEBwYXJhbSBjb250cm9sUG9zaXRpb24gLSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCB0aGF0IGlzIGJlaW5nIGRyYWdnZWRcbiAqIEByZXR1cm5zIGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCwgYWZmZWN0c1gsIGFmZmVjdHNZLFxuICovXG5mdW5jdGlvbiBnZXRDb250cm9sRGlyZWN0aW9uKGNvbnRyb2xQb3NpdGlvbikge1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygncmlnaHQnKSB8fCBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ2xlZnQnKTtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdib3R0b20nKSB8fCBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3RvcCcpO1xuICAgIGNvbnN0IGFmZmVjdHNYID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdsZWZ0Jyk7XG4gICAgY29uc3QgYWZmZWN0c1kgPSBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3RvcCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzSG9yaXpvbnRhbCxcbiAgICAgICAgaXNWZXJ0aWNhbCxcbiAgICAgICAgYWZmZWN0c1gsXG4gICAgICAgIGFmZmVjdHNZLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRMb3dlckV4dGVudENsYW1wKGxvd2VyRXh0ZW50LCBsb3dlckJvdW5kKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGxvd2VyQm91bmQgLSBsb3dlckV4dGVudCk7XG59XG5mdW5jdGlvbiBnZXRVcHBlckV4dGVudENsYW1wKHVwcGVyRXh0ZW50LCB1cHBlckJvdW5kKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHVwcGVyRXh0ZW50IC0gdXBwZXJCb3VuZCk7XG59XG5mdW5jdGlvbiBnZXRTaXplQ2xhbXAoc2l6ZSwgbWluU2l6ZSwgbWF4U2l6ZSkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBtaW5TaXplIC0gc2l6ZSwgc2l6ZSAtIG1heFNpemUpO1xufVxuZnVuY3Rpb24geG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/ICFiIDogYjtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyBuZXcgd2lkdGggJiBoZWlnaHQgYW5kIHggJiB5IG9mIG5vZGUgYWZ0ZXIgcmVzaXplIGJhc2VkIG9uIHBvaW50ZXIgcG9zaXRpb25cbiAqIEBkZXNjcmlwdGlvbiAtIEJ1Y2tsZSB1cCwgdGhpcyBpcyBhIGNodW5reSBvbmUuLi4gSWYgeW91IHdhbnQgdG8gZGV0ZXJtaW5lIHRoZSBuZXcgZGltZW5zaW9ucyBvZiBhIG5vZGUgYWZ0ZXIgYSByZXNpemUsXG4gKiB5b3UgaGF2ZSB0byBhY2NvdW50IGZvciBhbGwgcG9zc2libGUgcmVzdHJpY3Rpb25zOiBtaW4vbWF4IHdpZHRoL2hlaWdodCBvZiB0aGUgbm9kZSwgdGhlIG1heGltdW0gZXh0ZW50IHRoZSBub2RlIGlzIGFsbG93ZWRcbiAqIHRvIG1vdmUgaW4gKGluIHRoaXMgY2FzZTogcmVzaXplIGludG8pIGRldGVybWluZWQgYnkgdGhlIHBhcmVudCBub2RlLCB0aGUgbWluaW1hbCBleHRlbnQgZGV0ZXJtaW5lZCBieSBjaGlsZCBub2Rlc1xuICogd2l0aCBleHBhbmRQYXJlbnQgb3IgZXh0ZW50OiAncGFyZW50JyBzZXQgYW5kIG9oIHllYWgsIHRoZXNlIHRoaW5ncyBhbHNvIGhhdmUgdG8gd29yayB3aXRoIGtlZXBBc3BlY3RSYXRpbyFcbiAqIFRoZSB3YXkgdGhpcyBpcyBkb25lIGlzIGJ5IGRldGVybWluaW5nIGhvdyBtdWNoIGVhY2ggb2YgdGhlc2UgcmVzdHJpY3RpbmcgYWN0dWFsbHkgcmVzdHJpY3RzIHRoZSByZXNpemUgYW5kIHRoZW4gYXBwbHlpbmcgdGhlXG4gKiBzdHJvbmdlc3QgcmVzdHJpY3Rpb24uIEJlY2F1c2UgdGhlIHJlc2l6ZSBhZmZlY3RzIHgsIHkgYW5kIHdpZHRoLCBoZWlnaHQgYW5kIHdpZHRoLCBoZWlnaHQgb2YgYSBvcHBvc2luZyBzaWRlIHdpdGgga2VlcEFzcGVjdFJhdGlvLFxuICogdGhlIHJlc2l6ZSBhbW91bnQgaXMgYWx3YXlzIGtlcHQgaW4gZGlzdFggJiBkaXN0WSBhbW91bnQgKHRoZSBkaXN0YW5jZSBpbiBtb3VzZSBtb3ZlbWVudClcbiAqIEluc3RlYWQgb2YgY2xhbXBpbmcgZWFjaCB2YWx1ZSwgd2UgZmlyc3QgY2FsY3VsYXRlIHRoZSBiaWdnZXN0ICdjbGFtcCcgKGZvciB0aGUgbGFjayBvZiBhIGJldHRlciBuYW1lKSBhbmQgdGhlbiBhcHBseSBpdCB0byBhbGwgdmFsdWVzLlxuICogVG8gY29tcGxpY2F0ZSB0aGluZ3Mgbm9kZU9yaWdpbiBoYXMgdG8gYmUgdGFrZW4gaW50byBhY2NvdW50IGFzIHdlbGwuIFRoaXMgaXMgZG9uZSBieSBvZmZzZXR0aW5nIHRoZSBub2RlcyBhcyBpZiB0aGVpciBvcmlnaW4gaXMgWzAsIDBdLFxuICogdGhlbiBjYWxjdWxhdGluZyB0aGUgcmVzdHJpY3Rpb25zIGFzIHVzdWFsXG4gKiBAcGFyYW0gc3RhcnRWYWx1ZXMgLSBzdGFydGluZyB2YWx1ZXMgb2YgcmVzaXplXG4gKiBAcGFyYW0gY29udHJvbERpcmVjdGlvbiAtIGRpbWVuc2lvbnMgYWZmZWN0ZWQgYnkgdGhlIHJlc2l6ZVxuICogQHBhcmFtIHBvaW50ZXJQb3NpdGlvbiAtIHRoZSBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gY29ycmVjdGVkIGZvciBzbmFwcGluZ1xuICogQHBhcmFtIGJvdW5kYXJpZXMgLSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRpbWVuc2lvbnMgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBrZWVwQXNwZWN0UmF0aW8gLSBwcmV2ZW50IGNoYW5nZXMgb2YgYXNwcmVjdCByYXRpb1xuICogQHJldHVybnMgeCwgeSwgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgbm9kZSBhZnRlciByZXNpemVcbiAqL1xuZnVuY3Rpb24gZ2V0RGltZW5zaW9uc0FmdGVyUmVzaXplKHN0YXJ0VmFsdWVzLCBjb250cm9sRGlyZWN0aW9uLCBwb2ludGVyUG9zaXRpb24sIGJvdW5kYXJpZXMsIGtlZXBBc3BlY3RSYXRpbywgbm9kZU9yaWdpbiwgZXh0ZW50LCBjaGlsZEV4dGVudCkge1xuICAgIGxldCB7IGFmZmVjdHNYLCBhZmZlY3RzWSB9ID0gY29udHJvbERpcmVjdGlvbjtcbiAgICBjb25zdCB7IGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCB9ID0gY29udHJvbERpcmVjdGlvbjtcbiAgICBjb25zdCBpc0RpYWdvbmFsID0gaXNIb3Jpem9udGFsICYmIGlzVmVydGljYWw7XG4gICAgY29uc3QgeyB4U25hcHBlZCwgeVNuYXBwZWQgfSA9IHBvaW50ZXJQb3NpdGlvbjtcbiAgICBjb25zdCB7IG1pbldpZHRoLCBtYXhXaWR0aCwgbWluSGVpZ2h0LCBtYXhIZWlnaHQgfSA9IGJvdW5kYXJpZXM7XG4gICAgY29uc3QgeyB4OiBzdGFydFgsIHk6IHN0YXJ0WSwgd2lkdGg6IHN0YXJ0V2lkdGgsIGhlaWdodDogc3RhcnRIZWlnaHQsIGFzcGVjdFJhdGlvIH0gPSBzdGFydFZhbHVlcztcbiAgICBsZXQgZGlzdFggPSBNYXRoLmZsb29yKGlzSG9yaXpvbnRhbCA/IHhTbmFwcGVkIC0gc3RhcnRWYWx1ZXMucG9pbnRlclggOiAwKTtcbiAgICBsZXQgZGlzdFkgPSBNYXRoLmZsb29yKGlzVmVydGljYWwgPyB5U25hcHBlZCAtIHN0YXJ0VmFsdWVzLnBvaW50ZXJZIDogMCk7XG4gICAgY29uc3QgbmV3V2lkdGggPSBzdGFydFdpZHRoICsgKGFmZmVjdHNYID8gLWRpc3RYIDogZGlzdFgpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHN0YXJ0SGVpZ2h0ICsgKGFmZmVjdHNZID8gLWRpc3RZIDogZGlzdFkpO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFggPSAtbm9kZU9yaWdpblswXSAqIHN0YXJ0V2lkdGg7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WSA9IC1ub2RlT3JpZ2luWzFdICogc3RhcnRIZWlnaHQ7XG4gICAgLy8gQ2hlY2sgaWYgbWF4V2lkdGgsIG1pbldXaWR0aCwgbWF4SGVpZ2h0LCBtaW5IZWlnaHQgYXJlIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBsZXQgY2xhbXBYID0gZ2V0U2l6ZUNsYW1wKG5ld1dpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgpO1xuICAgIGxldCBjbGFtcFkgPSBnZXRTaXplQ2xhbXAobmV3SGVpZ2h0LCBtaW5IZWlnaHQsIG1heEhlaWdodCk7XG4gICAgLy8gQ2hlY2sgaWYgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgIGxldCB4RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBsZXQgeUV4dGVudENsYW1wID0gMDtcbiAgICAgICAgaWYgKGFmZmVjdHNYICYmIGRpc3RYIDwgMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyBkaXN0WCArIG9yaWdpbk9mZnNldFgsIGV4dGVudFswXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNYICYmIGRpc3RYID4gMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdXaWR0aCArIG9yaWdpbk9mZnNldFgsIGV4dGVudFsxXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmZmVjdHNZICYmIGRpc3RZIDwgMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBkaXN0WSArIG9yaWdpbk9mZnNldFksIGV4dGVudFswXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNZICYmIGRpc3RZID4gMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdIZWlnaHQgKyBvcmlnaW5PZmZzZXRZLCBleHRlbnRbMV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgeEV4dGVudENsYW1wKTtcbiAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCB5RXh0ZW50Q2xhbXApO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgY2hpbGQgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgbGV0IHhFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgIGxldCB5RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBpZiAoYWZmZWN0c1ggJiYgZGlzdFggPiAwKSB7XG4gICAgICAgICAgICB4RXh0ZW50Q2xhbXAgPSBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIGRpc3RYLCBjaGlsZEV4dGVudFswXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNYICYmIGRpc3RYIDwgMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdXaWR0aCwgY2hpbGRFeHRlbnRbMV1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZmZlY3RzWSAmJiBkaXN0WSA+IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgZGlzdFksIGNoaWxkRXh0ZW50WzBdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYWZmZWN0c1kgJiYgZGlzdFkgPCAwKSB7XG4gICAgICAgICAgICB5RXh0ZW50Q2xhbXAgPSBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WSArIG5ld0hlaWdodCwgY2hpbGRFeHRlbnRbMV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgeEV4dGVudENsYW1wKTtcbiAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCB5RXh0ZW50Q2xhbXApO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgYXNwZWN0IHJhdGlvIHJlc2l6aW5nIG9mIHRoZSBvdGhlciBzaWRlIGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBpZiAoa2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBtYXggZGltZW5zaW9ucyBtaWdodCBiZSByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgICAgICAgICBjb25zdCBhc3BlY3RIZWlnaHRDbGFtcCA9IGdldFNpemVDbGFtcChuZXdXaWR0aCAvIGFzcGVjdFJhdGlvLCBtaW5IZWlnaHQsIG1heEhlaWdodCkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgYXNwZWN0SGVpZ2h0Q2xhbXApO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWCAmJiAhYWZmZWN0c1kgJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyBvcmlnaW5PZmZzZXRZICsgbmV3V2lkdGggLyBhc3BlY3RSYXRpbywgZXh0ZW50WzFdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBvcmlnaW5PZmZzZXRZICsgKGFmZmVjdHNYID8gZGlzdFggOiAtZGlzdFgpIC8gYXNwZWN0UmF0aW8sIGV4dGVudFswXVsxXSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjaGlsZCBleHRlbnQgaXMgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWCAmJiAhYWZmZWN0c1kgJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPSBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WSArIG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzFdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyAoYWZmZWN0c1ggPyBkaXN0WCA6IC1kaXN0WCkgLyBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMF1bMV0pICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgYXNwZWN0RXh0ZW50Q2xhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERvIHRoZSBzYW1lIHRoaW5nIGZvciB2ZXJ0aWNhbCByZXNpemluZ1xuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgY29uc3QgYXNwZWN0V2lkdGhDbGFtcCA9IGdldFNpemVDbGFtcChuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbywgbWluV2lkdGgsIG1heFdpZHRoKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RXaWR0aENsYW1wKTtcbiAgICAgICAgICAgIGlmIChleHRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXNwZWN0RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgoIWFmZmVjdHNYICYmICFhZmZlY3RzWSkgfHwgKGFmZmVjdHNZICYmICFhZmZlY3RzWCAmJiBpc0RpYWdvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIG5ld0hlaWdodCAqIGFzcGVjdFJhdGlvICsgb3JpZ2luT2Zmc2V0WCwgZXh0ZW50WzFdWzBdKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyAoYWZmZWN0c1kgPyBkaXN0WSA6IC1kaXN0WSkgKiBhc3BlY3RSYXRpbyArIG9yaWdpbk9mZnNldFgsIGV4dGVudFswXVswXSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFkgPSBNYXRoLm1heChjbGFtcFksIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZEV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1kgJiYgIWFmZmVjdHNYICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMV1bMF0pIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIChhZmZlY3RzWSA/IGRpc3RZIDogLWRpc3RZKSAqIGFzcGVjdFJhdGlvLCBjaGlsZEV4dGVudFswXVswXSkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzdFkgPSBkaXN0WSArIChkaXN0WSA8IDAgPyBjbGFtcFkgOiAtY2xhbXBZKTtcbiAgICBkaXN0WCA9IGRpc3RYICsgKGRpc3RYIDwgMCA/IGNsYW1wWCA6IC1jbGFtcFgpO1xuICAgIGlmIChrZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgaWYgKGlzRGlhZ29uYWwpIHtcbiAgICAgICAgICAgIGlmIChuZXdXaWR0aCA+IG5ld0hlaWdodCAqIGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgZGlzdFkgPSAoeG9yKGFmZmVjdHNYLCBhZmZlY3RzWSkgPyAtZGlzdFggOiBkaXN0WCkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc3RYID0gKHhvcihhZmZlY3RzWCwgYWZmZWN0c1kpID8gLWRpc3RZIDogZGlzdFkpICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgZGlzdFkgPSBkaXN0WCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIGFmZmVjdHNZID0gYWZmZWN0c1g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXN0WCA9IGRpc3RZICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgYWZmZWN0c1ggPSBhZmZlY3RzWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB4ID0gYWZmZWN0c1ggPyBzdGFydFggKyBkaXN0WCA6IHN0YXJ0WDtcbiAgICBjb25zdCB5ID0gYWZmZWN0c1kgPyBzdGFydFkgKyBkaXN0WSA6IHN0YXJ0WTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogc3RhcnRXaWR0aCArIChhZmZlY3RzWCA/IC1kaXN0WCA6IGRpc3RYKSxcbiAgICAgICAgaGVpZ2h0OiBzdGFydEhlaWdodCArIChhZmZlY3RzWSA/IC1kaXN0WSA6IGRpc3RZKSxcbiAgICAgICAgeDogbm9kZU9yaWdpblswXSAqIGRpc3RYICogKCFhZmZlY3RzWCA/IDEgOiAtMSkgKyB4LFxuICAgICAgICB5OiBub2RlT3JpZ2luWzFdICogZGlzdFkgKiAoIWFmZmVjdHNZID8gMSA6IC0xKSArIHksXG4gICAgfTtcbn1cblxuY29uc3QgaW5pdFByZXZWYWx1ZXMgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHg6IDAsIHk6IDAgfTtcbmNvbnN0IGluaXRTdGFydFZhbHVlcyA9IHtcbiAgICAuLi5pbml0UHJldlZhbHVlcyxcbiAgICBwb2ludGVyWDogMCxcbiAgICBwb2ludGVyWTogMCxcbiAgICBhc3BlY3RSYXRpbzogMSxcbn07XG5mdW5jdGlvbiBub2RlVG9QYXJlbnRFeHRlbnQobm9kZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgW25vZGUubWVhc3VyZWQud2lkdGgsIG5vZGUubWVhc3VyZWQuaGVpZ2h0XSxcbiAgICBdO1xufVxuZnVuY3Rpb24gbm9kZVRvQ2hpbGRFeHRlbnQoY2hpbGQsIHBhcmVudCwgbm9kZU9yaWdpbikge1xuICAgIGNvbnN0IHggPSBwYXJlbnQucG9zaXRpb24ueCArIGNoaWxkLnBvc2l0aW9uLng7XG4gICAgY29uc3QgeSA9IHBhcmVudC5wb3NpdGlvbi55ICsgY2hpbGQucG9zaXRpb24ueTtcbiAgICBjb25zdCB3aWR0aCA9IGNoaWxkLm1lYXN1cmVkLndpZHRoID8/IDA7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2hpbGQubWVhc3VyZWQuaGVpZ2h0ID8/IDA7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WCA9IG5vZGVPcmlnaW5bMF0gKiB3aWR0aDtcbiAgICBjb25zdCBvcmlnaW5PZmZzZXRZID0gbm9kZU9yaWdpblsxXSAqIGhlaWdodDtcbiAgICByZXR1cm4gW1xuICAgICAgICBbeCAtIG9yaWdpbk9mZnNldFgsIHkgLSBvcmlnaW5PZmZzZXRZXSxcbiAgICAgICAgW3ggKyB3aWR0aCAtIG9yaWdpbk9mZnNldFgsIHkgKyBoZWlnaHQgLSBvcmlnaW5PZmZzZXRZXSxcbiAgICBdO1xufVxuZnVuY3Rpb24gWFlSZXNpemVyKHsgZG9tTm9kZSwgbm9kZUlkLCBnZXRTdG9yZUl0ZW1zLCBvbkNoYW5nZSwgb25FbmQgfSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKTtcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyBjb250cm9sUG9zaXRpb24sIGJvdW5kYXJpZXMsIGtlZXBBc3BlY3RSYXRpbywgcmVzaXplRGlyZWN0aW9uLCBvblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZSwgb25SZXNpemVFbmQsIHNob3VsZFJlc2l6ZSwgfSkge1xuICAgICAgICBsZXQgcHJldlZhbHVlcyA9IHsgLi4uaW5pdFByZXZWYWx1ZXMgfTtcbiAgICAgICAgbGV0IHN0YXJ0VmFsdWVzID0geyAuLi5pbml0U3RhcnRWYWx1ZXMgfTtcbiAgICAgICAgY29uc3QgY29udHJvbERpcmVjdGlvbiA9IGdldENvbnRyb2xEaXJlY3Rpb24oY29udHJvbFBvc2l0aW9uKTtcbiAgICAgICAgbGV0IG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb250YWluZXJCb3VuZHMgPSBudWxsO1xuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IHVuZGVmaW5lZDsgLy8gTmVlZGVkIHRvIGZpeCBleHBhbmRQYXJlbnRcbiAgICAgICAgbGV0IHBhcmVudEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNoaWxkRXh0ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gdHJpZ2dlciBvblJlc2l6ZUVuZCBpZiBvblJlc2l6ZSB3YXMgYWN0dWFsbHkgY2FsbGVkXG4gICAgICAgIGxldCByZXNpemVEZXRlY3RlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBkcmFnSGFuZGxlciA9IGRyYWcoKVxuICAgICAgICAgICAgLm9uKCdzdGFydCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luLCBwYW5lRG9tTm9kZSB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXJCb3VuZHMgPSBwYW5lRG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgPz8gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHsgeFNuYXBwZWQsIHlTbmFwcGVkIH0gPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgc25hcEdyaWQsXG4gICAgICAgICAgICAgICAgc25hcFRvR3JpZCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJCb3VuZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByZXZWYWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IG5vZGUubWVhc3VyZWQud2lkdGggPz8gMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG5vZGUubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgeDogbm9kZS5wb3NpdGlvbi54ID8/IDAsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5wb3NpdGlvbi55ID8/IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgLi4ucHJldlZhbHVlcyxcbiAgICAgICAgICAgICAgICBwb2ludGVyWDogeFNuYXBwZWQsXG4gICAgICAgICAgICAgICAgcG9pbnRlclk6IHlTbmFwcGVkLFxuICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvOiBwcmV2VmFsdWVzLndpZHRoIC8gcHJldlZhbHVlcy5oZWlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudElkICYmIChub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcgfHwgbm9kZS5leHBhbmRQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpO1xuICAgICAgICAgICAgICAgIHBhcmVudEV4dGVudCA9IHBhcmVudE5vZGUgJiYgbm9kZS5leHRlbnQgPT09ICdwYXJlbnQnID8gbm9kZVRvUGFyZW50RXh0ZW50KHBhcmVudE5vZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIENvbGxlY3QgYWxsIGNoaWxkIG5vZGVzIHRvIGNvcnJlY3QgdGhlaXIgcmVsYXRpdmUgcG9zaXRpb25zIHdoZW4gdG9wL2xlZnQgY2hhbmdlc1xuICAgICAgICAgICAgICogRGV0ZXJtaW5lIGxhcmdlc3QgbWluaW1hbCBleHRlbnQgdGhlIHBhcmVudCBub2RlIGlzIGFsbG93ZWQgdG8gcmVzaXplIHRvXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGNoaWxkRXh0ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbY2hpbGRJZCwgY2hpbGRdIG9mIG5vZGVMb29rdXApIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50SWQgPT09IG5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNoaWxkSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyAuLi5jaGlsZC5wb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW50OiBjaGlsZC5leHRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZXh0ZW50ID09PSAncGFyZW50JyB8fCBjaGlsZC5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IG5vZGVUb0NoaWxkRXh0ZW50KGNoaWxkLCBub2RlLCBjaGlsZC5vcmlnaW4gPz8gbm9kZU9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW01hdGgubWluKGV4dGVudFswXVswXSwgY2hpbGRFeHRlbnRbMF1bMF0pLCBNYXRoLm1pbihleHRlbnRbMF1bMV0sIGNoaWxkRXh0ZW50WzBdWzFdKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtNYXRoLm1heChleHRlbnRbMV1bMF0sIGNoaWxkRXh0ZW50WzFdWzBdKSwgTWF0aC5tYXgoZXh0ZW50WzFdWzFdLCBjaGlsZEV4dGVudFsxXVsxXSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEV4dGVudCA9IGV4dGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uUmVzaXplU3RhcnQ/LihldmVudCwgeyAuLi5wcmV2VmFsdWVzIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdkcmFnJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbiB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRlclBvc2l0aW9uID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgICAgICAgIHNuYXBUb0dyaWQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyQm91bmRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgeDogcHJldlgsIHk6IHByZXZZLCB3aWR0aDogcHJldldpZHRoLCBoZWlnaHQ6IHByZXZIZWlnaHQgfSA9IHByZXZWYWx1ZXM7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVPcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBzdG9yZU5vZGVPcmlnaW47XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHgsIHkgfSA9IGdldERpbWVuc2lvbnNBZnRlclJlc2l6ZShzdGFydFZhbHVlcywgY29udHJvbERpcmVjdGlvbiwgcG9pbnRlclBvc2l0aW9uLCBib3VuZGFyaWVzLCBrZWVwQXNwZWN0UmF0aW8sIG5vZGVPcmlnaW4sIHBhcmVudEV4dGVudCwgY2hpbGRFeHRlbnQpO1xuICAgICAgICAgICAgY29uc3QgaXNXaWR0aENoYW5nZSA9IHdpZHRoICE9PSBwcmV2V2lkdGg7XG4gICAgICAgICAgICBjb25zdCBpc0hlaWdodENoYW5nZSA9IGhlaWdodCAhPT0gcHJldkhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGlzWFBvc0NoYW5nZSA9IHggIT09IHByZXZYICYmIGlzV2lkdGhDaGFuZ2U7XG4gICAgICAgICAgICBjb25zdCBpc1lQb3NDaGFuZ2UgPSB5ICE9PSBwcmV2WSAmJiBpc0hlaWdodENoYW5nZTtcbiAgICAgICAgICAgIGlmICghaXNYUG9zQ2hhbmdlICYmICFpc1lQb3NDaGFuZ2UgJiYgIWlzV2lkdGhDaGFuZ2UgJiYgIWlzSGVpZ2h0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzWFBvc0NoYW5nZSB8fCBpc1lQb3NDaGFuZ2UgfHwgbm9kZU9yaWdpblswXSA9PT0gMSB8fCBub2RlT3JpZ2luWzFdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnggPSBpc1hQb3NDaGFuZ2UgPyB4IDogcHJldlZhbHVlcy54O1xuICAgICAgICAgICAgICAgIGNoYW5nZS55ID0gaXNZUG9zQ2hhbmdlID8geSA6IHByZXZWYWx1ZXMueTtcbiAgICAgICAgICAgICAgICBwcmV2VmFsdWVzLnggPSBjaGFuZ2UueDtcbiAgICAgICAgICAgICAgICBwcmV2VmFsdWVzLnkgPSBjaGFuZ2UueTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHdoZW4gdG9wL2xlZnQgY2hhbmdlcywgY29ycmVjdCB0aGUgcmVsYXRpdmUgcG9zaXRpb25zIG9mIGNoaWxkIG5vZGVzXG4gICAgICAgICAgICAgICAgICogc28gdGhhdCB0aGV5IHN0YXkgaW4gdGhlIHNhbWUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhDaGFuZ2UgPSB4IC0gcHJldlg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHlDaGFuZ2UgPSB5IC0gcHJldlk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGROb2RlIG9mIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjaGlsZE5vZGUucG9zaXRpb24ueCAtIHhDaGFuZ2UgKyBub2RlT3JpZ2luWzBdICogKHdpZHRoIC0gcHJldldpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBjaGlsZE5vZGUucG9zaXRpb24ueSAtIHlDaGFuZ2UgKyBub2RlT3JpZ2luWzFdICogKGhlaWdodCAtIHByZXZIZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkQ2hhbmdlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNXaWR0aENoYW5nZSB8fCBpc0hlaWdodENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZS53aWR0aCA9XG4gICAgICAgICAgICAgICAgICAgIGlzV2lkdGhDaGFuZ2UgJiYgKCFyZXNpemVEaXJlY3Rpb24gfHwgcmVzaXplRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpID8gd2lkdGggOiBwcmV2VmFsdWVzLndpZHRoO1xuICAgICAgICAgICAgICAgIGNoYW5nZS5oZWlnaHQgPVxuICAgICAgICAgICAgICAgICAgICBpc0hlaWdodENoYW5nZSAmJiAoIXJlc2l6ZURpcmVjdGlvbiB8fCByZXNpemVEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpID8gaGVpZ2h0IDogcHJldlZhbHVlcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy53aWR0aCA9IGNoYW5nZS53aWR0aDtcbiAgICAgICAgICAgICAgICBwcmV2VmFsdWVzLmhlaWdodCA9IGNoYW5nZS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXggZXhwYW5kUGFyZW50IHdoZW4gcmVzaXppbmcgZnJvbSB0b3AvbGVmdFxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgbm9kZS5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4TGltaXQgPSBub2RlT3JpZ2luWzBdICogKGNoYW5nZS53aWR0aCA/PyAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnggJiYgY2hhbmdlLnggPCB4TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlZhbHVlcy54ID0geExpbWl0O1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlcy54ID0gc3RhcnRWYWx1ZXMueCAtIChjaGFuZ2UueCAtIHhMaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHlMaW1pdCA9IG5vZGVPcmlnaW5bMV0gKiAoY2hhbmdlLmhlaWdodCA/PyAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnkgJiYgY2hhbmdlLnkgPCB5TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlZhbHVlcy55ID0geUxpbWl0O1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlcy55ID0gc3RhcnRWYWx1ZXMueSAtIChjaGFuZ2UueSAtIHlMaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gZ2V0UmVzaXplRGlyZWN0aW9uKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcHJldlZhbHVlcy53aWR0aCxcbiAgICAgICAgICAgICAgICBwcmV2V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwcmV2VmFsdWVzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBwcmV2SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGFmZmVjdHNYOiBjb250cm9sRGlyZWN0aW9uLmFmZmVjdHNYLFxuICAgICAgICAgICAgICAgIGFmZmVjdHNZOiBjb250cm9sRGlyZWN0aW9uLmFmZmVjdHNZLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0VmFsdWVzID0geyAuLi5wcmV2VmFsdWVzLCBkaXJlY3Rpb24gfTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxSZXNpemUgPSBzaG91bGRSZXNpemU/LihldmVudCwgbmV4dFZhbHVlcyk7XG4gICAgICAgICAgICBpZiAoY2FsbFJlc2l6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNpemVEZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBvblJlc2l6ZT8uKGV2ZW50LCBuZXh0VmFsdWVzKTtcbiAgICAgICAgICAgIG9uQ2hhbmdlKGNoYW5nZSwgY2hpbGRDaGFuZ2VzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc2l6ZURldGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25SZXNpemVFbmQ/LihldmVudCwgeyAuLi5wcmV2VmFsdWVzIH0pO1xuICAgICAgICAgICAgb25FbmQ/Lih7IC4uLnByZXZWYWx1ZXMgfSk7XG4gICAgICAgICAgICByZXNpemVEZXRlY3RlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZWN0aW9uLmNhbGwoZHJhZ0hhbmRsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBzZWxlY3Rpb24ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBDb25uZWN0aW9uTGluZVR5cGUsIENvbm5lY3Rpb25Nb2RlLCBNYXJrZXJUeXBlLCBQYW5PblNjcm9sbE1vZGUsIFBvc2l0aW9uLCBSZXNpemVDb250cm9sVmFyaWFudCwgU2VsZWN0aW9uTW9kZSwgWFlEcmFnLCBYWUhhbmRsZSwgWFlNaW5pbWFwLCBYWVBhblpvb20sIFhZUmVzaXplciwgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLCBYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TLCBhZGRFZGdlLCBhZG9wdFVzZXJOb2RlcywgYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCwgYXJlU2V0c0VxdWFsLCBib3hUb1JlY3QsIGNhbGNBdXRvUGFuLCBjYWxjdWxhdGVOb2RlUG9zaXRpb24sIGNsYW1wLCBjbGFtcFBvc2l0aW9uLCBjbGFtcFBvc2l0aW9uVG9QYXJlbnQsIGNyZWF0ZU1hcmtlcklkcywgZGVmYXVsdEFyaWFMYWJlbENvbmZpZywgZGV2V2FybiwgZWxlbWVudFNlbGVjdGlvbktleXMsIGVycm9yTWVzc2FnZXMsIGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbiwgZml0Vmlld3BvcnQsIGdldEJlemllckVkZ2VDZW50ZXIsIGdldEJlemllclBhdGgsIGdldEJvdW5kc09mQm94ZXMsIGdldEJvdW5kc09mUmVjdHMsIGdldENvbm5lY3RlZEVkZ2VzLCBnZXRDb25uZWN0aW9uU3RhdHVzLCBnZXREaW1lbnNpb25zLCBnZXRFZGdlQ2VudGVyLCBnZXRFZGdlUG9zaXRpb24sIGdldEVsZW1lbnRzVG9SZW1vdmUsIGdldEVsZXZhdGVkRWRnZVpJbmRleCwgZ2V0RXZlbnRQb3NpdGlvbiwgZ2V0SGFuZGxlQm91bmRzLCBnZXRIYW5kbGVQb3NpdGlvbiwgZ2V0SG9zdEZvckVsZW1lbnQsIGdldEluY29tZXJzLCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzLCBnZXRNYXJrZXJJZCwgZ2V0Tm9kZURpbWVuc2lvbnMsIGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4sIGdldE5vZGVUb29sYmFyVHJhbnNmb3JtLCBnZXROb2Rlc0JvdW5kcywgZ2V0Tm9kZXNJbnNpZGUsIGdldE91dGdvZXJzLCBnZXRPdmVybGFwcGluZ0FyZWEsIGdldFBvaW50ZXJQb3NpdGlvbiwgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UsIGhhbmRsZUV4cGFuZFBhcmVudCwgaW5maW5pdGVFeHRlbnQsIGluaXRpYWxDb25uZWN0aW9uLCBpc0Nvb3JkaW5hdGVFeHRlbnQsIGlzRWRnZUJhc2UsIGlzRWRnZVZpc2libGUsIGlzSW5wdXRET01Ob2RlLCBpc0ludGVybmFsTm9kZUJhc2UsIGlzTWFjT3MsIGlzTW91c2VFdmVudCwgaXNOb2RlQmFzZSwgaXNOdW1lcmljLCBpc1JlY3RPYmplY3QsIG1lcmdlQXJpYUxhYmVsQ29uZmlnLCBub2RlSGFzRGltZW5zaW9ucywgbm9kZVRvQm94LCBub2RlVG9SZWN0LCBvcHBvc2l0ZVBvc2l0aW9uLCBwYW5CeSwgcG9pbnRUb1JlbmRlcmVyUG9pbnQsIHJlY29ubmVjdEVkZ2UsIHJlY3RUb0JveCwgcmVuZGVyZXJQb2ludFRvUG9pbnQsIHNoYWxsb3dOb2RlRGF0YSwgc25hcFBvc2l0aW9uLCB1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucywgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cCwgdXBkYXRlTm9kZUludGVybmFscywgd2l0aFJlc29sdmVycyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/dist/style.css":
/*!***************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/style.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"d393e6a432f7\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2xheS1pdC1yaWdodC8uL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L2Rpc3Qvc3R5bGUuY3NzP2RlNDAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkMzkzZTZhNDMyZjdcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/style.css\n");

/***/ })

};
;