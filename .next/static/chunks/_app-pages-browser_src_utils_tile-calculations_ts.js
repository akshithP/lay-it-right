"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_utils_tile-calculations_ts"],{

/***/ "(app-pages-browser)/./src/utils/tile-calculations.ts":
/*!****************************************!*\
  !*** ./src/utils/tile-calculations.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateGroutArea: function() { return /* binding */ calculateGroutArea; },\n/* harmony export */   calculateLayoutArea: function() { return /* binding */ calculateLayoutArea; },\n/* harmony export */   calculatePolygonArea: function() { return /* binding */ calculatePolygonArea; },\n/* harmony export */   calculateProject: function() { return /* binding */ calculateProject; },\n/* harmony export */   calculateTilesByPattern: function() { return /* binding */ calculateTilesByPattern; },\n/* harmony export */   estimateProjectCost: function() { return /* binding */ estimateProjectCost; }\n/* harmony export */ });\n/* harmony import */ var _unit_conversions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unit-conversions */ \"(app-pages-browser)/./src/utils/unit-conversions.ts\");\n\n/**\r\n * Calculate total area for different layout shapes\r\n */ function calculateLayoutArea(project) {\n    const { layout } = project;\n    if (!layout) return 0;\n    switch(layout.shape){\n        case \"rectangle\":\n        case \"square\":\n            return layout.dimensions.length * layout.dimensions.width;\n        case \"l-shape\":\n            // Simplified L-shape calculation - assume it's two rectangles\n            // In a real app, you'd have more detailed L-shape configuration\n            return layout.dimensions.length * layout.dimensions.width * 0.75;\n        case \"u-shape\":\n            // Simplified U-shape calculation\n            return layout.dimensions.length * layout.dimensions.width * 0.8;\n        case \"t-shape\":\n            // Simplified T-shape calculation\n            return layout.dimensions.length * layout.dimensions.width * 0.7;\n        case \"custom\":\n            var _layout_customLayout;\n            if ((_layout_customLayout = layout.customLayout) === null || _layout_customLayout === void 0 ? void 0 : _layout_customLayout.points) {\n                return calculatePolygonArea(layout.customLayout.points);\n            }\n            return 0;\n        default:\n            return 0;\n    }\n}\n/**\r\n * Calculate area of a polygon using the shoelace formula\r\n */ function calculatePolygonArea(points) {\n    if (points.length < 3) return 0;\n    let area = 0;\n    const n = points.length;\n    for(let i = 0; i < n; i++){\n        const j = (i + 1) % n;\n        area += points[i].x * points[j].y;\n        area -= points[j].x * points[i].y;\n    }\n    return Math.abs(area) / 2;\n}\n/**\r\n * Calculate number of tiles needed based on pattern\r\n */ function calculateTilesByPattern(roomArea, tileLength, tileWidth, groutWidth, pattern, unit) {\n    // Normalize all measurements to mm for consistent calculation\n    const roomAreaMm = (0,_unit_conversions__WEBPACK_IMPORTED_MODULE_0__.normalizeToMm)(roomArea, unit + \"\\xb2\");\n    const tileLengthMm = (0,_unit_conversions__WEBPACK_IMPORTED_MODULE_0__.normalizeToMm)(tileLength, unit);\n    const tileWidthMm = (0,_unit_conversions__WEBPACK_IMPORTED_MODULE_0__.normalizeToMm)(tileWidth, unit);\n    const groutWidthMm = (0,_unit_conversions__WEBPACK_IMPORTED_MODULE_0__.normalizeToMm)(groutWidth, unit);\n    // Calculate effective tile size including grout\n    const effectiveTileLength = tileLengthMm + groutWidthMm;\n    const effectiveTileWidth = tileWidthMm + groutWidthMm;\n    const effectiveTileArea = effectiveTileLength * effectiveTileWidth;\n    // Base calculation\n    let baseTilesNeeded = Math.ceil(roomAreaMm / effectiveTileArea);\n    // Pattern-specific adjustments\n    let wastePercentage;\n    let cutTileRatio;\n    switch(pattern){\n        case \"grid\":\n            wastePercentage = 5 // 5% waste for grid pattern\n            ;\n            cutTileRatio = 0.15 // 15% of tiles will need cutting\n            ;\n            break;\n        case \"brick\":\n            wastePercentage = 8 // 8% waste for brick/running bond\n            ;\n            cutTileRatio = 0.25 // 25% of tiles will need cutting\n            ;\n            baseTilesNeeded *= 1.05 // Slight increase for brick pattern\n            ;\n            break;\n        case \"herringbone\":\n            wastePercentage = 15 // 15% waste for herringbone (most complex)\n            ;\n            cutTileRatio = 0.4 // 40% of tiles will need cutting\n            ;\n            baseTilesNeeded *= 1.15 // Significant increase for herringbone complexity\n            ;\n            break;\n        default:\n            wastePercentage = 5;\n            cutTileRatio = 0.15;\n    }\n    const totalTiles = Math.ceil(baseTilesNeeded * (1 + wastePercentage / 100));\n    const cutTiles = Math.ceil(totalTiles * cutTileRatio);\n    const fullTiles = totalTiles - cutTiles;\n    return {\n        totalTiles,\n        fullTiles,\n        cutTiles,\n        wastePercentage\n    };\n}\n/**\r\n * Calculate grout area\r\n */ function calculateGroutArea(roomArea, tileLength, tileWidth, groutWidth, totalTiles, unit) {\n    // Normalize measurements\n    const tileLengthMm = (0,_unit_conversions__WEBPACK_IMPORTED_MODULE_0__.normalizeToMm)(tileLength, unit);\n    const tileWidthMm = (0,_unit_conversions__WEBPACK_IMPORTED_MODULE_0__.normalizeToMm)(tileWidth, unit);\n    const groutWidthMm = (0,_unit_conversions__WEBPACK_IMPORTED_MODULE_0__.normalizeToMm)(groutWidth, unit);\n    // Calculate tile area vs total area\n    const singleTileArea = tileLengthMm * tileWidthMm;\n    const totalTileArea = singleTileArea * totalTiles;\n    // Convert room area to mmÂ²\n    const roomAreaMm = (0,_unit_conversions__WEBPACK_IMPORTED_MODULE_0__.normalizeToMm)(roomArea, unit + \"\\xb2\");\n    // Grout area is the difference plus additional for joint intersections\n    const baseGroutArea = roomAreaMm - totalTileArea;\n    const jointIntersectionArea = totalTiles * (groutWidthMm * groutWidthMm);\n    return Math.max(0, baseGroutArea + jointIntersectionArea);\n}\n/**\r\n * Main calculation function for complete project\r\n */ function calculateProject(project) {\n    const { layout, tile } = project;\n    if (!(layout === null || layout === void 0 ? void 0 : layout.dimensions) || !tile) return null;\n    // Calculate total area\n    const totalArea = calculateLayoutArea(project);\n    if (totalArea <= 0) return null;\n    // Calculate individual tile area\n    const tileArea = tile.length / 1000 * (tile.width / 1000 // Convert mm to m for display\n    );\n    // Calculate tiles needed by pattern\n    const { totalTiles, fullTiles, cutTiles, wastePercentage } = calculateTilesByPattern(totalArea, tile.length, tile.width, tile.groutWidth, layout.pattern, layout.dimensions.unit);\n    // Calculate grout area\n    const groutArea = calculateGroutArea(totalArea, tile.length, tile.width, tile.groutWidth, totalTiles, layout.dimensions.unit);\n    // Calculate coverage percentage\n    const actualTileArea = fullTiles * tileArea;\n    const coverage = totalArea > 0 ? actualTileArea / totalArea * 100 : 0;\n    return {\n        totalArea: Number(totalArea.toFixed(2)),\n        tileArea: Number(tileArea.toFixed(6)),\n        totalTiles,\n        fullTiles,\n        cutTiles,\n        wastePercentage,\n        groutArea: Number((0,_unit_conversions__WEBPACK_IMPORTED_MODULE_0__.convertFromMm)(groutArea, layout.dimensions.unit).toFixed(2)),\n        coverage: Number(coverage.toFixed(1))\n    };\n}\n/**\r\n * Estimate project cost (basic calculation)\r\n */ function estimateProjectCost(totalTiles, tilePrice, groutArea) {\n    let groutPricePerSqM = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10;\n    const tileCost = totalTiles * tilePrice;\n    const groutCost = groutArea * groutPricePerSqM;\n    const totalCost = tileCost + groutCost;\n    return {\n        tileCost: Number(tileCost.toFixed(2)),\n        groutCost: Number(groutCost.toFixed(2)),\n        totalCost: Number(totalCost.toFixed(2))\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy90aWxlLWNhbGN1bGF0aW9ucy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ2lFO0FBYWpFOztDQUVDLEdBQ00sU0FBU0Usb0JBQW9CQyxPQUFnQjtJQUNsRCxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHRDtJQUVuQixJQUFJLENBQUNDLFFBQVEsT0FBTztJQUVwQixPQUFRQSxPQUFPQyxLQUFLO1FBQ2xCLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT0QsT0FBT0UsVUFBVSxDQUFDQyxNQUFNLEdBQUdILE9BQU9FLFVBQVUsQ0FBQ0UsS0FBSztRQUUzRCxLQUFLO1lBQ0gsOERBQThEO1lBQzlELGdFQUFnRTtZQUNoRSxPQUFPSixPQUFPRSxVQUFVLENBQUNDLE1BQU0sR0FBR0gsT0FBT0UsVUFBVSxDQUFDRSxLQUFLLEdBQUc7UUFFOUQsS0FBSztZQUNILGlDQUFpQztZQUNqQyxPQUFPSixPQUFPRSxVQUFVLENBQUNDLE1BQU0sR0FBR0gsT0FBT0UsVUFBVSxDQUFDRSxLQUFLLEdBQUc7UUFFOUQsS0FBSztZQUNILGlDQUFpQztZQUNqQyxPQUFPSixPQUFPRSxVQUFVLENBQUNDLE1BQU0sR0FBR0gsT0FBT0UsVUFBVSxDQUFDRSxLQUFLLEdBQUc7UUFFOUQsS0FBSztnQkFDQ0o7WUFBSixLQUFJQSx1QkFBQUEsT0FBT0ssWUFBWSxjQUFuQkwsMkNBQUFBLHFCQUFxQk0sTUFBTSxFQUFFO2dCQUMvQixPQUFPQyxxQkFBcUJQLE9BQU9LLFlBQVksQ0FBQ0MsTUFBTTtZQUN4RDtZQUNBLE9BQU87UUFFVDtZQUNFLE9BQU87SUFDWDtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxxQkFBcUJELE1BQTJCO0lBQzlELElBQUlBLE9BQU9ILE1BQU0sR0FBRyxHQUFHLE9BQU87SUFFOUIsSUFBSUssT0FBTztJQUNYLE1BQU1DLElBQUlILE9BQU9ILE1BQU07SUFFdkIsSUFBSyxJQUFJTyxJQUFJLEdBQUdBLElB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O0lBTTNCLE1BQU1DLFdBQVdyQixhQUFhbUI7SUFDOUIsTUFBTUcsWUFBWVQsWUFBWU87SUFDOUIsTUFBTUcsWUFBWUYsV0FBV0M7SUFFN0IsT0FBTztRQUNMRCxVQUFVTCxPQUFPSyxTQUFTSixPQUFPLENBQUM7UUFDbENLLFdBQVdOLE9BQU9NLFVBQVVMLE9BQU8sQ0FBQztRQUNwQ00sV0FBV1AsT0FBT08sVUFBVU4sT0FBTyxDQUFDO0lBQ3RDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3RpbGUtY2FsY3VsYXRpb25zLnRzPzcyZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBQcm9qZWN0LCBMYXlvdXRQYXR0ZXJuLCBVbml0LCBDdXN0b21MYXlvdXRQb2ludCB9IGZyb20gJ0AvdHlwZXMnXHJcbmltcG9ydCB7IG5vcm1hbGl6ZVRvTW0sIGNvbnZlcnRGcm9tTW0gfSBmcm9tICcuL3VuaXQtY29udmVyc2lvbnMnXHJcblxyXG5pbnRlcmZhY2UgVGlsZUNhbGN1bGF0aW9uUmVzdWx0IHtcclxuICB0b3RhbEFyZWE6IG51bWJlclxyXG4gIHRpbGVBcmVhOiBudW1iZXJcclxuICB0b3RhbFRpbGVzOiBudW1iZXJcclxuICBmdWxsVGlsZXM6IG51bWJlclxyXG4gIGN1dFRpbGVzOiBudW1iZXJcclxuICB3YXN0ZVBlcmNlbnRhZ2U6IG51bWJlclxyXG4gIGdyb3V0QXJlYTogbnVtYmVyXHJcbiAgY292ZXJhZ2U6IG51bWJlclxyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIHRvdGFsIGFyZWEgZm9yIGRpZmZlcmVudCBsYXlvdXQgc2hhcGVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTGF5b3V0QXJlYShwcm9qZWN0OiBQcm9qZWN0KTogbnVtYmVyIHtcclxuICBjb25zdCB7IGxheW91dCB9ID0gcHJvamVjdFxyXG5cclxuICBpZiAoIWxheW91dCkgcmV0dXJuIDBcclxuXHJcbiAgc3dpdGNoIChsYXlvdXQuc2hhcGUpIHtcclxuICAgIGNhc2UgJ3JlY3RhbmdsZSc6XHJcbiAgICBjYXNlICdzcXVhcmUnOlxyXG4gICAgICByZXR1cm4gbGF5b3V0LmRpbWVuc2lvbnMubGVuZ3RoICogbGF5b3V0LmRpbWVuc2lvbnMud2lkdGhcclxuXHJcbiAgICBjYXNlICdsLXNoYXBlJzpcclxuICAgICAgLy8gU2ltcGxpZmllZCBMLXNoYXBlIGNhbGN1bGF0aW9uIC0gYXNzdW1lIGl0J3MgdHdvIHJlY3RhbmdsZXNcclxuICAgICAgLy8gSW4gYSByZWFsIGFwcCwgeW91J2QgaGF2ZSBtb3JlIGRldGFpbGVkIEwtc2hhcGUgY29uZmlndXJhdGlvblxyXG4gICAgICByZXR1cm4gbGF5b3V0LmRpbWVuc2lvbnMubGVuZ3RoICogbGF5b3V0LmRpbWVuc2lvbnMud2lkdGggKiAwLjc1XHJcblxyXG4gICAgY2FzZSAndS1zaGFwZSc6XHJcbiAgICAgIC8vIFNpbXBsaWZpZWQgVS1zaGFwZSBjYWxjdWxhdGlvblxyXG4gICAgICByZXR1cm4gbGF5b3V0LmRpbWVuc2lvbnMubGVuZ3RoICogbGF5b3V0LmRpbWVuc2lvbnMud2lkdGggKiAwLjhcclxuXHJcbiAgICBjYXNlICd0LXNoYXBlJzpcclxuICAgICAgLy8gU2ltcGxpZmllZCBULXNoYXBlIGNhbGN1bGF0aW9uXHJcbiAgICAgIHJldHVybiBsYXlvdXQuZGltZW5zaW9ucy5sZW5ndGggKiBsYXlvdXQuZGltZW5zaW9ucy53aWR0aCAqIDAuN1xyXG5cclxuICAgIGNhc2UgJ2N1c3RvbSc6XHJcbiAgICAgIGlmIChsYXlvdXQuY3VzdG9tTGF5b3V0Py5wb2ludHMpIHtcclxuICAgICAgICByZXR1cm4gY2FsY3VsYXRlUG9seWdvbkFyZWEobGF5b3V0LmN1c3RvbUxheW91dC5wb2ludHMpXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIDBcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gMFxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBhcmVhIG9mIGEgcG9seWdvbiB1c2luZyB0aGUgc2hvZWxhY2UgZm9ybXVsYVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVBvbHlnb25BcmVhKHBvaW50czogQ3VzdG9tTGF5b3V0UG9pbnRbXSk6IG51bWJlciB7XHJcbiAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSByZXR1cm4gMFxyXG5cclxuICBsZXQgYXJlYSA9IDBcclxuICBjb25zdCBuID0gcG9pbnRzLmxlbmd0aFxyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgY29uc3QgaiA9IChpICsgMSkgJSBuXHJcbiAgICBhcmVhICs9IHBvaW50c1tpXS54ICogcG9pbnRzW2pdLnlcclxuICAgIGFyZWEgLT0gcG9pbnRzW2pdLnggKiBwb2ludHNbaV0ueVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIE1hdGguYWJzKGFyZWEpIC8gMlxyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIG51bWJlciBvZiB0aWxlcyBuZWVkZWQgYmFzZWQgb24gcGF0dGVyblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVRpbGVzQnlQYXR0ZXJuKFxyXG4gIHJvb21BcmVhOiBudW1iZXIsXHJcbiAgdGlsZUxlbmd0aDogbnVtYmVyLFxyXG4gIHRpbGVXaWR0aDogbnVtYmVyLFxyXG4gIGdyb3V0V2lkdGg6IG51bWJlcixcclxuICBwYXR0ZXJuOiBMYXlvdXRQYXR0ZXJuLFxyXG4gIHVuaXQ6IFVuaXRcclxuKToge1xyXG4gIHRvdGFsVGlsZXM6IG51bWJlclxyXG4gIGZ1bGxUaWxlczogbnVtYmVyXHJcbiAgY3V0VGlsZXM6IG51bWJlclxyXG4gIHdhc3RlUGVyY2VudGFnZTogbnVtYmVyXHJcbn0ge1xyXG4gIC8vIE5vcm1hbGl6ZSBhbGwgbWVhc3VyZW1lbnRzIHRvIG1tIGZvciBjb25zaXN0ZW50IGNhbGN1bGF0aW9uXHJcbiAgY29uc3Qgcm9vbUFyZWFNbSA9IG5vcm1hbGl6ZVRvTW0ocm9vbUFyZWEsIHVuaXQgKyAnwrInIGFzIFVuaXQpXHJcbiAgY29uc3QgdGlsZUxlbmd0aE1tID0gbm9ybWFsaXplVG9NbSh0aWxlTGVuZ3RoLCB1bml0KVxyXG4gIGNvbnN0IHRpbGVXaWR0aE1tID0gbm9ybWFsaXplVG9NbSh0aWxlV2lkdGgsIHVuaXQpXHJcbiAgY29uc3QgZ3JvdXRXaWR0aE1tID0gbm9ybWFsaXplVG9NbShncm91dFdpZHRoLCB1bml0KVxyXG5cclxuICAvLyBDYWxjdWxhdGUgZWZmZWN0aXZlIHRpbGUgc2l6ZSBpbmNsdWRpbmcgZ3JvdXRcclxuICBjb25zdCBlZmZlY3RpdmVUaWxlTGVuZ3RoID0gdGlsZUxlbmd0aE1tICsgZ3JvdXRXaWR0aE1tXHJcbiAgY29uc3QgZWZmZWN0aXZlVGlsZVdpZHRoID0gdGlsZVdpZHRoTW0gKyBncm91dFdpZHRoTW1cclxuICBjb25zdCBlZmZlY3RpdmVUaWxlQXJlYSA9IGVmZmVjdGl2ZVRpbGVMZW5ndGggKiBlZmZlY3RpdmVUaWxlV2lkdGhcclxuXHJcbiAgLy8gQmFzZSBjYWxjdWxhdGlvblxyXG4gIGxldCBiYXNlVGlsZXNOZWVkZWQgPSBNYXRoLmNlaWwocm9vbUFyZWFNbSAvIGVmZmVjdGl2ZVRpbGVBcmVhKVxyXG5cclxuICAvLyBQYXR0ZXJuLXNwZWNpZmljIGFkanVzdG1lbnRzXHJcbiAgbGV0IHdhc3RlUGVyY2VudGFnZTogbnVtYmVyXHJcbiAgbGV0IGN1dFRpbGVSYXRpbzogbnVtYmVyXHJcblxyXG4gIHN3aXRjaCAocGF0dGVybikge1xyXG4gICAgY2FzZSAnZ3JpZCc6XHJcbiAgICAgIHdhc3RlUGVyY2VudGFnZSA9IDUgLy8gNSUgd2FzdGUgZm9yIGdyaWQgcGF0dGVyblxyXG4gICAgICBjdXRUaWxlUmF0aW8gPSAwLjE1IC8vIDE1JSBvZiB0aWxlcyB3aWxsIG5lZWQgY3V0dGluZ1xyXG4gICAgICBicmVha1xyXG5cclxuICAgIGNhc2UgJ2JyaWNrJzpcclxuICAgICAgd2FzdGVQZXJjZW50YWdlID0gOCAvLyA4JSB3YXN0ZSBmb3IgYnJpY2svcnVubmluZyBib25kXHJcbiAgICAgIGN1dFRpbGVSYXRpbyA9IDAuMjUgLy8gMjUlIG9mIHRpbGVzIHdpbGwgbmVlZCBjdXR0aW5nXHJcbiAgICAgIGJhc2VUaWxlc05lZWRlZCAqPSAxLjA1IC8vIFNsaWdodCBpbmNyZWFzZSBmb3IgYnJpY2sgcGF0dGVyblxyXG4gICAgICBicmVha1xyXG5cclxuICAgIGNhc2UgJ2hlcnJpbmdib25lJzpcclxuICAgICAgd2FzdGVQZXJjZW50YWdlID0gMTUgLy8gMTUlIHdhc3RlIGZvciBoZXJyaW5nYm9uZSAobW9zdCBjb21wbGV4KVxyXG4gICAgICBjdXRUaWxlUmF0aW8gPSAwLjQgLy8gNDAlIG9mIHRpbGVzIHdpbGwgbmVlZCBjdXR0aW5nXHJcbiAgICAgIGJhc2VUaWxlc05lZWRlZCAqPSAxLjE1IC8vIFNpZ25pZmljYW50IGluY3JlYXNlIGZvciBoZXJyaW5nYm9uZSBjb21wbGV4aXR5XHJcbiAgICAgIGJyZWFrXHJcblxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgd2FzdGVQZXJjZW50YWdlID0gNVxyXG4gICAgICBjdXRUaWxlUmF0aW8gPSAwLjE1XHJcbiAgfVxyXG5cclxuICBjb25zdCB0b3RhbFRpbGVzID0gTWF0aC5jZWlsKGJhc2VUaWxlc05lZWRlZCAqICgxICsgd2FzdGVQZXJjZW50YWdlIC8gMTAwKSlcclxuICBjb25zdCBjdXRUaWxlcyA9IE1hdGguY2VpbCh0b3RhbFRpbGVzICogY3V0VGlsZVJhdGlvKVxyXG4gIGNvbnN0IGZ1bGxUaWxlcyA9IHRvdGFsVGlsZXMgLSBjdXRUaWxlc1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgdG90YWxUaWxlcyxcclxuICAgIGZ1bGxUaWxlcyxcclxuICAgIGN1dFRpbGVzLFxyXG4gICAgd2FzdGVQZXJjZW50YWdlXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIGdyb3V0IGFyZWFcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVHcm91dEFyZWEoXHJcbiAgcm9vbUFyZWE6IG51bWJlcixcclxuICB0aWxlTGVuZ3RoOiBudW1iZXIsXHJcbiAgdGlsZVdpZHRoOiBudW1iZXIsXHJcbiAgZ3JvdXRXaWR0aDogbnVtYmVyLFxyXG4gIHRvdGFsVGlsZXM6IG51bWJlcixcclxuICB1bml0OiBVbml0XHJcbik6IG51bWJlciB7XHJcbiAgLy8gTm9ybWFsaXplIG1lYXN1cmVtZW50c1xyXG4gIGNvbnN0IHRpbGVMZW5ndGhNbSA9IG5vcm1hbGl6ZVRvTW0odGlsZUxlbmd0aCwgdW5pdClcclxuICBjb25zdCB0aWxlV2lkdGhNbSA9IG5vcm1hbGl6ZVRvTW0odGlsZVdpZHRoLCB1bml0KVxyXG4gIGNvbnN0IGdyb3V0V2lkdGhNbSA9IG5vcm1hbGl6ZVRvTW0oZ3JvdXRXaWR0aCwgdW5pdClcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIHRpbGUgYXJlYSB2cyB0b3RhbCBhcmVhXHJcbiAgY29uc3Qgc2luZ2xlVGlsZUFyZWEgPSB0aWxlTGVuZ3RoTW0gKiB0aWxlV2lkdGhNbVxyXG4gIGNvbnN0IHRvdGFsVGlsZUFyZWEgPSBzaW5nbGVUaWxlQXJlYSAqIHRvdGFsVGlsZXNcclxuXHJcbiAgLy8gQ29udmVydCByb29tIGFyZWEgdG8gbW3CslxyXG4gIGNvbnN0IHJvb21BcmVhTW0gPSBub3JtYWxpemVUb01tKHJvb21BcmVhLCB1bml0ICsgJ8KyJyBhcyBVbml0KVxyXG5cclxuICAvLyBHcm91dCBhcmVhIGlzIHRoZSBkaWZmZXJlbmNlIHBsdXMgYWRkaXRpb25hbCBmb3Igam9pbnQgaW50ZXJzZWN0aW9uc1xyXG4gIGNvbnN0IGJhc2VHcm91dEFyZWEgPSByb29tQXJlYU1tIC0gdG90YWxUaWxlQXJlYVxyXG4gIGNvbnN0IGpvaW50SW50ZXJzZWN0aW9uQXJlYSA9IHRvdGFsVGlsZXMgKiAoZ3JvdXRXaWR0aE1tICogZ3JvdXRXaWR0aE1tKVxyXG5cclxuICByZXR1cm4gTWF0aC5tYXgoMCwgYmFzZUdyb3V0QXJlYSArIGpvaW50SW50ZXJzZWN0aW9uQXJlYSlcclxufVxyXG5cclxuLyoqXHJcbiAqIE1haW4gY2FsY3VsYXRpb24gZnVuY3Rpb24gZm9yIGNvbXBsZXRlIHByb2plY3RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQcm9qZWN0KHByb2plY3Q6IFByb2plY3QpOiBUaWxlQ2FsY3VsYXRpb25SZXN1bHQgfCBudWxsIHtcclxuICBjb25zdCB7IGxheW91dCwgdGlsZSB9ID0gcHJvamVjdFxyXG5cclxuICBpZiAoIWxheW91dD8uZGltZW5zaW9ucyB8fCAhdGlsZSkgcmV0dXJuIG51bGxcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIHRvdGFsIGFyZWFcclxuICBjb25zdCB0b3RhbEFyZWEgPSBjYWxjdWxhdGVMYXlvdXRBcmVhKHByb2plY3QpXHJcblxyXG4gIGlmICh0b3RhbEFyZWEgPD0gMCkgcmV0dXJuIG51bGxcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGluZGl2aWR1YWwgdGlsZSBhcmVhXHJcbiAgY29uc3QgdGlsZUFyZWEgPSAodGlsZS5sZW5ndGggLyAxMDAwKSAqICh0aWxlLndpZHRoIC8gMTAwMCkgLy8gQ29udmVydCBtbSB0byBtIGZvciBkaXNwbGF5XHJcblxyXG4gIC8vIENhbGN1bGF0ZSB0aWxlcyBuZWVkZWQgYnkgcGF0dGVyblxyXG4gIGNvbnN0IHtcclxuICAgIHRvdGFsVGlsZXMsXHJcbiAgICBmdWxsVGlsZXMsXHJcbiAgICBjdXRUaWxlcyxcclxuICAgIHdhc3RlUGVyY2VudGFnZVxyXG4gIH0gPSBjYWxjdWxhdGVUaWxlc0J5UGF0dGVybihcclxuICAgIHRvdGFsQXJlYSxcclxuICAgIHRpbGUubGVuZ3RoLFxyXG4gICAgdGlsZS53aWR0aCxcclxuICAgIHRpbGUuZ3JvdXRXaWR0aCxcclxuICAgIGxheW91dC5wYXR0ZXJuLFxyXG4gICAgbGF5b3V0LmRpbWVuc2lvbnMudW5pdFxyXG4gIClcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGdyb3V0IGFyZWFcclxuICBjb25zdCBncm91dEFyZWEgPSBjYWxjdWxhdGVHcm91dEFyZWEoXHJcbiAgICB0b3RhbEFyZWEsXHJcbiAgICB0aWxlLmxlbmd0aCxcclxuICAgIHRpbGUud2lkdGgsXHJcbiAgICB0aWxlLmdyb3V0V2lkdGgsXHJcbiAgICB0b3RhbFRpbGVzLFxyXG4gICAgbGF5b3V0LmRpbWVuc2lvbnMudW5pdFxyXG4gIClcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGNvdmVyYWdlIHBlcmNlbnRhZ2VcclxuICBjb25zdCBhY3R1YWxUaWxlQXJlYSA9IGZ1bGxUaWxlcyAqIHRpbGVBcmVhXHJcbiAgY29uc3QgY292ZXJhZ2UgPSB0b3RhbEFyZWEgPiAwID8gKGFjdHVhbFRpbGVBcmVhIC8gdG90YWxBcmVhKSAqIDEwMCA6IDBcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHRvdGFsQXJlYTogTnVtYmVyKHRvdGFsQXJlYS50b0ZpeGVkKDIpKSxcclxuICAgIHRpbGVBcmVhOiBOdW1iZXIodGlsZUFyZWEudG9GaXhlZCg2KSksXHJcbiAgICB0b3RhbFRpbGVzLFxyXG4gICAgZnVsbFRpbGVzLFxyXG4gICAgY3V0VGlsZXMsXHJcbiAgICB3YXN0ZVBlcmNlbnRhZ2UsXHJcbiAgICBncm91dEFyZWE6IE51bWJlcihjb252ZXJ0RnJvbU1tKGdyb3V0QXJlYSwgbGF5b3V0LmRpbWVuc2lvbnMudW5pdCkudG9GaXhlZCgyKSksXHJcbiAgICBjb3ZlcmFnZTogTnVtYmVyKGNvdmVyYWdlLnRvRml4ZWQoMSkpXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRXN0aW1hdGUgcHJvamVjdCBjb3N0IChiYXNpYyBjYWxjdWxhdGlvbilcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZVByb2plY3RDb3N0KFxyXG4gIHRvdGFsVGlsZXM6IG51bWJlcixcclxuICB0aWxlUHJpY2U6IG51bWJlcixcclxuICBncm91dEFyZWE6IG51bWJlcixcclxuICBncm91dFByaWNlUGVyU3FNOiBudW1iZXIgPSAxMFxyXG4pOiB7XHJcbiAgdGlsZUNvc3Q6IG51bWJlclxyXG4gIGdyb3V0Q29zdDogbnVtYmVyXHJcbiAgdG90YWxDb3N0OiBudW1iZXJcclxufSB7XHJcbiAgY29uc3QgdGlsZUNvc3QgPSB0b3RhbFRpbGVzICogdGlsZVByaWNlXHJcbiAgY29uc3QgZ3JvdXRDb3N0ID0gZ3JvdXRBcmVhICogZ3JvdXRQcmljZVBlclNxTVxyXG4gIGNvbnN0IHRvdGFsQ29zdCA9IHRpbGVDb3N0ICsgZ3JvdXRDb3N0XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB0aWxlQ29zdDogTnVtYmVyKHRpbGVDb3N0LnRvRml4ZWQoMikpLFxyXG4gICAgZ3JvdXRDb3N0OiBOdW1iZXIoZ3JvdXRDb3N0LnRvRml4ZWQoMikpLFxyXG4gICAgdG90YWxDb3N0OiBOdW1iZXIodG90YWxDb3N0LnRvRml4ZWQoMikpXHJcbiAgfVxyXG59Il0sIm5hbWVzIjpbIm5vcm1hbGl6ZVRvTW0iLCJjb252ZXJ0RnJvbU1tIiwiY2FsY3VsYXRlTGF5b3V0QXJlYSIsInByb2plY3QiLCJsYXlvdXQiLCJzaGFwZSIsImRpbWVuc2lvbnMiLCJsZW5ndGgiLCJ3aWR0aCIsImN1c3RvbUxheW91dCIsInBvaW50cyIsImNhbGN1bGF0ZVBvbHlnb25BcmVhIiwiYXJlYSIsIm4iLCJpIiwiaiIsIngiLCJ5IiwiTWF0aCIsImFicyIsImNhbGN1bGF0ZVRpbGVzQnlQYXR0ZXJuIiwicm9vbUFyZWEiLCJ0aWxlTGVuZ3RoIiwidGlsZVdpZHRoIiwiZ3JvdXRXaWR0aCIsInBhdHRlcm4iLCJ1bml0Iiwicm9vbUFyZWFNbSIsInRpbGVMZW5ndGhNbSIsInRpbGVXaWR0aE1tIiwiZ3JvdXRXaWR0aE1tIiwiZWZmZWN0aXZlVGlsZUxlbmd0aCIsImVmZmVjdGl2ZVRpbGVXaWR0aCIsImVmZmVjdGl2ZVRpbGVBcmVhIiwiYmFzZVRpbGVzTmVlZGVkIiwiY2VpbCIsIndhc3RlUGVyY2VudGFnZSIsImN1dFRpbGVSYXRpbyIsInRvdGFsVGlsZXMiLCJjdXRUaWxlcyIsImZ1bGxUaWxlcyIsImNhbGN1bGF0ZUdyb3V0QXJlYSIsInNpbmdsZVRpbGVBcmVhIiwidG90YWxUaWxlQXJlYSIsImJhc2VHcm91dEFyZWEiLCJqb2ludEludGVyc2VjdGlvbkFyZWEiLCJtYXgiLCJjYWxjdWxhdGVQcm9qZWN0IiwidGlsZSIsInRvdGFsQXJlYSIsInRpbGVBcmVhIiwiZ3JvdXRBcmVhIiwiYWN0dWFsVGlsZUFyZWEiLCJjb3ZlcmFnZSIsIk51bWJlciIsInRvRml4ZWQiLCJlc3RpbWF0ZVByb2plY3RDb3N0IiwidGlsZVByaWNlIiwiZ3JvdXRQcmljZVBlclNxTSIsInRpbGVDb3N0IiwiZ3JvdXRDb3N0IiwidG90YWxDb3N0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/tile-calculations.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/unit-conversions.ts":
/*!***************************************!*\
  !*** ./src/utils/unit-conversions.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertArea: function() { return /* binding */ convertArea; },\n/* harmony export */   convertFromMm: function() { return /* binding */ convertFromMm; },\n/* harmony export */   convertUnit: function() { return /* binding */ convertUnit; },\n/* harmony export */   formatWithUnit: function() { return /* binding */ formatWithUnit; },\n/* harmony export */   getUnitDisplayName: function() { return /* binding */ getUnitDisplayName; },\n/* harmony export */   getUnitPrecision: function() { return /* binding */ getUnitPrecision; },\n/* harmony export */   getUnitShortName: function() { return /* binding */ getUnitShortName; },\n/* harmony export */   getUnitStep: function() { return /* binding */ getUnitStep; },\n/* harmony export */   isImperialUnit: function() { return /* binding */ isImperialUnit; },\n/* harmony export */   isMetricUnit: function() { return /* binding */ isMetricUnit; },\n/* harmony export */   normalizeToMm: function() { return /* binding */ normalizeToMm; }\n/* harmony export */ });\n// Convert-units doesn't include all our units, so we'll create our own conversion system\nconst UNIT_TO_METERS = {\n    mm: 0.001,\n    cm: 0.01,\n    m: 1,\n    in: 0.0254,\n    ft: 0.3048\n};\nconst UNIT_TO_MM = {\n    mm: 1,\n    cm: 10,\n    m: 1000,\n    in: 25.4,\n    ft: 304.8\n};\n/**\r\n * Convert a value from one unit to another\r\n */ function convertUnit(value, fromUnit, toUnit) {\n    if (fromUnit === toUnit) return value;\n    // Convert to meters first, then to target unit\n    const valueInMeters = value * UNIT_TO_METERS[fromUnit];\n    const convertedValue = valueInMeters / UNIT_TO_METERS[toUnit];\n    return convertedValue;\n}\n/**\r\n * Convert area from one unit to another (squared units)\r\n */ function convertArea(area, fromUnit, toUnit) {\n    if (fromUnit === toUnit) return area;\n    const conversionFactor = UNIT_TO_METERS[fromUnit] / UNIT_TO_METERS[toUnit];\n    return area * (conversionFactor * conversionFactor);\n}\n/**\r\n * Normalize all measurements to millimeters for consistent calculations\r\n */ function normalizeToMm(value, unit) {\n    return value * UNIT_TO_MM[unit];\n}\n/**\r\n * Convert from millimeters to specified unit\r\n */ function convertFromMm(value, unit) {\n    return value / UNIT_TO_MM[unit];\n}\n/**\r\n * Get display name for unit\r\n */ function getUnitDisplayName(unit) {\n    let plural = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    const names = {\n        mm: plural ? \"millimeters\" : \"millimeter\",\n        cm: plural ? \"centimeters\" : \"centimeter\",\n        m: plural ? \"meters\" : \"meter\",\n        in: plural ? \"inches\" : \"inch\",\n        ft: plural ? \"feet\" : \"foot\"\n    };\n    return names[unit];\n}\n/**\r\n * Get short display name for unit\r\n */ function getUnitShortName(unit) {\n    return unit;\n}\n/**\r\n * Format a number with unit for display\r\n */ function formatWithUnit(value, unit) {\n    let decimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    const formattedValue = value.toFixed(decimals).replace(/\\\\.?0+$/, \"\");\n    return \"\".concat(formattedValue, \" \").concat(unit);\n}\n/**\r\n * Get appropriate precision based on unit\r\n */ function getUnitPrecision(unit) {\n    switch(unit){\n        case \"mm\":\n            return 0;\n        case \"cm\":\n            return 1;\n        case \"m\":\n            return 2;\n        case \"in\":\n            return 2;\n        case \"ft\":\n            return 2;\n        default:\n            return 2;\n    }\n}\n/**\r\n * Check if unit is metric\r\n */ function isMetricUnit(unit) {\n    return [\n        \"mm\",\n        \"cm\",\n        \"m\"\n    ].includes(unit);\n}\n/**\r\n * Check if unit is imperial\r\n */ function isImperialUnit(unit) {\n    return [\n        \"in\",\n        \"ft\"\n    ].includes(unit);\n}\n/**\r\n * Get suggested step value for input based on unit\r\n */ function getUnitStep(unit) {\n    switch(unit){\n        case \"mm\":\n            return 1;\n        case \"cm\":\n            return 0.1;\n        case \"m\":\n            return 0.01;\n        case \"in\":\n            return 0.1;\n        case \"ft\":\n            return 0.1;\n        default:\n            return 0.1;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy91bml0LWNvbnZlcnNpb25zLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBR0EseUZBQXlGO0FBQ3pGLE1BQU1BLGlCQUFpQjtJQUNyQkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0FBQ047QUFFQSxNQUFNQyxhQUFhO0lBQ2pCTCxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsR0FBRztJQUNIQyxJQUFJO0lBQ0pDLElBQUk7QUFDTjtBQUVBOztDQUVDLEdBQ00sU0FBU0UsWUFBWUMsS0FBYSxFQUFFQyxRQUFjLEVBQUVDLE1BQVk7SUFDckUsSUFBSUQsYUFBYUMsUUFBUSxPQUFPRjtJQUVoQywrQ0FBK0M7SUFDL0MsTUFBTUcsZ0JBQWdCSCxRQUFRUixjQUFjLENBQUNTLFNBQVM7SUFDdEQsTUFBTUcsaUJBQWlCRCxnQkFBZ0JYLGNBQWMsQ0FBQ1UsT0FBTztJQUU3RCxPQUFPRTtBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxZQUFZQyxJQUFZLEVBQUVMLFFBQWMsRUFBRUMsTUFBWTtJQUNwRSxJQUFJRCxhQUFhQyxRQUFRLE9BQU9JO0lBRWhDLE1BQU1DLG1CQUFtQmYsY0FBYyxDQUFDUyxTQUFTLEdBQUdULGNBQWMsQ0FBQ1UsT0FBTztJQUMxRSxPQUFPSSxPQUFRQyxDQUFBQSxtQkFBbUJBLGdCQUFlO0FBQ25EO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxjQUFjUixLQUFhLEVBQUVTLElBQVU7SUFDckQsT0FBT1QsUUFBUUYsVUFBVSxDQUFDVyxLQUFLO0FBQ2pDO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxjQUFjVixLQUFhLEVBQUVTLElBQVU7SUFDckQsT0FBT1QsUUFBUUYsVUFBVSxDQUFDVyxLQUFLO0FBQ2pDO0FBRUE7O0NBRUMsR0FDTSxTQUFTRSxtQkFBbUJGLElBQVU7UUFBRUcsU0FBQUEsaUVBQVM7SUFDdEQsTUFBTUMsUUFBUTtRQUNacEIsSUFBSW1CLFNBQVMsZ0JBQWdCO1FBQzdCbEIsSUFBSWtCLFNBQVMsZ0JBQWdCO1FBQzdCakIsR0FBR2lCLFNBQVMsV0FBVztRQUN2QmhCLElBQUlnQixTQUFTLFdBQVc7UUFDeEJmLElBQUllLFNBQVMsU0FBUztJQUN4QjtJQUVBLE9BQU9DLEtBQUssQ0FBQ0osS0FBSztBQUNwQjtBQUVBOztDQUVDLEdBQ00sU0FBU0ssaUJBQWlCTCxJQUFVO0lBQ3pDLE9BQU9BO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNNLGVBQWVmLEtBQWEsRUFBRVMsSUFBVTtRQUFFTyxXQUFBQSxpRUFBVztJQUNuRSxNQUFNQyxpQkFBaUJqQixNQUFNa0IsT0FBTyxDQUFDRixVQUFVRyxPQUFPLENBQUMsV0FBVztJQUNsRSxPQUFPLEdBQXFCVixPQUFsQlEsZ0JBQWUsS0FBUSxPQUFMUjtBQUM5QjtBQUVBOztDQUVDLEdBQ00sU0FBU1csaUJBQWlCWCxJQUFVO0lBQ3pDLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBTztJQUNYO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNZLGFBQWFaLElBQVU7SUFDckMsT0FBTztRQUFDO1FBQU07UUFBTTtLQUFJLENBQUNhLFFBQVEsQ0FBQ2I7QUFDcEM7QUFFQTs7Q0FFQyxHQUNNLFNBQVNjLGVBQWVkLElBQVU7SUFDdkMsT0FBTztRQUFDO1FBQU07S0FBSyxDQUFDYSxRQUFRLENBQUNiO0FBQy9CO0FBRUE7O0NBRUMsR0FDTSxTQUFTZSxZQUFZZixJQUFVO0lBQ3BDLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBTztJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3VuaXQtY29udmVyc2lvbnMudHM/M2NjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY29udmVydCBmcm9tICdjb252ZXJ0LXVuaXRzJ1xyXG5pbXBvcnQgdHlwZSB7IFVuaXQgfSBmcm9tICdAL3R5cGVzJ1xyXG5cclxuLy8gQ29udmVydC11bml0cyBkb2Vzbid0IGluY2x1ZGUgYWxsIG91ciB1bml0cywgc28gd2UnbGwgY3JlYXRlIG91ciBvd24gY29udmVyc2lvbiBzeXN0ZW1cclxuY29uc3QgVU5JVF9UT19NRVRFUlMgPSB7XHJcbiAgbW06IDAuMDAxLFxyXG4gIGNtOiAwLjAxLFxyXG4gIG06IDEsXHJcbiAgaW46IDAuMDI1NCxcclxuICBmdDogMC4zMDQ4XHJcbn0gYXMgY29uc3RcclxuXHJcbmNvbnN0IFVOSVRfVE9fTU0gPSB7XHJcbiAgbW06IDEsXHJcbiAgY206IDEwLFxyXG4gIG06IDEwMDAsXHJcbiAgaW46IDI1LjQsXHJcbiAgZnQ6IDMwNC44XHJcbn0gYXMgY29uc3RcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgdmFsdWUgZnJvbSBvbmUgdW5pdCB0byBhbm90aGVyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVuaXQodmFsdWU6IG51bWJlciwgZnJvbVVuaXQ6IFVuaXQsIHRvVW5pdDogVW5pdCk6IG51bWJlciB7XHJcbiAgaWYgKGZyb21Vbml0ID09PSB0b1VuaXQpIHJldHVybiB2YWx1ZVxyXG4gIFxyXG4gIC8vIENvbnZlcnQgdG8gbWV0ZXJzIGZpcnN0LCB0aGVuIHRvIHRhcmdldCB1bml0XHJcbiAgY29uc3QgdmFsdWVJbk1ldGVycyA9IHZhbHVlICogVU5JVF9UT19NRVRFUlNbZnJvbVVuaXRdXHJcbiAgY29uc3QgY29udmVydGVkVmFsdWUgPSB2YWx1ZUluTWV0ZXJzIC8gVU5JVF9UT19NRVRFUlNbdG9Vbml0XVxyXG4gIFxyXG4gIHJldHVybiBjb252ZXJ0ZWRWYWx1ZVxyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhcmVhIGZyb20gb25lIHVuaXQgdG8gYW5vdGhlciAoc3F1YXJlZCB1bml0cylcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0QXJlYShhcmVhOiBudW1iZXIsIGZyb21Vbml0OiBVbml0LCB0b1VuaXQ6IFVuaXQpOiBudW1iZXIge1xyXG4gIGlmIChmcm9tVW5pdCA9PT0gdG9Vbml0KSByZXR1cm4gYXJlYVxyXG4gIFxyXG4gIGNvbnN0IGNvbnZlcnNpb25GYWN0b3IgPSBVTklUX1RPX01FVEVSU1tmcm9tVW5pdF0gLyBVTklUX1RPX01FVEVSU1t0b1VuaXRdXHJcbiAgcmV0dXJuIGFyZWEgKiAoY29udmVyc2lvbkZhY3RvciAqIGNvbnZlcnNpb25GYWN0b3IpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgYWxsIG1lYXN1cmVtZW50cyB0byBtaWxsaW1ldGVycyBmb3IgY29uc2lzdGVudCBjYWxjdWxhdGlvbnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVUb01tKHZhbHVlOiBudW1iZXIsIHVuaXQ6IFVuaXQpOiBudW1iZXIge1xyXG4gIHJldHVybiB2YWx1ZSAqIFVOSVRfVE9fTU1bdW5pdF1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgZnJvbSBtaWxsaW1ldGVycyB0byBzcGVjaWZpZWQgdW5pdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRGcm9tTW0odmFsdWU6IG51bWJlciwgdW5pdDogVW5pdCk6IG51bWJlciB7XHJcbiAgcmV0dXJuIHZhbHVlIC8gVU5JVF9UT19NTVt1bml0XVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGRpc3BsYXkgbmFtZSBmb3IgdW5pdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaXREaXNwbGF5TmFtZSh1bml0OiBVbml0LCBwbHVyYWwgPSBmYWxzZSk6IHN0cmluZyB7XHJcbiAgY29uc3QgbmFtZXMgPSB7XHJcbiAgICBtbTogcGx1cmFsID8gJ21pbGxpbWV0ZXJzJyA6ICdtaWxsaW1ldGVyJyxcclxuICAgIGNtOiBwbHVyYWwgPyAnY2VudGltZXRlcnMnIDogJ2NlbnRpbWV0ZXInLFxyXG4gICAgbTogcGx1cmFsID8gJ21ldGVycycgOiAnbWV0ZXInLFxyXG4gICAgaW46IHBsdXJhbCA/ICdpbmNoZXMnIDogJ2luY2gnLFxyXG4gICAgZnQ6IHBsdXJhbCA/ICdmZWV0JyA6ICdmb290J1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gbmFtZXNbdW5pdF1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBzaG9ydCBkaXNwbGF5IG5hbWUgZm9yIHVuaXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRVbml0U2hvcnROYW1lKHVuaXQ6IFVuaXQpOiBzdHJpbmcge1xyXG4gIHJldHVybiB1bml0XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgYSBudW1iZXIgd2l0aCB1bml0IGZvciBkaXNwbGF5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0V2l0aFVuaXQodmFsdWU6IG51bWJlciwgdW5pdDogVW5pdCwgZGVjaW1hbHMgPSAyKTogc3RyaW5nIHtcclxuICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHZhbHVlLnRvRml4ZWQoZGVjaW1hbHMpLnJlcGxhY2UoL1xcXFwuPzArJC8sICcnKVxyXG4gIHJldHVybiBgJHtmb3JtYXR0ZWRWYWx1ZX0gJHt1bml0fWBcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhcHByb3ByaWF0ZSBwcmVjaXNpb24gYmFzZWQgb24gdW5pdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaXRQcmVjaXNpb24odW5pdDogVW5pdCk6IG51bWJlciB7XHJcbiAgc3dpdGNoICh1bml0KSB7XHJcbiAgICBjYXNlICdtbSc6XHJcbiAgICAgIHJldHVybiAwXHJcbiAgICBjYXNlICdjbSc6XHJcbiAgICAgIHJldHVybiAxXHJcbiAgICBjYXNlICdtJzpcclxuICAgICAgcmV0dXJuIDJcclxuICAgIGNhc2UgJ2luJzpcclxuICAgICAgcmV0dXJuIDJcclxuICAgIGNhc2UgJ2Z0JzpcclxuICAgICAgcmV0dXJuIDJcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiAyXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdW5pdCBpcyBtZXRyaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc01ldHJpY1VuaXQodW5pdDogVW5pdCk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBbJ21tJywgJ2NtJywgJ20nXS5pbmNsdWRlcyh1bml0KVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdW5pdCBpcyBpbXBlcmlhbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzSW1wZXJpYWxVbml0KHVuaXQ6IFVuaXQpOiBib29sZWFuIHtcclxuICByZXR1cm4gWydpbicsICdmdCddLmluY2x1ZGVzKHVuaXQpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgc3VnZ2VzdGVkIHN0ZXAgdmFsdWUgZm9yIGlucHV0IGJhc2VkIG9uIHVuaXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRVbml0U3RlcCh1bml0OiBVbml0KTogbnVtYmVyIHtcclxuICBzd2l0Y2ggKHVuaXQpIHtcclxuICAgIGNhc2UgJ21tJzpcclxuICAgICAgcmV0dXJuIDFcclxuICAgIGNhc2UgJ2NtJzpcclxuICAgICAgcmV0dXJuIDAuMVxyXG4gICAgY2FzZSAnbSc6XHJcbiAgICAgIHJldHVybiAwLjAxXHJcbiAgICBjYXNlICdpbic6XHJcbiAgICAgIHJldHVybiAwLjFcclxuICAgIGNhc2UgJ2Z0JzpcclxuICAgICAgcmV0dXJuIDAuMVxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIDAuMVxyXG4gIH1cclxufVxuIl0sIm5hbWVzIjpbIlVOSVRfVE9fTUVURVJTIiwibW0iLCJjbSIsIm0iLCJpbiIsImZ0IiwiVU5JVF9UT19NTSIsImNvbnZlcnRVbml0IiwidmFsdWUiLCJmcm9tVW5pdCIsInRvVW5pdCIsInZhbHVlSW5NZXRlcnMiLCJjb252ZXJ0ZWRWYWx1ZSIsImNvbnZlcnRBcmVhIiwiYXJlYSIsImNvbnZlcnNpb25GYWN0b3IiLCJub3JtYWxpemVUb01tIiwidW5pdCIsImNvbnZlcnRGcm9tTW0iLCJnZXRVbml0RGlzcGxheU5hbWUiLCJwbHVyYWwiLCJuYW1lcyIsImdldFVuaXRTaG9ydE5hbWUiLCJmb3JtYXRXaXRoVW5pdCIsImRlY2ltYWxzIiwiZm9ybWF0dGVkVmFsdWUiLCJ0b0ZpeGVkIiwicmVwbGFjZSIsImdldFVuaXRQcmVjaXNpb24iLCJpc01ldHJpY1VuaXQiLCJpbmNsdWRlcyIsImlzSW1wZXJpYWxVbml0IiwiZ2V0VW5pdFN0ZXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/unit-conversions.ts\n"));

/***/ })

}]);